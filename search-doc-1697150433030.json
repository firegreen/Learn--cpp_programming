[{"title":"Un peu de logique avec les conditions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Conditions","content":"","keywords":"","version":"Next"},{"title":"Les valeurs bool√©ennes‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#les-valeurs-bool√©ennes","content":"J'ai omis un type lors du pr√©c√©dent chapitre, il s'agit du type bool√©en, il s'utilise avec le mot cl√© bool. Ce type peut prendre deux valeurs: soit true, signifiant vrai, soit false qui veut dire faux. C'est donc id√©al pour stocker le r√©sultat d'une condition. Voici un petit exemple int main() { bool const condition { true }; return 0; }  Cela va devenir int√©ressant gr√¢ce √† ce que l'on appelle les op√©rateurs de comparaison. Op√©rateur\tSignification==\t√âgalit√©, compare si deux variables sont √©gales !=\tIn√©galit√©, compare si deux variables sont diff√©rentes &lt;\tStrictement inf√©rieur, compare si la variable de gauche est strictement inf√©rieure √† celle de droite &lt;=\tInf√©rieur ou √©gal, compare si la variable de gauche est inf√©rieure ou √©gale √† celle de droite &gt;\tStrictement sup√©rieur, compare si la variable de gauche est strictement sup√©rieure √† celle de droite &gt;=\tSup√©rieur ou √©gal, compare si la variable de gauche est sup√©rieure ou √©gale √† celle de droite Ces op√©rateurs vont nous permettre de cr√©er des conditions (des valeurs bool√©ennes) √† partir de nos autres variables. #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; != &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a != b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt; &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt; b) &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; &quot; &lt;= &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a &lt;= b) &lt;&lt; std::endl; // On peut aussi stocker le r√©sultat de la condition dans une variable bool√©enne float const price { 24.5f }; bool const is_too_expensive { price &gt;= 100.f }; return 0; }  remarque Par d√©faut, std::cout affiche 1 pour une condition vraie (true) et 0 pour une condition fausse (false). Il est possible de changer ce comportement en ajoutant un &quot;modificateur&quot; sur le stream std::cout: #include &lt;iostream&gt; int main() { float const a { 10.0f }; float const b { 20.0f }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; a &lt;&lt; &quot; == &quot; &lt;&lt; b &lt;&lt; &quot; donne &quot; &lt;&lt; (a == b) &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h2"},{"title":"La logique bool√©enne‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#la-logique-bool√©enne","content":"Maintenant que nous disposons d'un moyen d'obtenir une valeur bool√©enne (via les op√©rateurs de comparaison) nous allons pouvoir manipuler ces valeurs avec ce que l'on nomme des op√©rateurs logiques. Ces op√©rateurs vont permettre de combiner et modifier des valeurs bool√©ennes afin d'en obtenir d'autres et faire ce que l'on appelle plus g√©n√©ralement de l‚Äôalg√®bre bool√©enne. Mais ne vous inqui√©tez pas, derri√®re ce nom tr√®s math√©matique se cache des choses tr√®s simples. ","version":"Next","tagName":"h2"},{"title":"NOT: La n√©gation‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#not-la-n√©gation","content":"L'op√©rateur ! (plac√© devant une valeur bool√©enne) permet d'exprimer la n√©gation d'une condition. remarque C'est ici un op√©rateur dit unaire (qui s'applique sur une seule valeur) et donne en retour la condition inverse. Voici ce qu‚Äôon appelle la table de v√©rit√© de l‚Äôop√©rateur NOT, qui formalise les entr√©es et les sorties de cet op√©rateur. A\tR√©sultattrue\tfalse false\ttrue float price { 114.2f }; bool isExpensive { price &gt;= 100.f }; bool isCheap { !isExpensive };  ","version":"Next","tagName":"h3"},{"title":"AND‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#and","content":"L'op√©rateur &amp;&amp; (plac√© entre deux valeurs bool√©ennes) permet d'exprimer la validit√© de deux conditions en m√™me temps. On peut l'interpr√©ter en fran√ßais par : &quot;ma condition1 est vraie ET ma condition2 est aussi vraie&quot;. A\tB\tR√©sultattrue\ttrue\ttrue true\tfalse\tfalse false\ttrue\tfalse false\tfalse\tfalse ","version":"Next","tagName":"h3"},{"title":"OR‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#or","content":"L'op√©rateur || (plac√© entre deux valeurs bool√©ennes) permet d'exprimer si au moins une des deux conditions est vraie. On peut l'interpr√©ter en fran√ßais par : &quot;ma condition1 est vraie OU ma condition2 est vraie&quot;. A\tB\tR√©sultattrue\ttrue\ttrue true\tfalse\ttrue false\ttrue\ttrue false\tfalse\tfalse  remarque Il est √©galement possible d'utiliser les mots-cl√©s and, or et not pour remplacer respectivement les op√©rateurs &amp;&amp;, || et !. C'est possible mais tr√®s peu r√©pandu en C++ c'est pourquoi je ne l'utiliserai pas personnellement mais sachez que √ßa existe √©galement. Avec de vielles versions de Visual Studio il est possible que cette syntaxe ne fonctionne pas et dans ce cas il faut inclure le fichier &lt;ciso646&gt;. danger Pour l'op√©rateur AND (&amp;&amp;) on note qu'il y a bien deux fois le symbole &amp;. C'est tr√®s important car il existe un autre op√©rateur (avec un seul &amp;) qui fait tout autre chose. Je ne d√©taillerai pas dans ce chapitre son utilit√© mais il est important de le souligner car c'est une erreur qui arrive fr√©quemment. De m√™me pour l'op√©rateur OR (||) diff√©rent de |. ","version":"Next","tagName":"h2"},{"title":"Des structures de contr√¥le‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#des-structures-de-contr√¥le","content":"C'est bien beau toutes ces valeurs bool√©ennes mais comment on peut s'en servir pour ex√©cuter une partie d'un code ou un autre en fonction d'une condition ? ","version":"Next","tagName":"h2"},{"title":"Si‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#si","content":"Notre premi√®re structure de contr√¥le va s'utiliser avec le mot cl√© if. De l'anglais, ce mot cl√© signifiant &quot;si&quot;, ex√©cute des instructions si et seulement si la condition donn√©e est vraie. Un petit sch√©ma d'explications: Voil√† comment l'utiliser. Toutes les instructions entre accolades seront ex√©cut√©es si la condition est vraie. if( /* condtion */ ) { // ... }  Un petit exemple #include &lt;iostream&gt; int main() { float price { 114.2f }; if ( price &gt;= 100.f ) { // appliquer une r√©duction si l'on d√©passe un certain prix price *= 0.9f; } std::cout &lt;&lt; &quot;Le prix final est de &quot; &lt;&lt; price &lt;&lt; &quot;‚Ç¨&quot; &lt;&lt; std::endl; return 0; }  attention Il est possible de cr√©er des variables √† l'int√©rieur m√™me des accolades de la structure de contr√¥le mais celles-ci sont restreintes √† cette port√©e. C'est ce qu'on appelle la port√©e des variables (scope en anglais). Plus g√©n√©ralement, cette r√®gle du C++ s'applique √† n'importe quel bloc entre accolades.Une variable n‚Äôest utilisable que dans la port√©e, ou le bloc d‚Äôaccolades o√π elle a √©t√© d√©clar√©e. Nous en reparlerons plus en d√©tail dans d'autres chapitres. attention Il n'est pas tr√®s utile de tester par une √©galit√© le r√©sultat d'une condition : float const price { 114.2f }; bool const isExpensive { price &gt;= 100.f }; if ( isExpensive == true ) { // ... } isExpensive ici √©tant d√©j√† une valeur bool√©enne ajouter une √©galit√© suppl√©mentaire avec la valeur true ne va rien faire d'autre que de cr√©er une nouvelle valeur bool√©enne qui a la m√™me valeur. Il est donc plus clair et concis d'√©crire directement: bool const isExpensive { price &gt;= 100.f }; if ( isExpensive ) { // ... }  ","version":"Next","tagName":"h3"},{"title":"Sinon‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#sinon","content":"C'est tr√®s bien de pouvoir effectuer quelque chose si une condition est v√©rif√©e mais comment faire si l'on veut effectuer une action A si la condition est v√©rif√©e et une autre action B si ce n'est pas le cas ? On pourrait tr√®s bien encha√Æner deux if avec la condition oppos√©e: #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } if ( temperature &lt; 35.f ) { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }  Mais c'est l√† que le mot-cl√© else (de l'anglais &quot;sinon&quot;) nous permet d'ex√©cuter des instructions si la condition du if est fausse de mani√®re plus compr√©hensible: #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( temperature &gt;= 35.f ) { std::cout &lt;&lt; &quot;il fait chaud&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;il fait froid&quot; &lt;&lt; std::endl; } return 0; }  Ici le else n'a pas de parenth√®se et indique donc &quot;tout le reste&quot; (ce qui ne v√©rifie pas la condition). remarque L'op√©rateur logique de n√©gation ! est parfois tr√®s utile dans le cas o√π l'on avait stock√© une valeur mais l'on souhaite faire une suite d'instructions uniquement dans le bloc else du if. Au lieu de faire : #include &lt;iostream&gt; int main() { bool condition { false }; if ( condition ) { // ... ne rien faire } else { // effectuer nos instructions } return 0; } Il est pr√©f√©rable de faire: #include &lt;iostream&gt; int main() { bool condition { false }; if ( !condition ) { // effectuer nos instructions } return 0; }  Mais comment tester une succession de conditions diff√©rentes avant de faire &quot;tout le reste&quot;‚ÄØ? ","version":"Next","tagName":"h3"},{"title":"Sinon si‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#sinon-si","content":"On pourrait tr√®s bien cha√Æner plusieurs if et else imbriqu√©s de cette mani√®re: #include &lt;iostream&gt; int main() { float temperature { 24.0f }; if ( /* condition1 */ ) { // ... } else { if ( /* condition2 */ ) { // ... } else { if ( /* condition3 */ ) { //... } else { //... } } } return 0; }  Mais vous √™tes s√ªrement d'accord pour dire que √ßa commence √† √™tre difficile √† suivre et √©crire √† cause des imbrications. Le C++ est bien fait et nous permet de d'utiliser la combinaison else if pour ce cas de figure. else if s‚Äôutilise entre un if et un else et signifie &quot;ou alors si cette condition est vraie&quot;. #include &lt;iostream&gt; int main() { if ( /* condition1 */ ) { // ... } else if ( /* condition2 */ ) { // ... } else if ( /* condition3 */ ) { //... } else { //... } return 0; }  remarque Enfin, il existe une derni√®re syntaxe (le switch pour les curieux) qui permet de faire quelque chose de similaire au else if mais il nous manque quelques notions et je vous le pr√©senterai donc au chapitre suivant sur les boucles. ","version":"Next","tagName":"h3"},{"title":"Faux-ami‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#faux-ami","content":"danger Attention le test d'√©galit√© == est diff√©rent de l'op√©rateur d'affectation =. int number { 20 }; if ( number = 10 ) { // ... }  En C++, l'assignation retourne la valeur de la variable assign√©e. Ici, la condition sera vraie car number vaut 10 apr√®s l'assignation et 10 est consid√©r√© comme vrai. Les valeurs num√©riques non nulles sont consid√©r√©es comme vraies et la valeur 0 est consid√©r√©e comme fausse. ","version":"Next","tagName":"h2"},{"title":"Combinaison d'expressions‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#combinaison-dexpressions","content":"Avec tous les op√©rateurs logiques vu pr√©c√©demment il est m√™me possible de tester plusieurs conditions dans un m√™me if. #include &lt;iostream&gt; int main() { float temperature { 24.0f }; bool const isRaining { false }; bool const wantToGoOut { true }; bool const ownsAnUmbrella { false }; if ( wantToGoOut &amp;&amp; (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella) ) ) { // ... } else { //... } return 0; }  danger Les op√©rateurs logiques sont comme les op√©rateurs math√©matiques que nous avons vus dans les chapitres pr√©c√©dents: ils ont une priorit√©. Le plus prioritaire est la n√©gation !Ensuite c'est le ET &amp;&amp;Enfin, le OU || est le moins prioritaire Par exemple avec le code a &amp;&amp; b || c &amp;&amp; d, dans l‚Äôordre, on √©value a &amp;&amp; b, c &amp;&amp; d et enfin (a &amp;&amp; b) || (c &amp;&amp; d). Pour des raisons de lisibilit√© je vous recommande tr√®s fortement d'ajouter des parenth√®ses (comme dans mon exemple ci-dessus) pour expliciter quelles op√©rations vous voulez prioriser dans ce genre de cas plus &quot;complexe&quot;. ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#pour-aller-plus-loin","content":"Enfin, pour aller encore plus loin il est possible de manipuler les op√©rateurs &amp;&amp;, || et ! et trouver des expressions donnant le m√™me r√©sultat. Cela permet parfois de simplifier le code ou alors d'exprimer la condition sous une forme plus lisible ou compr√©hensible. Dans mon exemple pr√©c√©dent la condition (!isRaining || (isRaining &amp;&amp; ownsAnUmbrella)) est √©quivalente √† √©crire (!isRaining || ownsAnUmbrella). Il existe aussi le th√©or√®me de De Morgan qui permet d'exprimer la n√©gation d'un ET avec un OU et inversement. Il est possible d'exprimer mon exemple pr√©c√©dent sous cette forme: (!isRaining || ownsAnUmbrella) √©quivalent √† !(isRaining &amp;&amp; !ownsAnUmbrella) On peut s'en convaincre en essayant de traduire ces conditions en phrases: (!isRaining || ownsAnUmbrella): c'est le cas o√π il ne pleut pas ou alors j'ai un parapluie.!(isRaining &amp;&amp; !ownsAnUmbrella) ce n'est pas le cas o√π il pleut et je n'ai pas de parapluie. Vous trouverez des exemples de propri√©t√©s et simplifications possibles sur la page Wikip√©dia suivante:Alg√®bre de Boole ","version":"Next","tagName":"h3"},{"title":"En r√©sum√©‚Äã","type":1,"pageTitle":"Un peu de logique avec les conditions","url":"/Learn--cpp_programming/Lessons/S1/Conditions#en-r√©sum√©","content":"Une valeur bool√©enne est du type bool et peut prendre comme valeur true ou false. On obtient une valeur bool√©enne avec une condition sur nos variables (avec les op√©rateurs de comparaison ==, !=, &gt;, &lt;=, &gt; ou &gt;=) Les op√©rateurs &amp;&amp;, || et ! permettent de modifier et combiner les valeurs bool√©ennes. On utilise les structures de contr√¥le if, else, else if pour ex√©cuter des instructions diff√©rentes en fonction des conditions. ","version":"Next","tagName":"h2"},{"title":"Des tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Tableaux‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#tableaux","content":"Les tableaux sont l√† pour r√©soudre ce probl√®me et nous permettre de stocker plusieurs √©l√©ments. Ils font partie de ce qu'on appelle les structures de donn√©es, des structures permettant d'organiser de fa√ßon particuli√®re des donn√©es, on les nomme aussi des conteneurs. En ce qui concerne les tableaux il en existe principalement deux types: std::array qui permet de stocker un nombre fix√© √† l'avance d'√©l√©mentsstd::vector qui permet de stocker un nombre variable ou dynamique d'√©l√©ments A retenir que les tableaux permettent seulement de stocker des variables de m√™me type. remarque Il existe bien d'autres structures de donn√©es qui stockent de fa√ßon diff√©rente (avec des avantages et des inconv√©nients) mais nous n'allons pas rentrer dans ce d√©tail pour l'instant. ","version":"Next","tagName":"h2"},{"title":"std::vector‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdvector","content":"Comme vous le remarquez, j'ai ajout√© std:: devant vector ce qui nous indique que c'est une fonctionnalit√© d√©j√† cod√©e pour nous dans la biblioth√®que standard. Pour pouvoir s'en servir on va donc inclure le fichier contenant cette fonctionnalit√© en faisant #include &lt; vector &gt; std::vector est un tableau dynamique qui s'agrandit et se r√©tr√©cit en fonction du nombre d'√©l√©ments que l'on souhaite stocker √† l'int√©rieur. On l'initialise entre accolades en pr√©cisant entre chevrons (&lt; et &gt;) le type de variable que l'on souhaite stocker: std::vector&lt;/* type des √©l√©ments du tableau */&gt; nom {};  des exemples #include &lt;vector&gt; int main() { // initialisation d'un tableau √† remplir plus tard std::vector&lt;int&gt; vector01 {}; // il est aussi possible de le pr√©remplir √† sa cr√©ation std::vector&lt;int&gt; vector02 { 12, 18, 8, 4, 9 }; // on peut rendre constant afin d'√©viter de future modifications si c'est ce que l'on souhaite std::vector&lt;float&gt; const vector03 { 3.1415f, 5.2365f }; // il est aussi possible de l'initialiser en copiant les valeurs d'un autre tableau de cette mani√®re std::vector&lt;float&gt; vector04 { vector03 }; return 0; }  ","version":"Next","tagName":"h2"},{"title":"Manipuler notre tableau‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#manipuler-notre-tableau","content":"","version":"Next","tagName":"h2"},{"title":"Acc√©der aux √©l√©ments‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#acc√©der-aux-√©l√©ments","content":"Pour acc√©der aux √©l√©ments on utilise les crochets ([ et ]) apr√®s le nom de notre tableau, avec la position de l‚Äô√©l√©ment √† r√©cup√©rer. #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;int&gt; vector { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; &quot;the second √©l√©ment is &quot; &lt;&lt; vector[1] &lt;&lt; std::endl; return 0; }  attention ‚ö†Ô∏è g√©n√©ralement en informatique (c'est le cas en C++), les √©l√©ments sont index√©s √† partir de 0 et non 1. c'est pour √ßa que 0 correspond au premier √©l√©ment et 1 au deuxi√®me dans notre exemple. danger Et si j‚Äôacc√®de √† l‚Äô√©l√©ment d'index 6 (donc le 7√®me √©l√©ment) alors que mon tableau n'en contient que 6, que se passe-t-il‚ÄØ? C'est un comportement ind√©termin√©. Le programme peut continuer sans rien dire, ou alors s'arr√™ter brusquement avec des erreurs nomm√©es g√©n√©ralement &quot;out of range&quot; (d√©passement de capacit√©) ou &quot;segmentation fault&quot; (erreur de segmentation). Il ne faut pas utiliser d‚Äôindice inf√©rieur √† 0 ou sup√©rieur ou √©gal √† la taille de notre tableau. ","version":"Next","tagName":"h3"},{"title":"Taille du tableau‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#taille-du-tableau","content":"Pour conna√Ætre la taille du tableau on va utiliser la fonction propre (appel√©e m√©thode) size() qui renvoie le nombre d'√©l√©ments. remarque Une fonction est un regroupement d'instructions que permet de r√©utiliser du code √† plusieurs endroits d'un programme. Une m√©thode est une fonction propre √† un objet(ici notre std::vector) et qui peut le manipuler ou retourner des informations √† son sujet. Nous en reparlerons plus en d√©tail dans un prochain chapitre, mais nous pouvons d√®s maintenant en utiliser. Le type de retour de cette m√©thode est un type nouveau, que nous n‚Äôavons pas rencontr√© jusque-l√† et qui s‚Äôappelle std::size_t. C‚Äôest un type entier non sign√© capable de stocker l'index d'un √©l√©ment ou la taille de n‚Äôimporte quel tableau, aussi grand soit-il. C'est, pour faire simple, un tr√®s grand entier positif √©quivalent √† √©crire unsigned long int. #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; std::size_t const size { vector.size() }; std::cout &lt;&lt; &quot;Mon tableau contient &quot; &lt;&lt; size &lt;&lt; &quot; √©l√©ments.&quot; &lt;&lt; std::endl; return 0; }  remarque Il existe aussi une fonction std::size(...) qui prends en param√®tre le tableau et retourne sa taille. std::size_t const size { std::size(vector) }; Dans la pratique, j'utilise plut√¥t la m√©thode, plus lisible selon moi mais c'est un avis personnel et vous √™tes libres de choisir ce qu‚Äôil vous pla√Æt. ","version":"Next","tagName":"h3"},{"title":"Premier et dernier √©l√©ment‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#premier-et-dernier-√©l√©ment","content":"On pourrait utiliser la taille pour acc√©der au dernier √©l√©ment du tableau mais on peut aussi utiliser deux autres m√©thodes (front() et back()) pour acc√©der au premier et au dernier √©l√©ment du tableau: #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; // Fa√ßon de faire h√©rit√© du c en utilisant la taille du tableau (attention au -1 les index commencent √† 0) std::cout &lt;&lt; &quot;Le dernier √©l√©ment est &quot; &lt;&lt; vector[vector.size() - 1] &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le premier √©l√©ment est &quot; &lt;&lt; vector.front() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le dernier √©l√©ment est &quot; &lt;&lt; vector.back() &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h3"},{"title":"V√©rifier si un tableau est vide‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#v√©rifier-si-un-tableau-est-vide","content":"Pour savoir si le tableau est vide on peut utiliser une condition sur la taille du tableau. Il y a aussi la m√©thode empty() qui fait ce test pour nous et permet d'√©crire quelque chose de plus lisible: #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector01 { }; std::vector&lt;int&gt; const vector02 { 12, 18, 8, 4, 9 }; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.size() == 0 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector01 est vide : &quot; &lt;&lt; vector01.empty() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector02 est vide : &quot; &lt;&lt; vector02.empty() &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h3"},{"title":"Afficher les √©l√©ments‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#afficher-les-√©l√©ments","content":"Pour afficher les √©l√©ments du tableau on peut simplement utiliser sa taille et une boucle for pour it√©rer sur les diff√©rentes valeurs: #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; for (std::size_t i {0}; i &lt; vector.size(); i++) { std::cout &lt;&lt; vector[i] &lt;&lt; std::endl; } return 0; }  Depuis le C++ moderne (√† partir de C++11) il existe une nouvelle fa√ßon de parcourir des conteneurs (qui se g√©n√©ralise sur d'autres structures de donn√©es): for (/* type d'un √©l√©ment du tableau */ nom : /* structure de donn√©es √† parcourir */) { }  remarque On appelle cela un foreach dans d'autres languages. Plus besoin de r√©cup√©rer la taille et cela va rendre notre code plus lisible: Petit exemple avec std::vector #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; const vector { 12, 18, 8, 4, 9 }; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }  ","version":"Next","tagName":"h3"},{"title":"Ajouter, supprimer et modifier des √©l√©ments‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#ajouter-supprimer-et-modifier-des-√©l√©ments","content":"Comme expliqu√©, le std::vector est dynamique dans le sens o√π il est possible d'ajouter ou de supprimer des √©l√©ments. C'est avec la m√©thode push_back que l'on ajoute un √©l√©ment: #include &lt;iostream&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; vector { 42 }; // On ajoute des √©l√©ments vector.push_back(23); vector.push_back(5); for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; std::endl; } return 0; }  attention On ne pourra pas ajouter un √©l√©ment de type diff√©rent dans notre tableau, un tableau ne peut contenir qu'un seul type de variable.  Pour supprimer un √©l√©ment on utilisera les m√©thodes pop_back ou clear. Clear comme son nom l'indique permet de vider enti√®rement le tableau et pop_back permet de retirer et retourner le dernier √©l√©ment. #include &lt;vector&gt; #include &lt;iostream&gt; int main() { std::vector&lt;int&gt; vector { 42, 12 }; std::cout &lt;&lt; &quot;Taille avant clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.clear(); std::cout &lt;&lt; &quot;Taille apr√®s clear : &quot; &lt;&lt; vector.size() &lt;&lt; std::endl; vector.push_back(23); vector.push_back(42); vector.push_back(25); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; vector.pop_back(); std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; if(!std::empty(vector)) { int last_value {vector.back()}; vector.pop_back(); std::cout &lt;&lt; &quot;La derniere valeur du tableau etait : &quot; &lt;&lt; last_value &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le tableau contient maintenant: &quot;; for (int const value : vector) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; } return 0; }  danger Appeler pop_back sur un tableau vide est aussi un comportement ind√©termin√©. Une tr√®s bonne pratique est donc de s'assurer que le tableau n'est pas vide.  Enfin, pour pouvoir modifier une valeur il suffit d'acc√©der √† l'√©l√©ment (√† condition que le tableau ou la variable ne soit pas constante √©videmment) d'utiliser le symbole √©gal =. #include &lt;vector&gt; int main() { std::vector&lt;int&gt; vector { 24, 12, 6 }; // On change la valeur du premier √©l√©ment vector[0] = 15; return 0; }  ","version":"Next","tagName":"h3"},{"title":"std::array‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdarray","content":"std::array est un tableau statique, c‚Äôest-√†-dire que sa taille doit √™tre connue √† la compilation et ne peut pas varier. En contre-partie, cette structure de donn√©es est plus performant et plus rapide qu‚Äôun std::vector puisqu‚Äôil n‚Äôy a pas d‚Äôop√©ration d‚Äôajout ou de retrait d‚Äô√©l√©ments. Pour l‚Äôutiliser, il faut inclure le ficher qui contient cette fonctionnalit√© (#include &lt; array &gt;). On l'initialise en pr√©cisant entre chevrons le type de variable que l'on souhaite stocker et sa taille: std::array&lt;/* type des √©l√©ments du tableau */, /* taille du tableau */&gt; nom {};  Contrairement √† std::vector, un tableau statique doit contenir autant d'√©l√©ments que la taille pr√©cis√©e. Ainsi, si l'on ne pr√©cise donc rien ou pas la totalit√© des √©l√©ments √† son initialisation, le tableau va √™tre rempli avec des valeurs par d√©faut. #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array_of_integer { 24, 12, 6, 32, 8 }; // On change la valeur du deuxi√®me √©l√©ment array_of_integer[1] = 42; std::cout &lt;&lt; &quot;Le tableau d'entier contient: &quot;; for (int const integer : array_of_integer) { std::cout &lt;&lt; integer &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // les 4 autres valeurs non pr√©cis√©es seront donc √©gale √† 0.0f std::array&lt;float, 6&gt; array_of_float { 45.3f, 142.857f }; std::cout &lt;&lt; &quot;Le tableau de flottant contient: &quot;; for (float const integer : array_of_integer) { std::cout &lt;&lt; integer &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // Ce tableau sera rempli de 4 valeurs par d√©faut √©gales √† 0.0 std::array&lt;double, 4&gt; array_of_double { }; return 0; }  Il existe la m√©thode fill sp√©cifique au std::array qui permet de le remplir avec une valeur donn√©e: #include &lt;array&gt; #include &lt;iostream&gt; int main() { std::array&lt;int, 5&gt; array { 1, 2, 3, 4, 5}; array.fill(3); std::cout &lt;&lt; &quot;Le tableau contient: &quot;; for (int const value : array) { std::cout &lt;&lt; value &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; return 0; }  Le reste des fonctionnalit√©s reste identique avec le std::vector (hors les ajouts et suppressions car le tableau ne change pas de taille ici). ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#pour-aller-plus-loin","content":"std::vector et std::array sont des structures qui disposent d'une multitude de m√©thodes tr√®s utiles, je vous laisse chercher par vous m√™me dans la documentation ou revenir vers moi si vous avez des questions √† ce sujet. ","version":"Next","tagName":"h2"},{"title":"std::string: un tableau cach√©‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#stdstring-un-tableau-cach√©","content":"Nous avions d√©couvert le type un peu particulier std::string dans le chapitre sur les variables. Ce &quot;type&quot; est lui m√™me une structure de donn√©es qui permet de stocker du texte, une suite de caract√®res (de type char donc). Le type std::string n‚Äôest donc rien d‚Äôautre qu'un tableau &quot;dynamique&quot; de char, con√ßu et optimis√© sp√©cialement pour le stockage de texte. On peut donc faire toutes les op√©rations que nous venons de voir, acc√©der √† sa taille, acc√©der aux caracat√®res, les modifier, en ajouter ou supprimer et enfin boucler sur les caract√®res. des exemples #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string phrase { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; &quot;Premier caract√®re : &quot; &lt;&lt; phrase.front() &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Dernier caract√®re : &quot; &lt;&lt; phrase.back() &lt;&lt; std::endl; phrase.pop_back(); phrase.push_back('.'); std::cout &lt;&lt; phrase &lt;&lt; std::endl; phrase[9] = ' '; std::cout &lt;&lt; phrase &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Cette phrase contient &quot; &lt;&lt; phrase.size() &lt;&lt; &quot; caract√®res.&quot; &lt;&lt; std::endl; // Il existe aussi &quot;phrase.length()&quot; qui fait exactement la m√™me chose for (char lettre : phrase) { std::cout &lt;&lt; lettre &lt;&lt; ','; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; &quot;Est ce que la phrase est vide ? &quot; &lt;&lt; std::empty(phrase) &lt;&lt; std::endl; return 0; }  std::string dispose de nombreuses autres m√©thodes permettant de faire d'autres choses sp√©cifiques √† la gestion de texte. Nous aurons l‚Äôoccasion de le revoir, retenez simplement ici que std::string peut √™tre manipul√© comme un tableau. ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Des tableaux","url":"/Learn--cpp_programming/Lessons/S1/Arrays#r√©sum√©","content":"Il existe plusieurs types de tableaux, statique quand la taille est fixe et dynamique quand elle peut varier. std::vector est un tableau dynamique.std::array est un tableau statique.std::string est un tableau dynamique sp√©cialement con√ßu pour la gestion du texte. ","version":"Next","tagName":"h2"},{"title":"Fonctions : D√©couper son code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Structure d'une fonction‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#structure-dune-fonction","content":"Une fonction est un ensemble d'instructions d√©limit√© par des accolades { et } ce qui d√©fini sa port√©e (scope). Elle a un nom et peut ou non prendre des informations en entr√©e et peut ou non fournir une information en sortie. type_de_retour nom(param√®tres) { instructions }  Un exemple bien connu D√®s notre premier programme nous avions rencontr√© une fonction, la fonction main. Celle-ci est le point d‚Äôentr√©e de tous les programmes que nous codons en C++. int main() { // Instructions diverses return 0; } Ici, main est le nom de la fonction. Le int situ√© juste avant indique son type de retour. Dans ce cas, la fonction renvoie une valeur enti√®re (via le return 0;) qui indique que tout s‚Äôest bien pass√©. Apr√®s, le nom, il y a des parenth√®ses vides (), ce qui signifie que la fonction n‚Äôattend aucune information en entr√©e. Enfin, entre les accolades {}, nous avons les instructions qui la composent. ","version":"Next","tagName":"h2"},{"title":"Choisir un nom‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#choisir-un-nom","content":"Les r√®gles de nommage des fonctions sont les m√™mes que pour nommer nos variables, vous pouvez aller les relire ici si n√©cessaire. De m√™me que pour les variables, il est important de donner un nom explicite aux fonctions afin de d√©finir clairement ce qu‚Äôelles font. ","version":"Next","tagName":"h3"},{"title":"Type de retour‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#type-de-retour","content":"Une fonction peut ou non renvoyer une valeur de retour, comme nous l‚Äôavons vu avec la fonction main. Il faut simplement pr√©ciser le type de la valeur √† retourner comme vu pr√©c√©demment. Pour renvoyer une valeur, on utilise le mot-cl√© return, exactement comme dans la fonction main. info Il peut y avoir plusieurs return dans une fonction. Un si un if est vrai, l‚Äôautre s‚Äôil est faux par exemple. Mais d√®s que l'instruction return est ex√©cut√©e, on sort de la fonction en cours et tout le code restant n‚Äôest pas ex√©cut√©. Cela coupe le flot d‚Äôex√©cution de la fonction comme avec les mots-cl√©s break et continue avec les boucles. Si votre fonction ne doit rien renvoyer, alors on utilise le mot-cl√© void, qui signifie &quot;vide&quot; et qui, dans ce contexte, indique que la fonction ne retourne pas d'information (dans ce cas il n'est pas n√©cessaire d'utiliser l'instruction return mais peut tout de m√™me √™tre utilis√©e pour couper le flot d‚Äôex√©cution). ","version":"Next","tagName":"h3"},{"title":"Des param√®tres‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#des-param√®tres","content":"Maintenant, parlons des param√®tres. C'est via des param√®tres que la fonction d√©crit ce qu'elle attend pour travailler. On les d√©clare entre les parenth√®ses (()). Il faut que chaque param√®tre ait un type et un nom. S‚Äôil y en a plusieurs, ils seront s√©par√©s par des virgules. Des exemples #include &lt;iostream&gt; int sum (int a, int b) { return a + b; } int pgcd(int a, int b) { int r { a % b }; while (r != 0) { a = b; b = r; r = a % b; } // On peut tout √† fait renvoyer la valeur d'un param√®tre return b; } int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Le PGCD de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; pgcd(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; }  attention Une fonction doit √™tre d√©clar√©e avant son utilisation. Il faut donc la d√©clarer avant la fonction main afin d'√™tre en mesure de l'utiliser dans la fonction main par exemple. Le nom donn√© aux param√®tres d'une fonction est sp√©cifique √† cette fonction et n'est pas partag√© par le reste du code. Il est possible de donner en argument √† une fonction une variable qui porte le m√™me nom qu‚Äôun des param√®tres. Inversement, il n‚Äôest pas possible d‚Äôutiliser un param√®tre de fonction en dehors de celle-ci. Le code suivant produit donc une erreur. int function(int parameter) { parameter += 5; return parameter; } int main() { int const a { function(37) }; int const b { function(a) }; // La variable parameter n'existe pas ici parameter = 410; return 0; }  Argument vs param√®tre Attention, il faut bien faire la distinction entre param√®tre et argument. Un param√®tre, c‚Äôest ce qu‚Äôattend une fonction pour travailler et qui est inscrit dans sa d√©claration, le nom du param√®tre est propre √† la fonction et utilisable uniquement dans celle-ci. Un argument, c‚Äôest la valeur transmise √† la fonction quand on l‚Äôutilise. Dans notre exemple pr√©c√©dent parameter est le param√®tre de la fonction. 37 est l'argument de la fonction pour l'assignation de la variable a. Ensuite a devient lui m√™me argument de la fonction pour l'assignation de b. En pratique, il y a souvent un abus de langage et les deux termes s'utilisent de fa√ßon interchangeable et je ne vous en voudrais si vous faites de m√™me mais je tenais √† vous expliquer la diff√©rence. ","version":"Next","tagName":"h3"},{"title":"Petit point vocabulaire: les m√©thodes‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#petit-point-vocabulaire-les-m√©thodes","content":"Dans le pr√©c√©dent chapitre sur les tableaux nous avons vu des fonctions propres ou m√©thodes. On parle de m√©thode quand une fonction est associ√©e √† un objet. C'est le cas par exemple de la fonction size() sur l'objet std::vector. Elle s'utilise avec un point . apr√®s le nom de la variable en question. On dit que size() est une m√©thode de std::vector. Une m√©thode a donc &quot;connaissance&quot; de l'objet en question pour le modifier, lire des informations, etc. std::vector&lt;int&gt; const array { 12, 18, 8, 4, 9 }; std::size_t const size { array.size() };  Nous y reviendrons plus tard, pour l'instant gardez simplement √† l'esprit que c'est r√©serv√© √† des type &quot;particuliers&quot; comme le std::vector ou std::string et que l'on appelle √ßa des m√©thodes. ","version":"Next","tagName":"h3"},{"title":"Une port√©e limit√©e‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#une-port√©e-limit√©e","content":"J'avais d√©j√† √©voqu√© la notion de port√©e (ou scope) lors de l'introduction des stuctures de contr√¥le. Cette notion est aussi vraie avec les fonctions. Les instructions d'une fonction sont contenues entre des accolades et donc restreignent la port√©e des variables √† l'int√©rieur de ce bloc. C‚Äôest une bonne pratique de d√©clarer ses variables dans la plus petite port√©e possible. Cela permet premi√®rement de limiter son utilisation √† cette port√©e et √©viter un usage malencontreux plus tard. D√©clarer une variable proche de son utilisation √©vite de devoir chercher et parcourir un code parfois long et complexe pour comprendre pourquoi cette variable est utilis√©e √† cet endroit pr√©cis. Cela aide donc √† la lecture et la compr√©hension du code. Enfin, lorsqu‚Äôon atteint la fin d'un bloc (accolade }), le programme lib√®re dans la m√©moire les emplacements qu‚Äôil avait r√©serv√©s pour les variables du bloc en question. C'est donc plus propre et plus performant (niveau m√©moire) de d√©clarer les variables √† l‚Äôint√©rieur d'un bloc (fonction, condition, etc) si elles ne sont pas destin√©es √† √™tre utilis√©es ailleurs. ","version":"Next","tagName":"h2"},{"title":"Param√®tre par copie‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#param√®tre-par-copie","content":"J‚Äôai expliqu√© pr√©c√©demment que les param√®tres d‚Äôune fonction √©taient dans une port√©e diff√©rente concernant le nommage. La port√©e diff√©rente implique une copie. Pour chaque utilisation de la fonction, le compilateur va r√©server un nouvel espace m√©moire et copier l'argument (la variable) qu‚Äôon lui passe en param√®tre. Une variable dans la fonction est donc totalement diff√©rente. C‚Äôest ce qu'on appelle un passage par copie. On peut donc nommer nos param√®tres avec le m√™me nom qu'une de nos variables. Un exemple #include &lt;iostream&gt; void addOne(int a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }  On pourrait penser que cela va afficher 9 mais en r√©alit√© a est toujours √©gal √† 8. la fonction addOne a re√ßu une copie de la variable a (nomm√©e a elle aussi) mais elle ne peut pas modifier la variable a originale. Dans le cas d‚Äôun entier ou d‚Äôun caract√®re par exemple ce n'est pas tr√®s grave, mais dans le cas d‚Äôun tableau de plusieurs d‚Äô√©l√©ments, on perd du temps inutilement √† copier toutes les valeurs du tableau (m√™me si on ne veut en lire que quelques unes dans la fonction). ","version":"Next","tagName":"h2"},{"title":"R√©f√©rence‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©f√©rence","content":"Mais, en C++, il existe un moyen de cr√©er un alias, une r√©f√©rence vers une variable. Cette r√©f√©rence devient manipulable comme si nous avions la variable originale entre les mains. On indique qu'une variable est une r√©f√©rence vers une autre en ajoutant une esperluette (&amp;) apr√®s le type de notre variable. #include &lt;iostream&gt; int main() { int a { 8 }; // refA est une r√©f√©rence vers la variable a int &amp; refA { a }; // ici je modifie donc la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }  danger On ne peut pas cr√©er de r√©f√©rence qui ne cible rien, ni changer la cible d‚Äôune r√©f√©rence une fois qu‚Äôon l‚Äôa cr√©√©e. Une r√©f√©rence est un alias vers une autre variable, si on essaye de l'assigner de nouveau cela revient √† modifier la variable originale et pas √† r√©atribuer la r√©f√©rence. #include &lt;iostream&gt; int main() { int a { 8 }; int b { 42 }; int &amp; refA { a }; refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; // ici refA reste une r√©f√©rence vers la variable a qui prend la valeur de b // refA ne devient PAS une r√©f√©rence vers la variable b refA = b; // Je modifie ici toujours la variable a refA += 1; std::cout &lt;&lt; a &lt;&lt; ';' &lt;&lt; b &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h2"},{"title":"Passage par r√©f√©rence‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#passage-par-r√©f√©rence","content":"Cela devient int√©ressant dans nos fonctions o√π il va aussi √™tre possible de d√©clarer un param√®tre en tant que r√©f√©rence et non pas comme une copie de la variable originale. Pour indiquer que l'on souhaite recevoir une r√©f√©rence il faut ajouter une esperluette (&amp;) apr√®s le type de notre param√®tre. remarque Bien entendu on ne pourra passer en argument qu'une variable du m√™me type que le type de la r√©f√©rence attendue par la fonction. #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h2"},{"title":"R√©f√©rence constante‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©f√©rence-constante","content":"Je vous avais dit que les variables constantes allaient prendre tout leur importance et bien c'est ici ! ü•≥ En effet, si on manipule une r√©f√©rence, on peut tr√®s bien modifier la variable originale comme vu pr√©c√©demment. Mais parfois on aimerait utiliser une r√©f√©rence (pour √©viter une copie d'un tableau par exemple) mais prot√©ger la variable originale et interdire les modifications de celle-ci, un mode lecture seule. On peut donc rajouter le mot cl√© const dans notre param√®tre comme cela: #include &lt;iostream&gt; #include &lt;vector&gt; float sum(std::vector&lt;float&gt; const&amp; list) { float sum {0}; for(float const value: list) { sum += value; } return sum; } int main() { std::vector&lt;float&gt; list { 8.f, 4.2f, 3.1415f, 43.8f }; float sum { sum(list) }; std::cout &lt;&lt; &quot;La somme des valeurs de mon tableau est de &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }  Si vous essayez de modifier un param√®tre constant vous allez obtenir une erreur (et c'est tant mieux !). #include &lt;iostream&gt; void addOne(int const&amp; a) { a += 1; } int main() { int a { 8 }; addOne(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }  main.cpp: In function ‚Äòvoid addOne(const int&amp;)‚Äô: main.cpp:4:7: error: assignment of read-only reference ‚Äòa‚Äô 4 | a += 1; | ~~^~~~  Le compilateur nous indique qu'il y a une tentative de modification d'un param√®tre d√©clar√© comme constant. C'est donc une s√©curit√© importante pour √©viter des erreurs et je vous recommande d'utiliser des variables ou param√®tres constants d√®s que possible. remarque Une r√©f√©rence constante ne peut √©videmment pas redevenir modifiable et le code ci-dessous va aussi produire une erreur de compilation. #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } void readyOnlyFunction(int const &amp; a) { addOne(a); } int main() { int a { 8 }; readyOnlyFunction(a); std::cout &lt;&lt; a &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h3"},{"title":"Le cas des litt√©raux‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#le-cas-des-litt√©raux","content":"Avec les lit√©raux il se passe un autre m√©canisme. Le code ci-dessous ne va pas compiler, √† cause de la ligne 15. #include &lt;iostream&gt; void display(int &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { display(42); displayConst(42); return 0; }  En effet, nous passons un lit√©ral √† notre fonction qui attend une r√©f√©rence, un alias, sur une variable modifiable. Un lit√©ral n'est pas √† proprement parl√© une variable, il est invariable et n‚Äôexiste nulle part en m√©moire, il n'est pas modifiable. Par contre, supprimez-la et le code compilera, la fonction displayConst ne pose pas de probl√®me de compilation. La seule diff√©rence entre les deux fonctions, c‚Äôest la pr√©sence du mot-cl√© const. Ici, le compilateur va cr√©er une variable constante temporaire, qui n‚Äôexistera que le temps que la fonction, et va lui assigner le lit√©ral comme valeur. Cela revient √† faire cela par exemple: #include &lt;iostream&gt; void displayConst(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { { int const temporaryVariable { 42 }; displayConst(temporaryVariable); // A la sortie de ce scope (d√©limit√© entre accolades) la variable temporaire va √™tre d√©truite } return 0; }  C'est donc pr√©f√©rable d'utiliser des param√®tres constants car cela permet √©galement de rendre compatible nos fonctions avec les litt√©raux. ","version":"Next","tagName":"h3"},{"title":"Retour par r√©f√©rence‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#retour-par-r√©f√©rence","content":"Les r√©f√©rences ont une contrainte particuli√®re‚ÄØ: elles doivent toujours √™tre valides. Dans le cas d‚Äôun param√®tre de fonction il n'y a pas de probl√®me car l‚Äôargument transmis √† la fonction existera toujours quand celle-ci se terminera: #include &lt;iostream&gt; void addOne(int &amp; a) { a += 1; } int main() { int a { 8 }; // la variable a est pass√©e en argument addOne(a); // Ici la variable a existe toujours return 0; }  Mais, dans le cas o√π l‚Äôon souhaite qu‚Äôune fonction retourne une r√©f√©rence, cela peut √™tre dangereux et on peut renvoyer une r√©f√©rence sur une variable qui n‚Äôexistera plus √† la fin de la fonction‚ÄØ! #include &lt;iostream&gt; int&amp; test() { int a { 33 }; return a; // A la fin du scope de la fonction la variable 'a' va √™tre d√©truite } int main() { int &amp; reference { test() }; // ici notre r√©f√©rence est invalide ! return 0; }  C'est un comportement ind√©termin√©. Il ne produira pas d'erreur de compilation mais l'utilisation de la r√©f√©rence est invalide. danger Il ne faut jamais renvoyer une r√©f√©rence vers une variable locale √† une fonction. ","version":"Next","tagName":"h3"},{"title":"R√©f√©rences et types standard‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©f√©rences-et-types-standard","content":"Utiliser des r√©f√©rences pour std::vector ou std::string d‚Äôaccord, mais qu‚Äôen est-il des types standard comme int, char et double ? Y a-t-il un int√©r√™t √† utiliser des r√©f√©rences ? Doit-on bannir toutes les copies de notre code ? Les types standard sont petits (en m√©moire) et le co√ªt de la cr√©ation d‚Äôune r√©f√©rence sur des types aussi simples est souvent plus √©lev√© ou √©quivalent que celui d‚Äôune &quot;b√™te&quot; copie. En effet, le compilateur arrive tr√®s souvent √† optimiser les copies et les rendre extr√™mement rapides, bien plus qu‚Äôavec les r√©f√©rences. Donc ne tombez pas dans le pi√®ge de l‚Äôoptimisation pr√©matur√©e. Pensez au r√©f√©rences lorsqu'il s'agit d'objets &quot;gros&quot;. Vouloir mettre des r√©f√©rences partout n'est pas une erreur (et je ne vous en tiendrai pas compte au contraire cela veux dire que vous pensez aux r√©f√©rences). Mais, garder √† l'esprit que cela a aussi un co√ªt de cr√©er une r√©f√©rence et que laisser juste un int const parameter permet au compilateur de mieux optimiser le code. ","version":"Next","tagName":"h2"},{"title":"Signature et fonctions surcharg√©es‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#signature-et-fonctions-surcharg√©es","content":"Ce qui diff√©rencie deux fonctions, √ßa n‚Äôest pas seulement leur nom mais √©galement leurs param√®tres. C‚Äôest ce qu‚Äôon appelle la signature d‚Äôune fonction. On peut donc tr√®s bien avoir deux fonctions qui ont le m√™me nom mais pas les m√™mes param√®tres: #include &lt;iostream&gt; void testDisplay(int const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void testDisplay(float const a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main() { testDisplay(42); testDisplay(63.5f); return 0; }  Ici, le compilateur voit deux signatures diff√©rentes testDisplay(int const a) et testDisplay(float const a) il n'y a donc pas de probl√®me. On appelle cela la surcharge, de l‚Äôanglais &quot;overloading&quot;. Cela rend le code plus simple et le compilateur appelle la bonne surcharge de la fonction pour les arguments pr√©cis√©s (si elle existe √©videmment). Par contre, le type de retour n'est pas une forme de surcharge. Deux fonctions avec le m√™me nom, les m√™mes param√®tres et des types de retour diff√©rents ne compileront pas. Et c‚Äôest logique, car comment savoir quelle fonction utiliser et quoi retourner sans ambigu√Øt√© sinon ? ","version":"Next","tagName":"h2"},{"title":"Prototype: d√©claration des fonctions‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-d√©claration-des-fonctions","content":"J'ai expliqu√© pr√©c√©demment qu'une fonction a besoin d'√™tre d√©clar√©e avant son utilisation. C'est vrai mais incomplet. Cette d√©claration peut se faire √† l'aide de ce qu'on appelle le prototype de la fonction. Le prototype est tr√®s similaire √† la signature et est compos√© du nom, des param√®tres(et leur type) ET du type de retour de la fonction. Voil√† un petit exemple de fonction et son prototype: // la d√©claration de la fonction sum avec son prototype int sum (int a, int b); // Le corps de la fonction qui contient les instructions de la fonction int sum (int a, int b) { return a + b; }  Il est possible d'utiliser une fonction d√®s lors qu'elle est d√©clar√©e avec son prototype seulement. #include &lt;iostream&gt; int sum (int const a, int const b); int main() { int const a { 42 }; int const b { 27 }; std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; vaut &quot; &lt;&lt; sum(a, b) &lt;&lt; &quot;.&quot; &lt;&lt; std::endl; return 0; } int sum (int const a, int const b) { return a + b; }  Je compl√®te donc: Une fonction doit √™tre d√©clar√©e avant son utilisation. Cela peut se faire avec le prototype de la fonction ou le corps lui m√™me. Une fonction peut √™tre utilis√©e m√™me si le corps de la fonction est √©crit plus tard du moment que son prototype est √©crit avant toute utilisation de la fonction. Le prototype est l√† pour d√©clarer/signaler au compilateur que le corps de la fonction qu'on appelle sera bien d√©fini plus tard dans le programme. remarque √âvidemment le programme ne va pas compiler si le corps de la fonction d√©clar√©e n'existe pas et va nous l'indiquer (undefined reference): in function `main': main.cpp: undefined reference to `sum(int, int)'  remarque C'est une notion qui va √™tre utile quand on verra la s√©paration du code en plusieurs fichiers. ","version":"Next","tagName":"h2"},{"title":"Prototype vs signature‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#prototype-vs-signature","content":"Il y a souvent un abus de langage et les termes de prototype et signature sont souvent interchang√©s. Je ne vous en voudrais donc pas si vous utilisez le terme de signature ou de prototype. Si on veut √™tre pointilleux le prototype d√©signe le nom, les param√®tres et le type de retour d'une fonction alors que la signature indique seulement son nom et ses param√®tres (permettant de faire de la surcharge de fonction). ","version":"Next","tagName":"h3"},{"title":"R√©cursivit√©‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©cursivit√©","content":"Enfin, il est possible d'utiliser une fonction dans elle m√™me, on parle alors de r√©cursivit√©. Cela peut √™tre utile quand le probl√®me que l'on souhaite r√©soudre est de nature r√©cursive, se r√©p√®te sur lui m√™me. ","version":"Next","tagName":"h2"},{"title":"Un petit exemple‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#un-petit-exemple","content":"Par exemple si l'on souhaite calculer le produit de tous les entiers de 1 √† une valeur n. Pn=1√ó2√ó‚ãØ√ón‚àí1√ónP_n = 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\Pn‚Äã=1√ó2√ó‚ãØ√ón‚àí1√ón On pourrait voir ce probl√®me de mani√®re r√©cursive en exprimant cette somme en fonction de la somme √† l'√©tape d'avant (n-1): Pn=1√ó2√ó‚ãØ√ón‚àí1√ónPn=(1√ó2√ó‚ãØ√ón‚àí1)√ónPn=Pn‚àí1√ón\\begin{aligned} P_n &amp;= 1 \\times 2 \\times \\dots \\times n-1 \\times n \\\\ P_n &amp;= (1 \\times 2 \\times \\dots \\times n-1) \\times n \\\\ P_n &amp;= P_{n-1} \\times n \\end{aligned}Pn‚ÄãPn‚ÄãPn‚Äã‚Äã=1√ó2√ó‚ãØ√ón‚àí1√ón=(1√ó2√ó‚ãØ√ón‚àí1)√ón=Pn‚àí1‚Äã√ón‚Äã On a finalement exprim√© le produit des entiers de 1 √† n comme √©tant n fois le produit des entiers de 1 √† n-1. remarque On nomme ce r√©sulat la factorielle de n en Math√©matiques. Sous forme de fonction r√©cursive cela nous donnerait: int fact(int n) { return fact(n-1) * n; }  On oublie cependant un ingr√©dient tr√®s important des fonctions r√©cursives: la condition d'arr√™t. En effet, dans notre probl√®me on a bien pr√©cis√© que c'√©tait de 1 √† n. On fait donc attention de s'arr√™ter quand n &lt;= 1. La factorielle de 1 √©tant √©gale √† 1 je retourne donc 1. int fact(int n) { if( n &lt;= 1 ) { return 1; } return fact(n-1) * n; }  Il faut faire attention √† ne pas oublier cette condition d'arr√™t et bien s'assurer qu'il est possible de la v√©rifier pour s'arr√™ter sinon notre fonction ne va jamais se terminer et notre programme va s√ªrement planter.  Dans la plupart des cas, il existe une version alternative non r√©cursive (avec des boucles par exemple). int fact(int n) { int P { 1 }; // Ici si n est n√©gatif alors la condition i &lt;= n est directement invalide et on ne passe pas dans la boucle if et on retourne 1 for(int i {2}; i &lt;= n; i++) { P *= i; } return P; }  Il est pr√©f√©rable d'utiliser des fonctions non r√©cursives quand c'est possible car elle sont g√©n√©ralement plus performantes et moins propices √† l'erreur (condition d'arr√™t jamais valide, etc). ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Fonctions : D√©couper son code","url":"/Learn--cpp_programming/Lessons/S1/Functions#r√©sum√©","content":"Une fonction est un ensemble d'instructions d√©limit√© par des accolades ({}).Elle peut retourner une valeur en pr√©cisant le type de retour avant le nom ou le mot-cl√© void dans le cas o√π l'on souhaite ne rien retourner.Elle peut avoir des param√®tres.Les arguments pass√©s en param√®tre sont par d√©faut copi√©s.Il est possible de manipuler la variable d'origine √† l'aide de r√©f√©rence (en ajoutant une esperluette (&amp;) apr√®s le type de notre variable).Il est possible de surcharger un fonction, c'est √† dire avoir le m√™me nom mais des param√®tres diff√©rents, on parle de signatures diff√©rentes.Il est recommand√© d'utiliser des param√®tres constants (avec le mot-cl√© const) pour √©viter des erreurs, √©viter des copies et prot√©ger nos variables. ","version":"Next","tagName":"h2"},{"title":"Compilation et Headers: S√©parer en plusieurs fichiers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Headers","content":"","keywords":"","version":"Next"},{"title":"M√©canisme de compilation (en simple)‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#m√©canisme-de-compilation-en-simple","content":"Revenons √† la compilation quelques instants pour mieux comprendre. Quand j'ai parl√© de compilation j'ai fait un abus de langage et j'ai englob√© plusieurs √©tapes. Pour faire simple, il y a en r√©alit√© trois grandes √©tapes lors de la compilation en C++: Le pr√©processeurLa compilationLe linkage ","version":"Next","tagName":"h2"},{"title":"Le pr√©processeur‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-pr√©processeur","content":"La toute premi√®re √©tape est celle du pr√©processeur. C'est le moment o√π toutes les directives pr√©processeur sont trait√©es (toutes les lignes commen√ßant par #). Par exemple, nous avons d√©j√† la directive pr√©processeur #include qui permet d'inclure des fonctionnalit√©s. Cette directive fait simplement un copi√©-coll√© du contenu du fichier √† inclure dans le fichier o√π la directive est utilis√©e. Je ne vais pas en parler ici mais sachez qu'il existe d'autres directives permettant de faire des conditions en fonction des plateformes par exemple. ","version":"Next","tagName":"h3"},{"title":"La compilation‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#la-compilation","content":"Ensuite nous avons la compilation √† proprement parler. Chaque fichier .cpp, obtenu apr√®s les modifications du pr√©processeur, appel√© unit√© de compilation, va √™tre trait√© individuellement. Le but de cette √©tape est de transformer le code C++ (sous format texte) en langage compr√©hensible pour l'ordinateur. C‚Äôest √† cette √©tape que des v√©rifications du code ont lieu. Par exemple, dans le cas o√π le compilateur ne trouve pas la d√©claration d‚Äôune fonction que vous appelez. Dans notre exemple pr√©c√©dent dans le fichier main.cpp, la compilation va s'arr√™ter avec un message d'erreur indiquant ce qui n‚Äôa pas fonctionn√©. Cette √©tape va produire des fichiers objets. Un fichier objet, reconnaissable √† son extension en .o ou .obj, n‚Äôest rien d‚Äôautre que du langage machine mais seul, sans aucun lien avec le reste des autres fichiers. Tel quel, il n‚Äôest pas ex√©cutable, car il lui manque des informations. Il est possible de pr√©ciser aux compilateurs que l'on souhaite s'arr√™ter √† ce stade en ajoutant des flags de compilation: WindowsLinux et OSX Avec MSVC le flag est /c: cl /c helloImac.cpp  Cela indique au compilateur que l'on souhaite produire des fichiers objets et pas directement lier les fichiers pour en faire un ex√©cutable. Les fichiers d'objets peuvent faire r√©f√©rence √† des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore enti√®rement d√©finis. C'est le cas lorsque l'on utilise une fonction d√©clar√©e et que l'on n'a pas encore √©crit le corps de celle-ci, nous allons le voir juste apr√®s. Le compilateur ne s'en pr√©occupe pas et produit le fichier objet demand√© si le reste du code est correct. remarque L'avantage est qu'il n'est pas n√©cessaire de tout recompiler si vous ne modifiez qu'un seul fichier. Si aucune modification n‚Äôest d√©tect√©e depuis la derni√®re compilation, alors le compilateur r√©utilise le fichier objet pr√©c√©demment cr√©√© lors d'une prochaine compilation ce qui acc√©l√®re la compilation d‚Äôun projet. Cmake g√®re les fichiers objets lui m√™me automatiquement dans le fameux dossier build. ","version":"Next","tagName":"h3"},{"title":"Le linkage‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#le-linkage","content":"Nos fichiers objets ne sont pas utilisables en l'√©tat et c'est la derni√®re √©tape de linkage qui va les lier entre eux pour produire un ex√©cutable. C'est ce qui va permettre de lier la d√©claration d'une fonction dans un fichier et le corps de la fonction dans un autre fichier par exemple. Il est aussi possible de faire cette op√©ration en ligne de commande √† partir des fichiers objets mais ce n'est pas tr√®s utile en pratique car des outils comme CMake se charge de cette √©tape pour nous. ","version":"Next","tagName":"h3"},{"title":"En pratique‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#en-pratique","content":"Revenons √† notre exemple avec les fichiers maths.cpp et main.cpp: Premi√®rement, il manque la d√©claration de la fonction sum (son prototype) dans le fichier main.cpp pour pouvoir produire un fichier objet valide: main.cpp #include &lt;iostream&gt; int sum (int const a, int const b); int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }  Ce fichier ne permet toujours pas de cr√©er un ex√©cutable √† lui seul (car il manque le corps de la fonction sum) mais il est maintenant possible d'en faire un fichier objet. ","version":"Next","tagName":"h2"},{"title":"Fichier d'en-t√™te‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#fichier-den-t√™te","content":"Pour une seule fonction dans mon exemple c'est simple de recopier le prototype de la fonction. Imaginons que notre fichier maths.cpp soit compos√© de dizaines de fonctions et que l'on souhaite les utiliser dans le fichier main.cpp mais aussi dans un autre fichier du m√™me projet. Cela commence √† √™tre fastidieux de tout recopier. On va donc regrouper les d√©clarations des fonctions dans un autre fichier d'extension .hpp que l'on appelle fichier d'en-t√™te (header en anglais). Ainsi gr√¢ce √† la directive pr√©processeur #include on va pouvoir inclure (recopier) toutes les d√©clarations des fonctions facilement. Dans notre exemple le fichier d'en-t√™te serait simplement: maths.hpp int sum (int const a, int const b);  et le main.cpp devient: main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }  guillemets ou chevrons On peut noter une petite diff√©rence, j'utilise ici des guillemets &quot;&quot; pour l'inclusion et pas des chevrons &lt; &gt;. On pourrait tr√®s bien utiliser des guillemets tout le temps et faire: #include &quot;iostream&quot;. Cette diff√©rence est une question de convention et on r√©serve les chevrons &lt; &gt; pour les fichiers de qui viennent de biblioth√®ques comme la biblioth√®que standard (iostream, string, vector, etc) et les guillemets &quot;&quot; pour le reste. On va √©galement inclure ce fichier d'en-t√™te dans notre fichier maths.cpp pour s'assurer que l'on impl√©mente les bonnes fonctions list√©es dans le fichier d'en-t√™te. maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }  cpp ou hpp Les fichiers d‚Äôen-t√™te peuvent aussi utiliser l‚Äôextension .h. La diff√©rence n‚Äôest qu‚Äôune histoire de go√ªt. Je pr√©f√®re utiliser .hpp plut√¥t que .h pour mieux faire la distinction entre C et C++ par analogie aux fichiers sources, qui se terminent par .cpp en C++ mais .c en C. ","version":"Next","tagName":"h3"},{"title":"Pragma once: √©viter les doublons‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#pragma-once-√©viter-les-doublons","content":"Mais se pose alors la question des doublons si l'on inclut de nombreux fichiers, les uns d√©pendants des autres. Dans le cas des fonctions ce n'est pas bien grave car d√©clarer plusieurs fois une fonction (je parle du prototype pas du corps qui lui doit √™tre unique) est autoris√© bien que ce soit inutile. Par contre ce n'est pas toujours le cas. Par exemple avec les Enums il n'est pas possible de les d√©clarer deux fois et on obtient une erreur de compilation si on le fait. Un exemple Admettons que l'on a un autre fichier utils.cpp qui inclut maths.cpp pour fonctionner. utils.hpp contient les d√©clarations des fonctions propres au fichier utils.cpp. Le fichier maths.hpp d√©finit un enum. Si maintenant on souhaite utiliser des fonctions des deux fichiers dans notre fichier principal main.cpp, on va se retrouver √† inclure les deux: main.cpp #include &quot;utils.hpp&quot; #include &quot;maths.hpp&quot; int main() { // ... return 0; } Cela va provoquer une erreur lors de la compilation du fichier objet main car l'enum est d√©clar√© deux fois. Une fois provenant de l'inclusion de utils.hpp (qui inclut lui-m√™me maths.hpp) et une seconde fois en incluant directement le fichier maths.hpp. #pragma once est une directive du pr√©processeur l√† pour r√©pondre √† notre besoin. Elle est utilis√©e pour emp√™cher que le contenu des fichiers d'en-t√™te soient inclus plusieurs fois. La directive #pragma once, pr√©sente dans un fichier d'en-t√™te, garantit que le contenu du fichier sera inclus une seule fois dans une compilation. Le fichier maths.hpp dans notre exemple devient donc: maths.hpp #pragma once int sum (int const a, int const b);  Un fichier d'en-t√™te doit toujours contenir cette directive au d√©but du fichier. Structures‚Äã Bien que ce soit possible de mettre la d√©claration d'une structure dans un fichier .cpp g√©n√©ralement on a besoin de s'en resservir dans plusieurs fichiers et la d√©claration se trouve donc dans un fichier d'en-t√™te (.hpp). Cependant, comme pour les enums, une structure ne peut √™tre d√©clar√©e qu'une fois et il ne faut donc surtout pas oublier la directive pr√©processeur #pragma once pour √©viter un doublon lors d'inclusions. On utilisera dans ce cas la d√©claration de la structure avec les prototypes des fonctions qui lui sont associ√©es dans notre fichier d'en-t√™te. ","version":"Next","tagName":"h3"},{"title":"Utiliser Cmake‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#utiliser-cmake","content":"Pour r√©sumer nous avons donc maintenant les fichiers suivants: maths.hpp #pragma once int sum (int const a, int const b);  main.cpp #include &lt;iostream&gt; #include &quot;maths.hpp&quot; int main() { std::cout &lt;&lt; sum(42, 27) &lt;&lt; std::endl; return 0; }  maths.cpp #include &quot;maths.hpp&quot; int sum (int const a, int const b) { return a + b; }  Nous allons les placer dans un dossier de projet puis dans un sous dossier /src (pour sources). Pour certains projets on peut avoir plusieurs sous dossiers comme /src, /include (pour s√©parer les fichiers d'en-t√™te). C'est une question d'organisation et de pr√©f√©rence. Dans ce dossier de projet nous allons cr√©er notre fichier CMakeLists.txt pour nous aider √† compiler le projet. Nous allons reprendre et modifier notre premier fichier Cmake. Dans le fichier CMakeLists.txt il va falloir indiquer les r√©pertoires o√π se trouvent les fichiers d'en-t√™te par target_include_directories(). On va √©galement r√©gler une variable Cmake CMAKE_RUNTIME_OUTPUT_DIRECTORY qui va permettre d'indiquer que l'on souhaite placer l'ex√©cutable compil√© dans un sous dossier bin. CMakeLists.txt # la version de cmake √† utiliser cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On souhaite placer l'ex√©cutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # On indique que l'on souhaite faire un ex√©cutable avec nos deux fichiers .cpp add_executable(helloImac &quot;src/main.cpp&quot; &quot;src/maths.cpp&quot;) # le dossier contenant les fichiers d'en-t√™te pour notre executable helloImac target_include_directories(helloImac &quot;src/&quot;)  CMAKE_SOURCE_DIR est une variable cmake qui indique le dossier dans lequel se trouve le fichier CMakeLists.txt (documentation ici). attention Il faut s'assurer qu'il y a exactement une fonction d'entr√©e main() dans les fichiers sources list√©s pour un ex√©cutable. Petit r√©sum√© de notre dossier: projet_folder/ ‚îú‚îÄ‚îÄ src/ ‚îÇ ‚îú‚îÄ‚îÄ main.cpp ‚îÇ ‚îú‚îÄ‚îÄ maths.cpp ‚îÇ ‚îî‚îÄ‚îÄ maths.hpp ‚îî‚îÄ‚îÄ CMakeLists.txt  Vous pouvez maintenant ouvrir le dossier de projet dans VSCode et compiler votre projet. ","version":"Next","tagName":"h2"},{"title":"Quelques am√©liorations‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#quelques-am√©liorations","content":"Je vous ai parl√© de &quot;warnings&quot; de compilation √† plusieurs reprises. Il est possible d'ajouter des options pour activer des warnings et avoir des informations suppl√©mentaires lors de la compilation. Je vous propose d'ajouter ces lignes dans votre fichier CMakeLists.txt: if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif()  Cela va se complexifier avec un nombre plus important de fichiers sources. Avec Cmake il est possible de faire une recherche de fichier afin de ne pas avoir √† lister tous les fichiers sources manuellement: file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;)  Notre fichier CMakeLists.txt devient: # la version de cmake √† utiliser cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # R√©glage du compilateur pour les warnings if (MSVC) add_compile_options(/W3) else() add_compile_options(-Wall -Wextra -Wpedantic -pedantic-errors) endif() # On souhaite placer l'ex√©cutable dans un sous-dossier &quot;bin&quot; au lieu de le mettre dans le dossier build set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin) # Obtenir la liste des fichiers sources dans le dossier src file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS &quot;src/*.cpp&quot;) # Optionnel : afficher la liste des fichiers sources message(STATUS &quot;Found source files:&quot;) foreach(SRC_FILE ${SRC_FILES}) message(STATUS &quot; - ${SRC_FILE}&quot;) endforeach() # On indique que l'on souhaite faire un ex√©cutable avec nos fichiers sources add_executable(helloImac ${SRC_FILES}) # le dossier contenant les fichiers d'en-t√™te pour notre executable helloImac target_include_directories(helloImac &quot;src/&quot;)  ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Compilation et Headers: S√©parer en plusieurs fichiers","url":"/Learn--cpp_programming/Lessons/S1/Headers#r√©sum√©","content":"Les fichiers d'en-t√™te ou headers (d'extension .hpp) sont l√† pour lister les diff√©rentes d√©clarations des fonctions (et d'autres choses comme les enums) afin de pouvoir les utiliser dans plusieurs fichiers. Les fichiers objets sont des fichiers g√©n√©r√©s pendant la compilation. Ils peuvent faire r√©f√©rence √† des &quot;symboles&quot;(noms de fonctions ou de variables) qui ne sont pas encore enti√®rement d√©finis mais seulement d√©clar√©s (et inclus √† l'aide des fichiers d'en-t√™te). Ils permettent aussi d'acc√©l√©rer la compilation pour r√©utiliser des parties de code inchang√©es. La directive pr√©processeur #include fait simplement un copier-coller du fichier cible dans le fichier actuel. La directive pr√©processeur #pragma once permet d'√©viter de copier deux fois des d√©clarations lors d'inclusions. C'est tr√®s utile pour les fichiers d'en-t√™te contenant des enums ou des structures. Il faut toujours l'utiliser dans les fichiers d'en-t√™te. il y a 3 √©tapes dans la compilation: Le pr√©processeur qui transforme les directives pr√©processeur comme #include ou #pragma once.La compilation qui g√©n√®re des fichiers objets pour chaque unit√© de compilation (fichiers .cpp apr√®s traitement du pr√©processeur).Le linkage qui permet de lier tous les fichiers objets ensemble pour obtenir un ex√©cutable. Cmake permet de g√©rer ces √©tapes de compilation simplement. ","version":"Next","tagName":"h2"},{"title":"Un peu d'histoire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/introduction","content":"","keywords":"","version":"Next"},{"title":"Pourquoi apprendre C++ ?‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#pourquoi-apprendre-c-","content":"Sa popularit√©‚ÄØ: le C++ est un langage qui est utilis√© dans de nombreux projets importants de d√©veloppement logiciel. Il est √©galement beaucoup utilis√© dans l'industrie du jeu vid√©o. Il est enseign√© dans de nombreuses formations en informatique. Il poss√®de une communaut√© tr√®s importante, beaucoup de documentation et d‚Äôaide en ligne ainsi qu'une biblioth√®ques pr√©existantes tr√®s riche. Sa rapidit√©‚ÄØ: C‚Äôest cette caract√©ristique qui fait de lui un des langages de choix pour les gros logiciels, les calculs scientifiques et le domaine du jeu vid√©o. Son anciennet√©‚ÄØ: C++ est un langage ancien d‚Äôun point de vue informatique, il a fait l'objet de plusieurs mises √† jour ce qui donne une certaine garantie de maturit√©, de stabilit√© et de p√©rennit√© (il ne dispara√Ætra pas dans quelques ann√©es). Sa modernisation‚ÄØ: depuis sa version de 2011, C++ est beaucoup plus facile √† apprendre. La version C++11 le rend plus facile √† utiliser et plus puissant dans les fonctionnalit√©s qu‚Äôil propose. ","version":"Next","tagName":"h2"},{"title":"Langage difficile ?‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#langage-difficile-","content":"Tout n‚Äôest tout de m√™me pas parfait et le C++ a aussi ses d√©fauts. Son h√©ritage du C‚ÄØ: C++ est un descendant du langage C, invent√© dans les ann√©es 1970. Certains choix de conception, s√ªrement pertinents pour l‚Äô√©poque, sont plus probl√©matiques aujourd‚Äôhui, et C++ les traine avec lui. Sa complexit√©‚ÄØ: La libert√© et les performances qu'il offre viennent avec leur lot de complexit√©s. Avoir une certaine ma√Ætrise du C++ est &quot;long&quot; et demandera des ann√©es d‚Äôexp√©rience, notamment parce que certaines des fonctionnalit√©s les plus puissantes demandent de bien conna√Ætre les bases. Mais je vous rassure, nous allons commencer par les bases pour aborder pas √† pas ce langage, que vous ayez d√©j√† programm√© ou non. Nous allons d√©couvrir les notions petit √† petit pour que ce soit le plus compr√©hensible possible (certaines notions plus complexes ne seront d'ailleurs vu qu'en deuxi√®me ann√©e). ","version":"Next","tagName":"h2"},{"title":"La documentation‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#la-documentation","content":"En programmation, un bon r√©flexe √† adopter est d'aller consulter la documentation de l‚Äôoutil concern√©, et ce avant de demander de l‚Äôaide sur un forum par exemple. Voici un lien vers une excellente documentation C++. Elle est en anglais, mais je suis √©galement l√† pour vous aider. Je vous donnerai des liens, vous expliquerai comment comprendre et exploiter les informations fournies pour que, par la suite, vous puissiez le faire vous-m√™me. Enfin, sachez qu‚Äôil existe une r√©f√©rence ultime appel√©e la norme, produit par un organisme de validation international, l'ISO, qui explique tous les d√©tails et les r√®gles du C++ mais qui est un document (trop) complexe, m√™me pour des professionels, et est donc largement hors de port√©e nous concernant. Je le mentionne simplement pour que vous soyez au courant de son existence, sans √™tre surpris si, lors de vos recherches sur Internet, des r√©ponses mentionnent ou citent la norme. ","version":"Next","tagName":"h2"},{"title":"Compil√© vs interpr√©t√©‚Äã","type":1,"pageTitle":"Un peu d'histoire","url":"/Learn--cpp_programming/Lessons/S1/introduction#compil√©-vs-interpr√©t√©","content":"Il existe deux grands types de langages informatiques, les langages interpr√©t√©s et compil√©s. Dans un langage interpr√©t√©, le m√™me code source pourra marcher directement sur tout ordinateur disposant de l'interpr√©teur n√©cessaire, c'est le cas du Python par exemple. remarque L'interpr√©teur est un programme en lui m√™me qui interpr√®te le code pour le convertir en instructions compr√©hensibles pour la machine. Avec un langage compil√©, il faut compiler son programme (enti√®rement ou recompiler partiellement) √† chaque fois pour pouvoir obtenir un ex√©cutable utilisable sur la machine sur laquelle on veut lancer celui-ci. Cela n√©cessite donc une √©tape suppl√©mentaire (plus ou moins rapide): la compilation. Mais cela apporte √©galement l'avantage de pouvoir optimiser et adapter l'ex√©cutable pour une ou des machines sp√©cifiques. Dans la majorit√© des cas, l'ex√©cutable compil√© sera plus performant et plus rapide qu'un √©quivalent dans un langage interpr√©t√©. Dans votre cas, vous allez coder en C++ qui est un langage compil√© et ce sera donc la premi√®re √©tape de ce cours. Nous allons voir ensemble comment installer tous les outils n√©cessaires √† tout d√©veloppeur C++ sur votre machine afin d'ex√©cuter votre premier programme C++. ","version":"Next","tagName":"h2"},{"title":"Des boucles pour gagner du temps","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Loops","content":"","keywords":"","version":"Next"},{"title":"While - \"Tant que ...\"‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#while---tant-que-","content":"La premi√®re est la boucle while, de l'anglais qui signifie &quot;tant que&quot;. Elle ex√©cute une s√©rie d‚Äôinstructions tant qu'une condition est vraie. Une fois que la condition devient fausse la boucle s‚Äôarr√™te et passe √† la suite. Un petit exemple #include &lt;iostream&gt; int main() { int count { 0 }; // initialisation (d'un compteur ou autre chose li√© √† la boucle) while ( count &lt; 10 /* condition */) { std::cout &lt;&lt; count &lt;&lt; std::endl; // Instructions count++; // It√©ration (mise √† jour du compteur g√©n√©ralement) } return 0; }  Le code √©value la condition avant d'effectuer quoi que ce soit. Dans notre cas si le compte est sup√©rieur √† 0 alors on va afficher le nombre et le d√©cr√©menter. Quand finalement count vaut 0, la condition devient fausse, on passe √† la suite du code. (on ne va donc pas afficher la valeur 0) attention Attention aux boucles infinies ! Lorsque vous cr√©ez une boucle, assurez-vous qu'elle puisse s'arr√™ter √† un moment ! Si la condition est toujours vraie, votre programme ne s'arr√™tera jamais ! ","version":"Next","tagName":"h2"},{"title":"Do while‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#do-while","content":"De mani√®re tr√®s similaire il existe la boucle Do... while, qui signifie &quot;fait .. tant que...&quot; Ce type de boucle est moins utilis√©. La seule chose qui change par rapport √† une boucle while, c'est la position de la condition : au lieu d'√™tre au d√©but de la boucle, la condition est √† la fin. remarque La boucle while peut tr√®s bien ne jamais √™tre ex√©cut√©e si la condition est fausse d√®s le d√©part. Dans mon exemple pr√©c√©dent, si on avait initialis√© le count √† -1, la condition aurait √©t√© fausse d√®s le d√©but, et on ne serait jamais rentr√© dans la boucle. Pour la boucle Do... while, on rentre au moins une fois √† l'int√©rieur. Le test se fait √† la fin. Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle. #include &lt;iostream&gt; int main() { int sum {0}; int number; do { std::cout &lt;&lt; &quot;Entre un nombre: &quot;; std::cin &gt;&gt; number; sum += number; } while (number != 0); std::cout &lt;&lt; &quot;La somme vaut &quot; &lt;&lt; sum &lt;&lt; std::endl; return 0; }  attention Il y a une petite sp√©cificit√© suppl√©mentaire ici, il faut ajouter un &quot;;&quot; √† la fin de la ligne contenant la condition while. ","version":"Next","tagName":"h2"},{"title":"For‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#for","content":"Un des cas les plus fr√©quents avec les boucles est d'avoir un compteur et un nombre d'it√©rations pr√©d√©fini. On pourrait tr√®s bien le faire avec la boucle while: int count { 0 }; // initialisation (d'un compteur ou autre chose li√© √† la boucle) while ( count &lt; 10 /* condition */) { // Instructions count++; // It√©ration (mise √† jour du compteur g√©n√©ralement) }  Mais il existe une boucle d√©di√©e √† cela qui permet de s√©parer le reste de notre code de ce qui est li√© √† la boucle. Cela rend le code plus clair et plus compr√©hensible surtout dans le cas ou l'on connait √† l'avance le nombre d'it√©rations. C'est la boucle for (&quot;pour&quot; en anglais) et elle s'utilise selon le sch√©ma suivant: for (int count {0} /*initialisation*/ ; count &lt; 10 /*condition*/ ; count++/*It√©ration*/) { // Instructions }  Voil√† le m√™me exemple qu'avec la boucle while mais ici avec la boucle for : #include &lt;iostream&gt; int main() { for (int count { 0 }; count &lt; 10 ; count++) { std::cout &lt;&lt; count &lt;&lt; std::endl; } return 0; }  L'avantage ici est que le d√©tail de ce que fait la boucle est concentr√© sur la m√™me ligne. info Un autre gros avantage est que la port√©e de la variable (scope) est limit√©e √† la boucle et donc rend notre code plus s√ªr et propre. #include &lt;iostream&gt; int main() { for (int count { 10 }; count &gt; 0 ; count--) { std::cout &lt;&lt; count &lt;&lt; std::endl; } std::cout &lt;&lt; count &lt;&lt; std::endl; return 0; } La variable count ici est uniquement n√©cessaire pour la boucle en question et n'a donc pas lieu d'√™tre partag√©e ensuite avec le reste du code pour √©viter des erreurs. Si on essaye de le faire le compilateur nous donne l'erreur suivante: Compilation failed due to following error(s) main.cpp: In function ‚Äòint main()‚Äô: main.cpp:17:18: error: ‚Äòcount‚Äô was not declared in this scope 17 | std::cout &lt;&lt; count &lt;&lt; std::endl; | ^~~~~  Mais alors quand choisir une boucle while ou une boucle for ? C'est une question l√©gitime et il n'y a pas de bonne r√©ponse, vous √™tes libre. En g√©n√©ral on utilise une boucle for dans le cas o√π l'on connait le nombre d'it√©rations √† l'avance (un compteur, un nombre de niveaux ou de joueurs dans un jeu, etc...). La boucle while, quant √† elle, est g√©n√©ralement utilis√©e pour effectuer des actions sans savoir √† l'avance le nombre d'it√©rations que l'on va effectuer (par exemple la gestion de l'entr√©e utilisateur ou dans un jeu faire bouger un ennemi tant qu'il n'a pas atteint sa cible) astuce Plus simplement, essayez de dire ce que vous voulez faire et si votre phrase contient &quot;pour&quot; ou &quot;pour chaque ... faire ...&quot; il est pr√©f√©rable d'utiliser une boucle for. Et si vous vous d√Ætes &quot;Tant que ... faire ...&quot; alors vous devriez utiliser une boucle while. ","version":"Next","tagName":"h2"},{"title":"Contr√¥ler l'ex√©cution‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#contr√¥ler-lex√©cution","content":"Les boucles sont tr√®s utiles, mais parfois on aimerait pouvoir contr√¥ler plus finement les instructions √† l‚Äôint√©rieur des accolades et pouvoir s'arr√™ter plus t√¥t ou ne pas ex√©cuter les instructions pour un cas particulier. Il existe en C++ deux mots-cl√©s: break et continue ","version":"Next","tagName":"h2"},{"title":"Break‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#break","content":"Break (de anglais &quot;casser&quot;/&quot;interrompre&quot;) permet d'interrompre une boucle et mettre fin √† l‚Äôex√©cution de celle-ci peu importe o√π on en est. Voyons un exemple plus &quot;complexe&quot; ensemble: for (int i { 0 }; i &lt; 5; ++i) { std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; for (int j { 0 }; j &lt; i; ++j) { if (j == 2) { std::cout &lt;&lt; &quot;break j == 2&quot; &lt;&lt; std::endl; break; } std::cout &lt;&lt; &quot;j : &quot; &lt;&lt; j &lt;&lt; std::endl; } std::cout &lt;&lt; std::endl; }  qui nous donne le r√©sultat suivant: i: 0 i: 1 j: 0 i: 2 j: 0 j: 1 i: 3 j: 0 j: 1 break j == 2 i: 4 j: 0 j: 1 break j == 2  Ici il y a plusieurs choses qui se passent: il y a d√©j√† deux boucles imbriqu√©es, et oui rien ne nous emp√™che de faire cela en C++la deuxi√®me boucle (sur la variable j) d√©pend de la variable i de la premi√®re (c'est parfois utile de le faire et je vous montre donc un petit exemple)ici le mot cl√© break permet d'interrompre la boucle de la variable j si la valeur de j est √©gale √† 2. Une petite analyse des it√©rations s'impose: la premi√®re fois i est √©gal √† 0 et donc la condition j &lt; i est directement fausse vu que j aussi est √©gal √† 0. ensuiteensuite i est √©gal √† 1 et donc on passe une fois seulement dans la boucle du j car √† la seconde it√©ration j devient √©gal √† i et invalide la condition j &lt; i.la troisi√®me fois c'est le break qui entre en jeu et permet d'interrompre la boucle quand j est √©gal √† 2 (√† noter que la condition de la boucle aurait aussi invalid√© la condition j &lt; i)enfin ici le break prend tout son sens car s'il n'√©tait pas l√†, on aurait encore continu√© un tour car j √©tant √©gal √† 3, la condition (j &lt; i) serait valide car i est √©gal √† 4 et que 3 &lt; 4. attention Comme nous venons de le voir, dans le cas de boucles imbriqu√©es cela arr√™te seulement la boucle du niveau au dessus et pas toutes les boucles. ","version":"Next","tagName":"h3"},{"title":"Continue‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#continue","content":"L‚Äôautre mot-cl√©, continue, permet de sauter l‚Äôit√©ration courante. Toutes les instructions restantes du bloc sont ignor√©es et la boucle continue au tour suivant. for (int i { 0 }; i &lt; 5; ++i) { if( i == 3) { continue; } std::cout &lt;&lt; &quot;i : &quot; &lt;&lt; i &lt;&lt; std::endl; }  Ce qui nous donne: i : 0 i : 1 i : 2 i : 4  danger Comme cela interrompt la totalit√© des instructions suivantes de la boucle cela peut √™tre dangereux dans le cas d'une boucle while: #include &lt;iostream&gt; int main() { int count { 10 }; while (count &gt; 0) { std::cout &lt;&lt; count &lt;&lt; std::endl; if (count == 5) { continue; } count--; } return 0; } Ici, l'instruction de count--; ne sera donc jamais appel√©e une fois que count devient √©gal √† 5.count restera donc √©gal √† 5 ind√©finiment: C'est une boucle infinie. ","version":"Next","tagName":"h3"},{"title":"Switch‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#switch","content":"Mainteant que nous avons toutes les cartes en main revenons bri√®vement au switch dont je vous parlais au chapitre pr√©c√©dent sur les conditions. Tr√®s souvent on veut tester la valeur d'une variable et effectuer telle ou telle action en fonction. On pourrait tr√®s bien √©crire cela avec des else if: #include &lt;iostream&gt; int main() { int value { 42 }; if ( value == 12 ) { // ... } else if ( value == 33 ) { // ... } else if ( value == 52) { //... } else { //... } return 0; }  C'est avec le mot cl√© switch que l'on va pouvoir faire cela de fa√ßon plus lisible: #include &lt;iostream&gt; int main() { int value { 42 }; switch (value) { case 12: // ... break; // permet de quitter le bloc switch case 33: // ... break; case 52: // ... break; default: // ... break; } return 0; }  Lorsque l'expression test√©e est √©gale √† une des valeurs list√©es avec les mots-cl√©s case la totalit√© des instructions qui suivent sont ex√©cut√©es. Le mot cl√© break indique la sortie de la structure de contr√¥le. Le mot cl√© default indique quelles instructions ex√©cuter si l'expression n'est jamais √©gale √† une des valeurs. danger De mani√®re g√©n√©rale, n'oubliez pas d'ins√©rer des instructions break entre chaque test, ce genre d'oubli est difficile √† d√©tecter car aucune erreur n'est signal√©e... En effet la totalit√© des instructions suivant le case sont ex√©cut√©es et donc on pourrait se retrouver √† ex√©cuter des instructions de mani√®re involontaire. #include &lt;iostream&gt; int main() { int value { 33 }; switch (value) { case 12: std::cout &lt;&lt; &quot;value est √©gale √† 12&quot; &lt;&lt; std::endl; case 33: std::cout &lt;&lt; &quot;value est √©gale √† 33&quot; &lt;&lt; std::endl; default: std::cout &lt;&lt; &quot;value est diff√©rent de 12 ou 33&quot; &lt;&lt; std::endl; } return 0; } qui nous donne: value est √©gale √† 33 value est diff√©rent de 12 ou 33 Cela peut √™tre parfois voulu mais ici on se rend bien compte qu'il y a un probl√®me et il ne faut donc pas oublier le mot cl√© break. Voici un exemple o√π cela peut √™tre utile: #include &lt;iostream&gt; int main() { char letter { 'e' }; switch(letter) { case 'a': case 'e': case 'i': case 'o': case 'u': case 'y': std::cout &lt;&lt; &quot;You entered a vowel.&quot; &lt;&lt; std::endl; break; default: std::cout &lt;&lt; &quot;You entered a consonant.&quot; &lt;&lt; std::endl; break; } return 0; } Certains warnings de compilateur permette d'indiquer ce genre de cas mais c'est mieux d'y faire attention. ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Des boucles pour gagner du temps","url":"/Learn--cpp_programming/Lessons/S1/Loops#r√©sum√©","content":"Il existe trois types de boucle: la boucle while qui permet d'ex√©cuter des instructions tant qu'une condition est v√©rifi√©e.la boucle Do while qui permet de faire la m√™me chose que la boucle while mais en faisant le test seulement √† la fin et permettant d'ex√©cuter les instructions au moins une fois.la boucle for plus utile en pratique quand l'on connait √† l'avance le nombre d'it√©rations √† effectuer. Elle permet aussi de mieux &quot;scoper&quot; les variables et limiter leur port√©e. Il existe deux mots-cl√©s break et continue qui permettent de contr√¥ler plus finemment les boucles. La structure de contr√¥le switch est une alternative au else if. ","version":"Next","tagName":"h2"},{"title":"Allouer et manipuler la m√©moire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Mode d'allocation‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#mode-dallocation","content":"Il existe trois principaux modes d‚Äôallocation de la m√©moire: l‚Äôallocation statiquel‚Äôallocation sur la Stackl‚Äôallocation sur la Heap ","version":"Next","tagName":"h2"},{"title":"Allocation statique‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-statique","content":"Lorsque le programme s‚Äôinitialise, il demande une quantit√© de m√©moire sp√©cifi√©e dans le code source du programme, laquelle ne pourra pas changer par la suite. Nous n'avons pas rencontr√© ce type d'allocation pour l'instant mais sachez que √ßa existe. ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Stack‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-stack","content":"Jusqu'a pr√©sent, nous avons principalement rencontr√© des allocations de m√©moire sur la Stack. C'est le cas de toutes nos variables locales (dans des fonctions, y compris dans la fonction main). La Stack (ou pile en fran√ßais) est une zone m√©moire qui sert d‚Äôespace de stockage aux variables d√©clar√©es par les fonctions et permet aussi de garder une trace des appels de fonctions. Elle tient son nom de son mode de fonctionnement, semblable √† une pile de dossiers. Il s‚Äôagit d‚Äôune structure de donn√©es fond√©e sur le principe ‚Äúdernier pos√© sur le dessus de la pile, premier √† sortir‚Äù. Cet ordonnancement s‚Äôappelle LIFO (Last In, First Out). La Stack poss√®de donc deux actions principales : push, pour ajouter un √©l√©ment, et pop pour retirer et r√©cup√©rer cet √©l√©ment. Cela rend tr√®s simple le suivi de la pile pour lib√©rer ou demander de la m√©moire. Comme les acc√®s √† la Stack sont contigu√´s et que les m√™mes adresses m√©moire tendent √† √™tre r√©utilis√©es, les lectures et √©critures dans la Stack sont tr√®s performantes. Cependant cela manque de souplesse car son allocation doit √™tre &quot;pr√©vue&quot; lors de l‚Äô√©criture du programme (Pour des variables de taille d√©j√† connue √† la compilation). info La Stack a une taille fix√©e (qui d√©pend des machines et syst√®mes d'exploitation(OS)). Pour garder une trace de l‚Äôemplacement m√©moire actuel, il existe un pointeur appel√© Stack Pointer. Chaque fois que quelque chose doit √™tre √©crit ou retir√© dans la Stack, on d√©place simplement ce pointeur. Le pointeur ne peut pas aller au del√† des limites de la Stack, cela risque de provoquer un crash du programme appel√© Stack overflow. Cela peut se produire avec une fonction r√©cursive avec de nombreux appels r√©cursifs ou sans condition d'arr√™t par exemple. La syntaxe pour allouer de la m√©moire sur la Stack est la suivante: int x {};  Vous connaissez d√©j√† cette syntaxe, c'est simplement la d√©claration d'une variable locale. ","version":"Next","tagName":"h3"},{"title":"Allocation sur la Heap‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-sur-la-heap","content":"L‚Äôallocation sur la Heap se fait de mani√®re dynamique pendant l‚Äôex√©cution d‚Äôun programme (on parle de runtime). L‚Äôespace n√©cessaire n‚Äôa pas besoin d'√™tre d√©fini en amont dans le code. Le programme effectue la demande d‚Äôallocation d‚Äôespace √† l‚ÄôOS au cours de son ex√©cution. remarque Il y a g√©n√©ralement un abus de langage et ce que l'on qualifie d'allocation dynamique d√©signe ce type d'allocation sur la Heap. L'allocation sur la Stack est √©galement dynamique dans le sens o√π elle se produit pendant l'ex√©cution du programme en fonction des variables d√©clar√©es. La Heap permet donc le contr√¥le compl√®tement arbitraire de l‚Äôallocation et de la lib√©ration. Lorsque le processus n√©cessite plus de m√©moire, il en fait simplement la demande √† l‚ÄôOS (dans la limite o√π il est en mesure de fournir un tel emplacement m√©moire). C'est donc aussi ce type d'allocation que l'on privil√©gie dans le cas de gros volumes de donn√©es. Cependant, cela demande de maintenir des pointeurs pour chacune des valeurs stock√©es, afin de savoir o√π se trouve la m√©moire demand√©e pour pouvoir la manipuler mais aussi la lib√©rer. Cette gestion de la m√©moire √©tant plus &quot;complexe&quot;, les performances n‚Äôen sont g√©n√©ralement pas aussi bonnes, mais parfois on n'a tout simplement pas le choix. La syntaxe pour allouer de la m√©moire sur la Heap est la suivante: int* x { new int };  Je vous expliquerai plus en d√©tail ce que cela signifie dans la suite de ce chapitre. ","version":"Next","tagName":"h3"},{"title":"Adresse et pointeurs‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#adresse-et-pointeurs","content":"J'ai √©voqu√© le terme de pointeur mais qu'est ce que c'est ? Une variable est localis√©e quelque part dans notre m√©moire. On peut voir la m√©moire de notre ordinateur comme une grande √©tag√®re √† livres dans laquelle chaque emplacement est num√©rot√©. Chaque variable a une adresse (un num√©ro) qui permet de savoir o√π elle se trouve en m√©moire. Cette adresse est simplement un nombre (g√©n√©ralement repr√©sent√© sous forme hexad√©cimale). On peut r√©cup√©rer l'adresse d'une variable en ajoutant le symbole &quot;esperluette&quot; &amp; devant le nom de la variable en question. Essayons: #include &lt;iostream&gt; int main() { int integer {4}; std::cout &lt;&lt; &amp;integer &lt;&lt; std::endl; return 0; }  qui nous donne un truc qui ressemble √† √ßa: 0x7ffe08bf5854  Ce nombre indique o√π est stock√©e la valeur de notre variable en m√©moire (que ce soit la heap ou la stack). Maintenant que nous savons o√π se trouve notre variable on va pouvoir stocker cette adresse. C'est justement le r√¥le du pointeur de stocker l'adresse d'une variable. On indique que l'on souhaite manipuler un pointeur en ajoutant le symbole * apr√®s le type de la variable. Cela indique donc que l'on stocke une adresse vers une variable du type indiqu√© et non une valeur. #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h2"},{"title":"D√©r√©f√©rencement‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#d√©r√©f√©rencement","content":"Avec ce pointeur, il est possible de faire ce qu'on appelle un d√©r√©f√©rencement et aller voir le contenu de l'emplacement situ√© √† l'adresse stock√©e. C'est-√†-dire, la valeur de la variable point√©e. Pour faire un d√©r√©f√©rencement on utilise √©galement le symbole * devant le nom de notre pointeur comme cela: #include &lt;iostream&gt; int main() { int integer {4}; int* integer_pointer {&amp;integer}; std::cout &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;address: &quot; &lt;&lt; integer_pointer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; *integer_pointer &lt;&lt; std::endl; // On peut m√™me modifier la valeur de notre variable par ce biais *integer_pointer = 18; std::cout &lt;&lt; &quot;value of integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h3"},{"title":"Null pointer‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#null-pointer","content":"Il est possible d'indiquer qu'un pointeur ne pointe actuellement sur rien en lui attribuant une valeur nulle avec le mot-cl√© nullptr: Il s'agit alors d'un pointeur nul (ou null pointer en anglais). Le d√©r√©f√©rencement d'un pointeur nul provoque une erreur: #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { float* float_pointer {nullptr}; displayPointer(float_pointer); // null return 0; }  info Il existe √©galement le mot-cl√© NULL qui vient du C pour indiquer un pointeur nul. Il a cependant des inconv√©nients et je vous demande d'utiliser nullptr en C++ qui est plus s√ªr. ","version":"Next","tagName":"h3"},{"title":"Allocation dynamique en pratique: New & delete‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#allocation-dynamique-en-pratique-new--delete","content":"Comme je l'ai √©voqu√© pr√©c√©demment avec l‚Äôallocation dynamique dans la Heap on va donc demander un emplacement m√©moire et le lib√©rer plus tard. Cela se fait avec les mots-cl√©s new et delete. Cette demande de m√©moire va retourner un pointeur. #include &lt;iostream&gt; int main() { // je demande un emplacement m√©moire pour un entier int* integer_ptr {new int}; // je peux aussi demander et initialiser un entier int* number_ptr {new int{5}}; std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; // Une fois que l'on en a plus besoin, on lib√®re les zones m√©moire demand√©es delete number_ptr; delete integer_ptr; return 0; }  qui nous donne: 0x557590f93eb0 5  danger Le pointeur est toujours &quot;existant&quot; apr√®s avoir √©t√© lib√©r√©. Le pointeur n'est rien d'autre qu'un nombre repr√©sentant l'adresse m√©moire. Cela ne veut pas dire que nous avons le droit de manipuler cette m√©moire. Si l'espace m√©moire point√© par le pointeur est lib√©r√©, il ne faut pas l'utiliser car cet emplacement m√©moire ne nous appartient plus. #include &lt;iostream&gt; int main() { int* number_ptr {new int{2}}; delete number_ptr; // Ici l'adresse √©tant un nombre, elle est toujours valide std::cout &lt;&lt; number_ptr &lt;&lt; std::endl; // Mais la valeur contenue √† cette adresse peut prendre n'importe quelle valeur en fonction de l'usage nouveau de cet emplacement m√©moire std::cout &lt;&lt; *number_ptr &lt;&lt; std::endl; return 0; } Il est donc recommand√© d'assigner au pointeur la valeur nullptr une fois lib√©r√© pour √©viter tout probl√®me. int* number_ptr {new int{2}}; delete number_ptr; number_ptr = nullptr; // ...  ","version":"Next","tagName":"h2"},{"title":"Tableaux‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#tableaux","content":"Il est √©galement possible de demander plusieurs emplacements m√©moire contigu√´s (autrement dit un tableau) d'un coup en pr√©cisant entre crochets la taille du tableau [ ] . Le pointeur va contenir alors l'adresse du premier √©l√©ment du tableau. L'adresse stock√©e par le pointeur √©tant un nombre (repr√©sent√© en hexad√©cimal) il est possible de faire des op√©rations dessus comme l'addition ou la soustraction. Cela permet de se positionner sur un emplacement m√©moire pr√©cis du tableau. Pour lib√©rer un tableau allou√© dynamiquement, il faut utiliser le mot-cl√© delete suivi de crochets [ ] . int main() { // attention ici les valeurs ne sont pas initialis√©es int* array_ptr {new int[5]}; // Je me positionne sur le 3√®me √©l√©ment du tableau et j'utilise le d√©r√©f√©rencement pour modifier sa valeur *(array_ptr + 2) = 42; // On peut aussi utiliser la notation avec les crochets qui est √©quivalente array_ptr[2] = 42; // Je lib√®re l'espace m√©moire allou√© delete[] array_ptr; return 0; }  remarque Si la taille est connue √† l'avance (√† la compilation), il est aussi possible de d√©clarer un tableau sur la Stack avec la taille entre crochets [ ]. int main() { int array[5]; // Je peux acc√©der aux valeurs du tableau avec les crochets array[0] = 42; return 0; }  danger Il est important de noter que le pointeur ne contient pas la taille du tableau. Il est donc important de la conserver quelque part pour ne pas d√©passer la taille du tableau. Si vous d√©passez, vous risquez de modifier des valeurs qui ne vous appartiennent pas et donc de causer des erreurs. int main() { int* array_ptr {new int[5]}; // Ici je d√©passe la taille du tableau et j'essaie de modifier une valeur qui ne m'appartient pas array_ptr[5] = 42; return 0; } Il s'agit d'une erreur tr√®s courante appel√©e &quot;erreur de segmentation&quot;. Elle se produit lorsque votre programme essaie de lire ou d'√©crire dans une zone m√©moire qui ne lui a pas √©t√© attribu√©e (ou ne l'est plus). C'est la fa√ßon de g√©rer les tableaux en C. Cependant, en C++ il existe des structures de donn√©es plus adapt√©es pour g√©rer les tableaux comme std::array ou std::vector que nous avons vu pr√©c√©demment. ","version":"Next","tagName":"h2"},{"title":"std::vector: explications‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdvector-explications","content":"Justement, parlons un peu de std::vector. Comme dit pr√©c√©demment, l'allocation dynamique (sur la Heap) est particuli√®rement int√©ressante lorsque l‚Äôon ne sait pas √† l‚Äôavance la taille dont on va avoir besoin. C'est exactement le cas d'utilisation du std::vector. En effet, std::vector n'est rien d'autre qu'une structure de donn√©e qui g√®re en interne un pointeur vers une zone m√©moire contigu√´. Lorsque celui-ci est trop petit et que l'on souhaite tout de m√™me ajouter une valeur, la structure demande un nouvel espace m√©moire plus grand, copie les donn√©es dans ce nouvel espace m√©moire et enfin lib√®re l'ancien espace m√©moire qui n'est donc plus utilis√©. Ce changement (allocation, copie, lib√©ration de m√©moire) a un co√ªt c'est pourquoi std::vector pr√©voit un espace plus grand que n√©cessaire lors d'une allocation pour anticiper de futurs ajouts dans le tableau dynamique. Il est possible de conna√Ætre la taille de l'espace de stockage allou√© pour le std::vector avec sa m√©thode capacity() qui retourne cette taille exprim√©e en nombre d'√©l√©ments. C'est diff√©rent de la taille actuellement utilis√©e qui s'obtient avec la m√©thode size().  Une impl√©mentation simplifi√©e struct IntegerVector { size_t size {0}; size_t capacity {0}; int* pointer {nullptr}; void reserve(size_t const newCapacity) { if (newCapacity &lt;= capacity) { return; } // Je demande un nouvel espace m√©moire int* newPointer {new int[newCapacity]}; // Si j'avais d√©j√† un espace m√©moire if (pointer != nullptr) { // Je copie les donn√©es de l'ancien espace m√©moire vers le nouveau std::copy(pointer, pointer + size, newPointer); // Je lib√®re l'ancien espace m√©moire delete [ ] pointer; } // Je met √† jour les informations de la structure capacity = newCapacity; pointer = newPointer; } void push_back(int const value) { // Si je n'ai plus de place dans mon tableau, j'en demande plus if( size == capacity ) { reserve( 2 * capacity + 1 ); } // J'ajoute la valeur √† la fin du tableau objects[size] = value; size++; } void pop_back() { if (size &gt; 0) { size--; } } int &amp; at(size_t const index) { // Si l'index est en dehors du tableau, je l√®ve une exception (erreur) // Nous n'avons pas encore vu les exceptions, mais c'est un m√©canisme qui permet de g√©rer les erreurs if (index &gt;= size) { throw std::out_of_range(&quot;Index out of range&quot;); } // Je retourne la valeur √† l'index demand√© return pointer[index]; } //... }; std::vector est bien s√ªr plus complexe que cela et a √©t√© fait par des experts du C++ mais cela permet de comprendre le principe qui se cache derri√®re cette structure de donn√©e. ","version":"Next","tagName":"h2"},{"title":"Structure et This‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#structure-et-this","content":"Vous vous souvenez de l'utilisation du mot-cl√© this dans les m√©thodes de nos structures ? this est en fait un pointeur vers la structure elle m√™me ! On peut donc faire un d√©r√©f√©rencement et avoir acc√®s √† la structure pour la modifier. struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { (*this).price = price; // this-&gt;price = price; } };  C'est ce qui permet ici de faire la diff√©rence entre price qui est un param√®tre de la m√©thode et this-&gt;price qui est le membre de la structure. info La syntaxe -&gt; est en r√©alit√© un raccourci de syntaxe qui permet de faire un d√©r√©f√©rencement puis d'acc√©der √† un membre ou une m√©thode de la structure: Ces deux √©critures sont donc √©quivalentes: this-&gt;member (*this).member. ","version":"Next","tagName":"h2"},{"title":"Les r√©f√©rences dans tout √ßa‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#les-r√©f√©rences-dans-tout-√ßa","content":"Vous avez remarqu√© des ressemblances entre les pointeurs et les r√©f√©rences ? C'est normal c'est le m√™me m√©canisme sous-jacent. La r√©f√©rence utilise l'adresse m√©moire de la variable cibl√©e. attention Cependant, une r√©f√©rence ne peut pas √™tre nulle comme avec nullptr pour les pointeurs. Une r√©f√©rence est forc√©ment associ√©e √† une variable. Une r√©f√©rence peut √™tre consid√©r√©e comme un pointeur avec d√©r√©f√©rencement automatique, c'est-√†-dire que le compilateur applique en quelque sorte l'op√©rateur * pour vous. comparaison #include &lt;iostream&gt; void addOneUsingPtr(int * a) { *a += 1; } void addOneUsingRef(int &amp; a) { a += 1; } void constDisplayUsingRef(int const &amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } void constDisplayUsingPtr(int const * a) { std::cout &lt;&lt; *a &lt;&lt; std::endl; }  La r√©f√©rence a donc l'avantage d'√™tre plus lisible et simple √† utiliser. remarque Utiliser les pointeurs directement est plut√¥t r√©serv√© √† des cas sp√©cifiques. Comme par exemple dans le cas o√π on souhaite une &quot;r√©f√©rence&quot; optionnelle (qui peut √™tre nulle) ou alors r√©assigner la r√©f√©rence √† une autre variable. #include &lt;iostream&gt; void displayPointer(int const* ptr) { if (ptr != nullptr) { std::cout &lt;&lt; *ptr &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;null&quot; &lt;&lt; std::endl; } } int main() { int a {42}; int b {24}; int&amp; ref {a}; ref = b; // a = b int* ptr {&amp;a}; *ptr = 12; // a = 12 ptr = &amp;b; // ptr pointe sur b *ptr = 36; // b = 36 displayPointer(ptr); // 36 ptr = nullptr; displayPointer(ptr); // null return 0; }  ","version":"Next","tagName":"h2"},{"title":"Pointeurs intelligents‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#pointeurs-intelligents","content":"Pendant l‚Äôex√©cution d'un programme, le syst√®me ne peut pas √©craser ce que les d√©veloppeurs ont demand√©. C‚Äôest √† nous, humains, de le g√©rer avec le mot-cl√© delete sinon cela provoque une fuite de m√©moire. Une fuite de m√©moire est la m√©moire qui a √©t√© demand√©e par l‚Äôutilisateur et qui n‚Äôa jamais √©t√© lib√©r√©e, lorsque le programme s‚Äôest termin√© ou que des pointeurs vers son emplacement ont √©t√© perdus. Pour √©viter cela, chaque fois que nous n‚Äôavons plus besoin d‚Äôun √©l√©ment de la Heap allou√©, nous devons absolument le lib√©rer. L'accumulation de fuites de m√©moire risque de provoquer un crash du programme ou de ralentir le syst√®me d'exploitation ou m√™me dans le pire des cas faire planter l'ordinateur.  Pour √©viter ce probl√®me, et nous aider √† g√©rer la m√©moire le C++11 a introduit des pointeurs dits intelligents (smart pointer en anglais) dans la biblioth√®que standard. Lorsque le pointeur est d√©truit, la m√©moire allou√©e pr√©c√©demment est √©galement lib√©r√©e. Il n'est donc pas n√©cessaire de lib√©rer la m√©moire explicitement avec delete, c'est le pointeur intelligent qui s'en charge. Un pointeur intelligent est en quelque sorte une structure enveloppant un pointeur et permettant de s'assurer que la m√©moire est lib√©r√©e une fois que le pointeur n'est plus utilis√©. ","version":"Next","tagName":"h2"},{"title":"unique_ptr‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#unique_ptr","content":"std::unique_ptr est un pointeur intelligent qui g√®re une zone m√©moire allou√©e dynamiquement. Il est, comme son l'indique, l'unique responsable de cette zone m√©moire. Elle sera d√©truite d√®s que le pointeur est d√©truit. Il ne peut pas √™tre copi√©, c'est √† dire que l'on ne peut pas avoir deux std::unique_ptr pointant vers le m√™me objet. Sinon, lors de la destruction des deux pointeurs, l'objet serait d√©truit deux fois. #include &lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; ptr {new int{42}}; // On ne peut pas copier un unique_ptr // std::unique_ptr&lt;int&gt; ptr2 {ptr}; // A la fin du bloc (de la fonction main ici), ptr est d√©truit et l'espace m√©moire est lib√©r√© }  ","version":"Next","tagName":"h3"},{"title":"shared_ptr‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#shared_ptr","content":"std::shared_ptr est un pointeur intelligent qui g√®re une zone m√©moire allou√©e dynamiquement. La responsabilit√© de cette zone m√©moire peut-√™tre partag√©e entre plusieurs std::shared_ptr, et elle ne sera d√©truite que quand tous les std::shared_ptr responsables auront √©t√© d√©truits. Il est possible de copier un std::shared_ptr pour partager la responsabilit√© de la zone m√©moire. Il utilise un compteur interne pour savoir combien de std::shared_ptr pointent vers la zone m√©moire. Lorsque ce compteur tombe √† z√©ro, la zone m√©moire est lib√©r√©e. #include &lt;memory&gt; int main() { std::shared_ptr&lt;int&gt; ptr1 {new int{42}}; { // On peut copier un shared_ptr std::shared_ptr&lt;int&gt; ptr2 {ptr1}; // Changer la valeur de ptr1 *ptr1 = 24; // ptr1 et ptr2 pointent vers la m√™me zone m√©moire std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 24 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 24 *ptr2 = 12; std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 std::cout &lt;&lt; &quot;ptr2 value:&quot; &lt;&lt; *ptr2 &lt;&lt; std::endl; // 12 // Ici ptr2 est d√©truit mais la zone m√©moire n'est pas lib√©r√©e car ptr1 pointe toujours vers cette zone m√©moire } std::cout &lt;&lt; &quot;ptr1 value:&quot; &lt;&lt; *ptr1 &lt;&lt; std::endl; // 12 // A la fin du bloc (de la fonction main ici), ptr1 est d√©truit et l'espace m√©moire est lib√©r√© return 0; }  C'est utile lorsque l'on souhaite partager un objet entre plusieurs parties du code. ","version":"Next","tagName":"h3"},{"title":"std::weak_ptr‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#stdweak_ptr","content":"Il existe √©galement un pointeur intelligent std::weak_ptr qui est un pointeur qui permet de pointer vers un objet g√©rer par un std::shared_ptr sans augmenter le compteur de r√©f√©rences. C'est utile pour √©viter des r√©f√©rences circulaires et mieux g√©rer le cycle de vie des objets mais nous n'irons pas plus loin dans ce cours. ","version":"Next","tagName":"h3"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Allouer et manipuler la m√©moire","url":"/Learn--cpp_programming/Lessons/S1/MemoryAllocation#r√©sum√©","content":"Il existe plusieurs types d'allocation de m√©moire: L'allocation de m√©moire statique est effectu√©e √† la compilation. Elle est donc tr√®s rapide mais ne permet pas de modifier la taille de la m√©moire allou√©e.L'allocation de m√©moire sur la stack est effectu√©e √† l'ex√©cution. Elle est utilis√©e pour allouer nos variables locales et est √† privil√©gier car elle est rapide.L'allocation de m√©moire dynamique sur la heap est effectu√©e √† l'ex√©cution. Elle est utilis√©e si on ne conna√Æt pas la taille de la m√©moire √† allouer √† la compilation ou si on veut modifier la taille de la m√©moire allou√©e. Cela permet de g√©rer plus finement la m√©moire mais est plus lente que l'allocation de m√©moire sur la stack. Un pointeur est une variable qui contient une adresse m√©moire (un nombre repr√©sent√© en hexad√©cimal). C'est un type de variable √† part enti√®re qu'on diff√©rencie avec le symbole * apr√®s le type de la variable. On utilise les mots-cl√©s new et delete pour allouer et d√©sallouer de la m√©moire sur la heap. Le d√©r√©f√©rencement d'un pointeur permet d'acc√©der √† la valeur de la variable point√©e. Cela s'effectue avec l'op√©rateur * devant le nom du pointeur. Il est possible d'attribuer √† un pointeur la valeur nullptr qui repr√©sente un pointeur nul. Cela permet d'indiquer qu'un pointeur ne pointe sur rien. On l'utilise pour v√©rifier qu'un pointeur est valide avant de l'utiliser. std::vector est un conteneur qui permet de g√©rer les allocations dynamiques de tableaux √† notre place. le mot-cl√© this est un pointeur vers la structure elle m√™me. Cela permet de faire la diff√©rence entre un param√®tre de m√©thode et un membre de la structure. Il existe des pointeurs intelligents (smart pointer) qui permettent de g√©rer la m√©moire √† notre place. Ils sont tr√®s pratiques car ils permettent d'√©viter les fuites m√©moires et les erreurs de d√©sallocation de m√©moire. ","version":"Next","tagName":"h2"},{"title":"Mise en place des outils","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/","content":"Mise en place des outils Comme expliqu√© pr√©c√©demment le C++ est un langage compil√© et il va donc falloir installer un compilateur. Mais ce n'est pas tout, il est aussi pr√©f√©rable d'utiliser un √©diteur ou IDE (Integrated Development Environment) adapt√© pour coder et je vous propose d'utiliser Visual Studio Code. De plus, nous installerons √©galement un petit outil suppl√©mentaire pour simplifier grandement l'√©tape de compilation (et particuli√®rement plus tard pour un projet compos√© de plusieurs fichiers).","keywords":"","version":"Next"},{"title":"Cmake","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/Cmake","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Cmake","url":"/Learn--cpp_programming/Lessons/S1/Setup/Cmake#installation","content":"Vous pouvez vous rendre .css-q8raqo{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-q8raqo.Mui-disabled{opacity:0.38;pointer-events:none;}.css-q8raqo .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-q8raqo .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-q8raqo .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-q8raqo .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-q8raqo .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-q8raqo .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-q8raqo .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-q8raqo .MuiChip-deleteIcon:hover,.css-q8raqo .MuiChip-deleteIcon:active{color:#fff;}.css-q8raqo:hover{background-color:rgba(0, 0, 0, 0.12);}.css-q8raqo.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-q8raqo:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-q8raqo:hover,.css-q8raqo.Mui-focusVisible{background-color:#1565c0;} .css-1giu1bt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-1giu1bt::-moz-focus-inner{border-style:none;}.css-1giu1bt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1giu1bt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1giu1bt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1giu1bt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1giu1bt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1giu1bt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1giu1bt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1giu1bt .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-1giu1bt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-1giu1bt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1giu1bt .MuiChip-deleteIcon:hover,.css-1giu1bt .MuiChip-deleteIcon:active{color:#fff;}.css-1giu1bt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1giu1bt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1giu1bt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1giu1bt:hover,.css-1giu1bt.Mui-focusVisible{background-color:#1565c0;} ici et s√©lectionner l'installeur qui correspond √† votre OS.  WindowsLinuxOSX Choisis Windows x64 Installer. Vous pouvez ensuite v√©rifier que c'est bien install√© en ex√©cutant la commande suivante dans un terminal : cmake --version   ","version":"Next","tagName":"h2"},{"title":"Installation d'un compilateur","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler","content":"","keywords":"","version":"Next"},{"title":"V√©rifier que le compilateur est install√©‚Äã","type":1,"pageTitle":"Installation d'un compilateur","url":"/Learn--cpp_programming/Lessons/S1/Setup/Compiler#v√©rifier-que-le-compilateur-est-install√©","content":"Dans un premier temps, vous allez pouvoir v√©rifier que le compilateur est bien install√© avec la commande suivante: WindowsLinuxOSX cl Avec MSVC c'est un peu particulier et la commande du compilateur ne sera accessible qu'√† travers un terminal particulier. Vous pouvez le trouver en cherchant &quot;developer powershell&quot; ou &quot;developer Command Prompt&quot; dans le Menu Windows. Vous pouvez ouvrir un terminal d√©veloppeur et essayer d'ex√©cuter la commande pr√©c√©dente. Vous devriez voir un retour comme celui l√† : C:\\Program Files\\Microsoft Visual Studio\\2022\\Community&gt; cl Microsoft (R) C/C++ Optimizing Compiler Version 19.31.31105 for x86 Copyright (C) Microsoft Corporation. All rights reserved. usage: cl [ option... ] filename... [ /link linkoption... ]  attention Cela peut ne pas fonctionner si le r√©pertoire contenant le compilateur n'est pas &quot;accessible&quot;. Les commandes sont elles-m√™mes des ex√©cutables sous forme de fichiers situ√©s quelque part sur votre ordinateur. Depuis un terminal, l'ordinateur a une liste de tous les endroits dans lesquels il va essayer de chercher les dits fichiers (commandes) √† ex√©cuter. Ces endroits (sous forme de chemins de dossier) sont list√©s dans ce qu'on appelle des variables d'environnement et particuli√®rement la variable d'environnement PATH. Pour pouvoir avoir acc√®s √† la commande du compilateur depuis n'importe o√π dans votre ordinateur il va donc falloir ajouter le chemin o√π est install√© l'ex√©cutable (les outils de compilation dans notre cas) √† cette variable PATH. WindowsLinuxOSX Vous pouvez y acc√©der en allant dans le Panneau de configuration et en cliquant sur le lien Param√®tres syst√®me avanc√©s puis sur Variables d'environnement. Ou plus simplement en cherchant &quot;path&quot; ou &quot;variable&quot; dans le Menu d√©marrer. Dans la section Variables syst√®me recherchez la variable d'environnement PATH et s√©lectionnez-la. Cliquez sur Modifier. Dans la fen√™tre qui vient de s'ouvrir, ajoutez une valeur avec le chemin vers le dossier contenant la commande. (Pour MSVC par exemple c'est quelque chose comme : &quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\19.09.26726\\bin\\HostX86\\x64&quot;)Cliquez sur OK.Fermez toutes les fen√™tres restantes en cliquant sur OK. C'est √©galement expliqu√© ici avec des illustrations si n√©cessaire. ","version":"Next","tagName":"h2"},{"title":"Visual Studio Code","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#installation","content":"Tout d'abord il s'agit d'installer l'IDE. Rendez-vous .css-q8raqo{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-q8raqo.Mui-disabled{opacity:0.38;pointer-events:none;}.css-q8raqo .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-q8raqo .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-q8raqo .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-q8raqo .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-q8raqo .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-q8raqo .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-q8raqo .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-q8raqo .MuiChip-deleteIcon:hover,.css-q8raqo .MuiChip-deleteIcon:active{color:#fff;}.css-q8raqo:hover{background-color:rgba(0, 0, 0, 0.12);}.css-q8raqo.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-q8raqo:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-q8raqo:hover,.css-q8raqo.Mui-focusVisible{background-color:#1565c0;} .css-1giu1bt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:#fff;background-color:#1976d2;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-1giu1bt::-moz-focus-inner{border-style:none;}.css-1giu1bt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1giu1bt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1giu1bt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1giu1bt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1giu1bt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1giu1bt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1giu1bt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1giu1bt .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-1giu1bt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(255, 255, 255, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-1giu1bt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1giu1bt .MuiChip-deleteIcon:hover,.css-1giu1bt .MuiChip-deleteIcon:active{color:#fff;}.css-1giu1bt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1giu1bt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1giu1bt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1giu1bt:hover,.css-1giu1bt.Mui-focusVisible{background-color:#1565c0;} ici et s√©lectionnez l'installeur adapt√© √† votre syst√®me d'exploitation.  ","version":"Next","tagName":"h2"},{"title":"Les extensions‚Äã","type":1,"pageTitle":"Visual Studio Code","url":"/Learn--cpp_programming/Lessons/S1/Setup/IDE#les-extensions","content":"Les extensions sont, comme le nom l'indique, des modules qui permettent d'√©tendre les fonctionnalit√©s de l'IDE. Elles sont list√©es ici et vous pouvez √©galement les parcourir pour les installer √† l'int√©rieur de l'IDE via le raccourci CTRL+SHIFT+X ou en cliquant sur cet onglet:  N'h√©sitez pas √† consulter les extensions recommand√©es par langage ou d√©couvrir ce que d'autres personnes utilisent. Concernant le C++, nous avons besoin au minimum d'installer ces extensions: cpptools-extension-packcmake Ces extensions vont nous permettre de lancer notre programme C++ sans difficult√©. Si vous voulez aller plus loin et conna√Ætre un peu mieux VSCode, je vous invite √† aller regarder la page .css-173r67b{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-173r67b.Mui-disabled{opacity:0.38;pointer-events:none;}.css-173r67b .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-173r67b .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-173r67b .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-173r67b .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-173r67b .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-173r67b .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-173r67b .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-173r67b:hover{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-173r67b:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-173r67b.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b .MuiChip-avatar{margin-left:4px;}.css-173r67b .MuiChip-avatarSmall{margin-left:2px;}.css-173r67b .MuiChip-icon{margin-left:4px;}.css-173r67b .MuiChip-iconSmall{margin-left:2px;}.css-173r67b .MuiChip-deleteIcon{margin-right:5px;}.css-173r67b .MuiChip-deleteIconSmall{margin-right:3px;} .css-1aq2sw4{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-1aq2sw4::-moz-focus-inner{border-style:none;}.css-1aq2sw4.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1aq2sw4{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1aq2sw4.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1aq2sw4 .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1aq2sw4 .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1aq2sw4 .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1aq2sw4 .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-1aq2sw4 .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-1aq2sw4 .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1aq2sw4:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1aq2sw4:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1aq2sw4.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4 .MuiChip-avatar{margin-left:4px;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-icon{margin-left:4px;}.css-1aq2sw4 .MuiChip-iconSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-deleteIcon{margin-right:5px;}.css-1aq2sw4 .MuiChip-deleteIconSmall{margin-right:3px;} suivante .  ","version":"Next","tagName":"h2"},{"title":"Compiler votre premier programme","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac","content":"","keywords":"","version":"Next"},{"title":"Utiliser CMake et VSCode‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#utiliser-cmake-et-vscode","content":"C'est donc possible de le faire uniquement avec des lignes de commandes mais par simplicit√© nous allons d√®s maintenant utiliser CMake dont j'ai parl√© pr√©c√©demment qui s'int√®gre facilement avec VSCode. Pour utiliser CMake il faut tout d'abord cr√©er un fichier nomm√© CMakeLists.txtVoici le premier qu'on va utiliser (quelques explications en commentaire &quot;#&quot; du fichier): CMakeLists.txt # Nous voulons un cmake &quot;r√©cent&quot; pour utiliser les derni√®res fonctionnalit√©s cmake_minimum_required(VERSION 3.0) # La version du C++ que l'on souhaite utiliser (dans notre cas C++17) set(CMAKE_CXX_STANDARD 17) # Le nom du projet project(IMAC_project) # On indique que l'on veut cr√©er un ex√©cutable &quot;helloImac&quot; compil√© √† partir du fichier helloImac.cpp add_executable(helloImac helloImac.cpp)  Ce fichier CMakeLists.txt va √™tre bien pratique car il est reconnu par divers IDE et en ce qui nous concerne on va l'utiliser avec VSCode. Il suffit d'avoir au pr√©alable install√© l'extension dont je vous ai parl√© .css-173r67b{max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-173r67b.Mui-disabled{opacity:0.38;pointer-events:none;}.css-173r67b .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-173r67b .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-173r67b .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-173r67b .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-173r67b .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-173r67b .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-173r67b .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-173r67b:hover{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-173r67b:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-173r67b.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-173r67b.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-173r67b .MuiChip-avatar{margin-left:4px;}.css-173r67b .MuiChip-avatarSmall{margin-left:2px;}.css-173r67b .MuiChip-icon{margin-left:4px;}.css-173r67b .MuiChip-iconSmall{margin-left:2px;}.css-173r67b .MuiChip-deleteIcon{margin-right:5px;}.css-173r67b .MuiChip-deleteIconSmall{margin-right:3px;} .css-1aq2sw4{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;max-width:100%;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:unset;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;background-color:transparent;border:1px solid #bdbdbd;}.css-1aq2sw4::-moz-focus-inner{border-style:none;}.css-1aq2sw4.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1aq2sw4{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1aq2sw4.Mui-disabled{opacity:0.38;pointer-events:none;}.css-1aq2sw4 .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-1aq2sw4 .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-1aq2sw4 .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-1aq2sw4 .MuiChip-icon{margin-left:5px;margin-right:-6px;color:#616161;}.css-1aq2sw4 .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-1aq2sw4 .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-1aq2sw4:hover{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-1aq2sw4:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);}.css-1aq2sw4.MuiChip-clickable:hover{background-color:rgba(0, 0, 0, 0.04);}.css-1aq2sw4.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.12);}.css-1aq2sw4 .MuiChip-avatar{margin-left:4px;}.css-1aq2sw4 .MuiChip-avatarSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-icon{margin-left:4px;}.css-1aq2sw4 .MuiChip-iconSmall{margin-left:2px;}.css-1aq2sw4 .MuiChip-deleteIcon{margin-right:5px;}.css-1aq2sw4 .MuiChip-deleteIconSmall{margin-right:3px;} cmake et d'ouvrir le dossier contenant le fichier CMakeLists.txt dans VSCode (il est recommand√© de cr√©er un dossier d√©di√© au &quot;projet&quot; contenant les fichiers sources et le fichier CMakeLists.txt ). L'extension devrait normalement reconna√Ætre automatiquement qu'il y a un fichier cmake et vous proposer d'initialiser celui-ci automatiquement.   Si c'est la premi√®re fois que vous l'ouvrez ce qui est s√ªrement le cas il devrait vous demander de choisir un kit de compilation et faudra donc s√©lectionner MSVC ou GCC en fonction de votre plateforme.  astuce Si ce n'est pas le cas vous pouvez toujours utiliser le raccourci Ctrl+Shift+P puis taper et s√©lectionner &quot;CMake: select a kit&quot; Une fois tout initialis√©, vous devriez voir des logs dans un terminal ressemblant √† cela (dans mon cas sous Linux avec le compilateur GCC ici): [variant] Loaded new set of variants [kit] Successfully loaded 1 kits from /home/user/.local/share/CMakeTools/cmake-tools-kits.json [proc] Executing command: /usr/bin/cmake --version [proc] Executing command: /usr/bin/gcc -v [proc] The command: ninja --version failed with error: Error: spawn ninja ENOENT [proc] The command: ninja-build --version failed with error: Error: spawn ninja-build ENOENT [proc] Executing command: /usr/bin/cmake &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [main] Configuring project: helloImac [proc] Executing command: /usr/bin/cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=/usr/bin/gcc -DCMAKE_CXX_COMPILER:FILEPATH=/usr/bin/g++ &quot;-S/home/user/DATA/Cours IMAC1/helloImac&quot; &quot;-B/home/user/DATA/Cours IMAC1/helloImac/build&quot; -G &quot;Unix Makefiles&quot; [cmake] Not searching for unused variables given on the command line. [cmake] -- Configuring done [cmake] -- Generating done [cmake] -- Build files have been written to: /home/user/DATA/Cours IMAC1/helloImac/build  Vous pouvez maintenant cliquer sur le bouton &quot;play&quot; dans la barre en bas pour ex√©cuter le programme. ü•≥ remarque En cliquant sur ce bouton, l'IDE compile automatiquement si n√©cessaire puis ex√©cute l'ex√©cutable.  remarque Cmake devrait normalement cr√©er un dossier build, c'est normal. CMake est un outil de compilation mais ne compile pas directement, il permet de g√©n√©rer des fichiers permettant ensuite de compiler un projet. Vous n'avez pas besoin d'aller voir ce qui s'y trouve, CMake g√®re automatiquement ce dossier build pour vous. attention Pour qu'un projet CMake soit fonctionnel, il faut que le dossier ouvert dans votre IDE contienne un fichier CMakeLists.txt √† la racine du dossier. Sinon, l'extension CMake ne d√©tectera pas le dossier ouvert comme un projet CMake et il ne va pas s'initialiser automatiquement. Les fonctionnalit√©s de l'extension ne seront donc pas disponibles. ","version":"Next","tagName":"h2"},{"title":"Quelques explications sur le programme‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#quelques-explications-sur-le-programme","content":"","version":"Next","tagName":"h2"},{"title":"include ?‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#include-","content":"#include &lt;iostream&gt;  Le but de notre programme est d‚Äôafficher un message. Des d√©veloppeurs experts ont d√©j√† cr√©√© un outil qui permet de le faire facilement. Il se trouve dans un fichier nomm√© iostream, acronyme de &quot;Input Output Stream&quot;, soit &quot;Flux d‚ÄôEntr√©es Sorties&quot;. Ce fichier fait partie de la biblioth√®que standard C++ STD (pour &quot;C++ STandarD library&quot;), un ensemble de fonctionnalit√©s d√©j√† pr√©-cod√©es et inclues partout avec chaque compilateur C++. Pour utiliser les fonctionnalit√©s offertes par ce fichier, notamment √©crire un message, on doit l‚Äôimporter dans notre programme. On dit qu‚Äôon l‚Äôinclut, d‚Äôo√π l‚Äôanglais &quot;include&quot;. Nous utiliserons beaucoup cette fonctionnalit√© en C++. info #include s'appelle une directive pr√©processeur. Le pr√©processeur est un programme ex√©cut√© lors de la premi√®re phase de la compilation qui effectue des modifications textuelles sur le fichier source √† partir de directives. Ces directives commencent par le caract√®re # et doivent se terminer par un saut de ligne. Retenez simplement que #include nous permet d‚Äôimporter des fichiers pour les inclure dans le programme que l'on est en train d'√©crire, et je le d√©taillerai plus tard dans le semestre. ","version":"Next","tagName":"h3"},{"title":"La fonction main‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#la-fonction-main","content":"int main() { // ... return 0; }  Lorsqu‚Äôon lance le programme, celui-ci doit savoir par o√π commencer. On parle de point d‚Äôentr√©e. Ce point d'entr√©e doit √™tre une fonction nomm√©e main et renvoyer une valeur avec le mot cl√© return. Nous reviendrons sur les fonctions dans un autre chapitre mais retenez que c'est un ensemble d'instructions d√©limit√© par des accolades { et }, et auquel on donne un nom (main dans ce cas).&quot; remarque La valeur de retour (de type int) du main indique si le programme s‚Äôest termin√© sans erreur. Si tout se passe bien, il faut retourner 0. N‚Äôimporte quelle autre valeur indique une erreur. ","version":"Next","tagName":"h3"},{"title":"Hello and welcome to IMAC !‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#hello-and-welcome-to-imac-","content":"L‚Äôinstruction ci-dessous permet d‚Äôafficher le texte (qu'on appelle &quot;cha√Æne de caract√®res&quot;, ou &quot;string&quot;, en programmation) &quot;Hello and welcome to IMAC !&quot; sur la sortie standard du programme. std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl;  Premi√®rement &quot;std&quot; fait r√©f√©rence √† la biblioth√®que standard C++ dont je parlais pr√©c√©demment. std:: permet d'indiquer que l'on veut utiliser une fonctionnalit√© particuli√®re de cette biblioth√®que ici cout: Il s‚Äôagit de l'objet (on parle de stream dans le jargon C++) permettant de renvoyer des caract√®res, g√©n√©ralement pour les afficher dans le terminal. Le 'c' fait r√©f√©rence √† caract√®re et ‚Äòout‚Äô indique ‚Äòsortie‚Äô. Enfin, std::endl indique ici &quot;end-line&quot; soit la 'fin de ligne'. ","version":"Next","tagName":"h3"},{"title":"Dernier point (virgule)‚Äã","type":1,"pageTitle":"Compiler votre premier programme","url":"/Learn--cpp_programming/Lessons/S1/Setup/HelloImac#dernier-point-virgule","content":"Chaque instruction doit √™tre identifiable afin de que compilateur puisse faire son travail et produire un programme ex√©cutable. C'est le r√¥le du point-virgule ; de d√©limiter chaque instruction et il est donc important de ne pas l'oublier. On le retrouve par exemple dans notre programme √† la fin du return 0;. attention Ce n'est pas le cas pour les directives pr√©processeur comme #include vu pr√©c√©demment qui, elles, doivent avoir leur propre ligne et ne doivent pas se terminer par un point-virgule ; mais un saut de ligne. Les sauts de lignes et espacements sont l√† pour am√©liorer la lisibilit√© mais pas pour le bon fonctionnement du compilateur en lui m√™me et on pourrait tr√®s bien √©crire: #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello and welcome to IMAC !&quot; &lt;&lt; std::endl; return 0; }  Je vous recommande tout de m√™me d'utiliser des espacements et sauts de ligne pour mieux s'y retrouver et c'est ce que je vais faire tout au long de ce cours.  Et voil√† ! Vous avez ex√©cut√© votre premier programme C++ √† l'aide de VSCode ! üéâ ","version":"Next","tagName":"h3"},{"title":"Structure: organiser nos donn√©es","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"D√©claration‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#d√©claration","content":"C'est en utilisant le mot-cl√© struct que l'on va cr√©er une nouvelle structure. La syntaxe de d√©claration est la suivante: struct nom { // liste des membres // type nom; // type nom; };  Cette structure est ensuite utilisable comme n'importe quel autre type de variable. Un exemple de d√©claration: struct People { std::string name; std::string lastName; unsigned int age; };  ","version":"Next","tagName":"h2"},{"title":"Initialisation‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#initialisation","content":"Pour initialiser une structure, il y a plusieurs fa√ßons de faire similaire √† la d√©claration des variables &quot;classiques&quot;. // Initialisation avec des valeurs (elles doivent √™tre ordonn√©es comme les membres de la structure) People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Syntaxe possible utilisant le signe = (comme en C) People people = { &quot;name&quot;, &quot;lastName&quot;, 42 };  remarque Lors de l'initialisation avec des valeurs, elles doivent √™tre ordonn√©es dans l‚Äôordre dans lequel elles sont d√©finies dans la structure. On ne peut pas donner juste un entier comme premi√®re valeur pour l'age dans notre cas. danger Ne pas initialiser une structure est un comportement ind√©termin√©. // Initialisation ind√©termin√©e People defaultPeople; Dans ce cas, il faut s'assurer de bien d√©finir les membres de la structure ensuite ! ","version":"Next","tagName":"h2"},{"title":"Utilisation‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#utilisation","content":"Pour manipuler un membre, c‚Äôest-√†-dire une variable appartenant √† la structure, il suffit d‚Äôutiliser la syntaxe structure.membre. #include &lt;iostream&gt; #include &lt;string&gt; struct People { std::string name; std::string lastName; unsigned int age; }; int main() { People people { &quot;name&quot;, &quot;lastName&quot;, 42 }; // Modification de l'age people.age = 19; // Lecture des membres std::cout &lt;&lt; &quot;My name is &quot; &lt;&lt; people.name &lt;&lt; &quot; &quot; &lt;&lt; people.lastName &lt;&lt; &quot; and i'm &quot; &lt;&lt; people.age &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h2"},{"title":"Passage par r√©f√©rence‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#passage-par-r√©f√©rence","content":"Une structure √©tant un agr√©gat de donn√©es (plus ou moins gros) il est int√©ressant d'utiliser des r√©f√©rences pour passer en param√®tres nos structures afin d'√©viter des copies. #include &lt;string&gt; #include &lt;iostream&gt; struct Product { std::string name; float price; unsigned int quantity; }; float GetTotalPrice(Product const&amp; product) { return product.price * product.quantity; } int main() { Product product { &quot;Tomatos&quot;, 0.32, 12 }; // Lecture des membres std::cout &lt;&lt; &quot;The total price for &quot; &lt;&lt; product.name &lt;&lt; &quot; is &quot; &lt;&lt; GetTotalPrice(product) &lt;&lt; &quot; ‚Ç¨.&quot; &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h2"},{"title":"Changer les valeurs par d√©faut‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#changer-les-valeurs-par-d√©faut","content":"Lors de l'initialisation, si il n'y a pas de valeur fournie entre accolades ({}) pour les membres de la structure, ils seront initialis√©s avec une valeur par d√©faut. Pour les types primitifs (comme int, float, double, char, bool, etc.) la valeur par d√©faut est z√©ro. Pour les objets (comme std::string, std::vector, etc.) la valeur par d√©faut est l'objet vide. Si une valeur est fournie en m√™me temps que la d√©claration d'un membre, c'est cette valeur qui sera utilis√©e lors de l'initialisation par d√©faut de la structure. un exemple #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name {&quot;unknown&quot;}; float price {0.f}; unsigned int quantity {1}; }; void Display(Product const&amp; product) { std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; product.name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Price: &quot; &lt;&lt; product.price &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Quantity: &quot; &lt;&lt; product.quantity &lt;&lt; std::endl; } int main() { Product unknownProduct; Display(unknownProduct); return 0; }  Name: unknown Price: 0 Quantity: 1  ","version":"Next","tagName":"h2"},{"title":"Des m√©thodes‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#des-m√©thodes","content":"Maintenant que nous avons nos propres structures cela va devenir int√©ressant d'utiliser des m√©thodes. En effet, dans mon exemple pr√©c√©dent j'ai cr√©√© des fonctions GetTotalPrice et Display. Mais j'aurais bien aim√© pouvoir faire : product.TotalPrice(). Autrement dit, cr√©er et utiliser une m√©thode TotalPrice() pour ma structure Product. Il suffit simplement de d√©clarer notre fonction au sein m√™me des accolades de notre structure comme cela: struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() { return price * quantity; } };  remarque Vous pouvez remarquer qu'ici je peux acc√©der aux membres de ma struct sans avoir √† faire struct.membre. En effet, la m√©thode a connaissance de la structure elle-m√™me et peut manipuler ses membres directement. ","version":"Next","tagName":"h2"},{"title":"Prototype de m√©thodes‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#prototype-de-m√©thodes","content":"Comme pour les fonctions, il est possible de d√©clarer seulement le prototype de la m√©thode et d'impl√©menter le corps de la m√©thode plus tard. Il y a juste un petit d√©tail en plus, il faut indiquer √† l'aide du nom de la structure et des caract√®res :: ,l'appartenance de la m√©thode √† la structure (comme avec std::). struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; }  remarque C'est une notion qui va √™tre utile quand on verra la s√©paration du code en plusieurs fichiers. ","version":"Next","tagName":"h3"},{"title":"M√©thode constante‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#m√©thode-constante","content":"Ici, il est aussi possible de pr√©ciser qu'une m√©thode ne modifie pas la structure, on parle de m√©thode constante. Il faut ajouter le mot-cl√© const √† la fin de la d√©claration de la m√©thode, avant le point virgule ;. struct Product { std::string name; float price; unsigned int quantity; float TotalPrice() const; }; float Product::TotalPrice() const { return price * quantity; }  C'est important car si on ne le fait pas on ne pourra pas appeler une m√©thode non constante d'une variable constante car celle-ci est susceptible de modifier la structure alors que c'est interdit par la variable constante. #include &lt;iostream&gt; #include &lt;string&gt; struct Product { std::string name; float price; unsigned int quantity; float TotalPrice(); }; float Product::TotalPrice() { return price * quantity; } int main() { Product const tomatos { &quot;Tomatos&quot;, 0.32, 12 }; // erreur ici: la variable tomatos est constante mais la m√©thode 'TotalPrice' ne l'est pas float tomatosPrice { tomatos.TotalPrice() }; return 0; }  Il faut donc indiquer que la m√©thode est constante: // le prototype float GetTotalPrice() const; // et la fonction float Product::GetTotalPrice() const { return price * quantity; }  ","version":"Next","tagName":"h3"},{"title":"Conflit de noms‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#conflit-de-noms","content":"Comme pour les fonctions, il est possible de passer des param√®tres √† notre m√©thode. Mais si le param√®tre a le m√™me nom qu'un des membres de la structure il y a un conflit de noms. struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float price) { price = price; } };  Ici la variable price manipul√©e dans la fonction n'est plus le membre mais le param√®tre, les param√®tres ont la priorit√© sur les membres de la structure. attention Sur certains compilateurs bien configur√©s on peut avoir des warnings : Warning g√©n√©r√© par clang Explicitly assigning value of variable of type 'float' to itself; did you mean to assign to member 'price'? Mais ce n'est pas toujours le cas. Avec un param√®tre constant on aurait g√©n√©r√© des erreurs de compilation et pas seulement un warning et c'est donc pr√©f√©rable pour mieux se rendre compte des erreurs. - Cannot assign to variable 'price' with const-qualified type 'const float' - assignment of read-only parameter 'price'  Pour √©viter la confusion, il est pr√©f√©rable d'utiliser le mot cl√© this suivi des caract√®res -&gt; devant le nom d'un membre de la structure comme cela: struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const price) { this-&gt;price = price; } };  Ici, plus de probl√®me, this-&gt;price fait r√©f√©rence √† notre membre et price est le param√®tre constant de la m√©thode. Une autre solution pr√©f√©rable et recommand√©e est de renommer le nom du param√®tre pour √©viter cette confusion: struct Product { std::string name; float price; unsigned int quantity; void ChangePrice(float const newPrice) { price = newPrice; // this-&gt;price = newPrice; } };  Vous √™tes libre de laisser ou non le this-&gt; pour indiquer plus explicitement l'utilisation du membre de la structure surtout si c'est plus compr√©hensible pour vous. Je ne rentre pas dans le d√©tail ici. Je reviendrai sur le fonctionnement du mot-cl√© this dans un autre chapitre. Retenez simplement ici que cela permet d'indiquer explicitement que l'on souhaite manipuler la structure. ","version":"Next","tagName":"h3"},{"title":"Aller plus loin: Forward Declaration‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#aller-plus-loin-forward-declaration","content":"Parfois deux structures ont besoin l'une de l'autre, on veut utiliser une struct A dans une struct B et inversement. Probl√®me, l'une est d√©finie avant l'autre et donc dans la premi√®re structure A il y a une erreur, B est encore inconnue. Pour r√©soudre ce probl√®me on va faire une d√©claration anticip√©e (Forward Declaration en anglais). Un peu √† la mani√®re d'un prototype on va indiquer que la structure existe, sans en d√©finir pr√©cis√©ment encore son contenu. #include &lt;vector&gt; // D√©claration anticip√©e de la structure Book struct Book; struct Author { std::string name; // Je peux donc l'utiliser ici std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); };  attention Cela ne permet pas de manipuler la structure vu que l'on ne sait pas encore ce qu'elle contient. De ce fait, les m√©thodes de la structure Author qui utilisent la structure Book doivent se trouver apr√®s la d√©claration compl√®te de la structure Book. Un exemple plus complet #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; struct Book; struct Author { std::string name; std::vector&lt;Book&gt; books; void Display(); void AddBook(std::string title); }; struct Book { std::string title; Author&amp; author; void Display(); }; void Author::Display() { std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; name &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Books: &quot; &lt;&lt; std::endl; for (Book const&amp; book : books) { std::cout &lt;&lt; &quot;\\t&quot; &lt;&lt; book.title &lt;&lt; std::endl; } } void Author::AddBook(std::string title) { // le &quot;*this&quot; permet de r√©cup√©rer une r√©f√©rence vers l'objet courant // Ce m√©canisme sera d√©taill√© dans un prochain chapitre Book book {title, *this}; // Ici une copie de l'objet book est faite dans le vecteur books.push_back(book); // La variable book va √™tre d√©truite √† la fin de la fonction // mais le vecteur books contient une copie de l'objet book donc pas de probl√®me } void Book::Display() { std::cout &lt;&lt; &quot;Title: &quot; &lt;&lt; title &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Author: &quot; &lt;&lt; author.name &lt;&lt; std::endl; } int main() { Author author {&quot;Jules Verne&quot;, {}}; author.AddBook(&quot;Vingt mille lieues sous les mers&quot;); author.Display(); return 0; }  ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"Structure: organiser nos donn√©es","url":"/Learn--cpp_programming/Lessons/S1/Struct#r√©sum√©","content":"Une structure est un agr√©gat de donn√©es, on la d√©clare avec le mot-cl√© struct. Les membres de la structure sont les variables qui la composent. On y acc√®de avec un point . apr√®s le nom de la variable. Une structure peut avoir des m√©thodes qui se d√©clarent comme pour les fonctions mais au sein m√™me des accolades de la structure. Le corps d'une m√©thode peut √™tre d√©clar√© plus tard (du moment que le prototype de la m√©thode est dans la structure). Il faut utiliser le nom de la structure suivi des caract√®res :: pour indiquer l'appartenance de la m√©thode √† la structure si elle est d√©clar√©e en dehors des accolades d√©limitant la structure. Une m√©thode peut √™tre constante pour indiquer qu'elle ne va pas modifier la structure. Il faut ajouter le mot-cl√© const apr√®s les param√®tres de la fonction et avant le point virgule ;. On peut utiliser le mot-cl√© this pour expliciter que l'on souhaite manipuler la structure et √©viter des conflits de nommages entre les membres et les param√®tres d'une m√©thode. ","version":"Next","tagName":"h2"},{"title":"Un monde de variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Les litt√©raux‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-litt√©raux","content":"Un litt√©ral est une valeur donn√©e explicitement dans le code. Il y a plusieurs types de litt√©raux en C++. ","version":"Next","tagName":"h2"},{"title":"Les caract√®res‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-caract√®res","content":"En effet, la phrase &quot;Hello and welcome to IMAC !&quot; pr√©c√©demment rencontr√©e repr√©sente simplement du texte. C'est ce qu'on appelle une cha√Æne de caract√®res. Qui dit cha√Æne de caract√®res dit caract√®res et il est √©galement possible de repr√©senter un unique caract√®re avec des guillemets simples '. #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'a' &lt;&lt; std::endl; std::cout &lt;&lt; '7' &lt;&lt; std::endl; std::cout &lt;&lt; '?' &lt;&lt; std::endl; return 0; }  #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 'H' &lt;&lt; 'e' &lt;&lt; 'l' &lt;&lt; 'l' &lt;&lt; 'o' &lt;&lt; ' ' &lt;&lt; 'I' &lt;&lt; 'M' &lt;&lt; 'A' &lt;&lt; 'C' &lt;&lt; '!' &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h3"},{"title":"Les cha√Ænes de caract√®res‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-cha√Ænes-de-caract√®res","content":"On pourrait simplement se contenter de caract√®res me direz vous mais c'est un peu fastidieux et les cha√Ænes de caract√®res sont donc l√† pour nous simplifier la vie. #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello IMAC!&quot; &lt;&lt; std::endl; return 0; }  remarque On diff√©rencie les caract√®res simples (utilisant des ') des chaines de caract√®res par les guillemets &quot;. Les caract√®res sp√©ciaux‚Äã Avez vous une id√©e de comment afficher des guillemets ? #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello &quot;IMAC&quot;!&quot; &lt;&lt; std::endl; return 0; }  Si j'essaie d'utiliser des guillemets cela ne compile pas comme dans l'exemple ci-dessus. En effet, les guillemets permettent d√©j√† de signaler le d√©but et la fin d'une cha√Æne de caract√®res. C'est √©galement le cas quand on essaye de repr√©senter un chemin de dossier au format Windows, par exemple, avec le chemin de fichier &quot;C:\\Program Files&quot; et on obtient une erreur du type warning: unknown escape sequence: '\\P'. Il existe en C++ des caract√®res dits sp√©ciaux, appel√©s s√©quences d‚Äô√©chappement. Le symbole \\ permet d'indiquer au compilateur d‚Äôafficher et non interpr√©ter ces caract√®res. Il faut donc pr√©fixer les guillemets du caract√®re \\ pour pouvoir les afficher: #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Hello \\&quot;IMAC\\&quot;!&quot; &lt;&lt; std::endl; return 0; }  Vous pouvez trouver tous les caract√®res d'√©chappement ici. Voil√† les plus utiles en pratique: \\' qui permet d‚Äôafficher un guillemet simple '\\&quot; qui permet d‚Äôafficher un guillemet double &quot;\\n qui permet d‚Äôaller √† la ligne, comme std::endl\\t qui permet de faire une tabulation horizontale\\\\ qui permet d‚Äôafficher un antislash \\ ","version":"Next","tagName":"h3"},{"title":"Les nombres‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-nombres","content":"On peut √©galement manipuler des nombres. #include &lt;iostream&gt; int main() { std::cout &lt;&lt; -1 &lt;&lt; std::endl; std::cout &lt;&lt; 0 &lt;&lt; std::endl; std::cout &lt;&lt; 42 &lt;&lt; std::endl; return 0; }  On les appelle nombres entiers mais il est aussi possible d'utiliser des nombres √† virgule, appel√©s flottants. #include &lt;iostream&gt; int main() { std::cout &lt;&lt; 3.141593 &lt;&lt; std::endl; std::cout &lt;&lt; -1.5 &lt;&lt; std::endl; return 0; }  info On remarque que l'on peut utiliser des nombres n√©gatifs sans aucun probl√®me. On y reviendra un peu plus tard. Concernant les nombres (entiers ou flottants) les op√©rateurs arithm√©tiques usuels sont utilisables: Op√©rateur\tDescription+\tAddition -\tSoustraction *\tMultiplication /\tDivision %\tModulo (reste de la division) #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Op√©rateurs arithm√©tiques :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Addition: 1 + 2 = &quot; &lt;&lt; 1 + 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Soustraction: 6 - 2 = &quot; &lt;&lt; 6 - 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Multiplication: 3.14 * 2 = &quot; &lt;&lt; 3.14 * 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Division: 42.5 / 3.2 = &quot; &lt;&lt; 42.5 / 3.2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Modulo: 7 % 3 = &quot; &lt;&lt; 7 % 3 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5 / 2 = &quot; &lt;&lt; 5 / 2 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;5. / 2 = &quot; &lt;&lt; 5. / 2 &lt;&lt; std::endl; return 0; }  C'est aussi vrai pour les r√®gles de distributivit√©, associativit√©, commutativit√© ou priorit√© des op√©rateurs, rien de bien √©tonnant me direz vous. #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Associativit√© :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 + (3 + 6) = &quot; &lt;&lt; 2 + (3 + 6) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;(2 + 3) + 6 = &quot; &lt;&lt; (2 + 3) + 6 &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Distributivit√© :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;2 * (4 + 3) = &quot; &lt;&lt; 2 * (4 + 3) &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Priorit√© des op√©rateurs :&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;42 * 3 + (2 + 8 / 4) = &quot; &lt;&lt; 42 * 3 + (2 + 8 / 4) &lt;&lt; std::endl; return 0; }  attention Ne remarquez vous pas quelque chose d'√©tonnant ? 5 / 2 et 5. / 2 ne donne pas la m√™me chose‚ÄØ? La raison est que pour le C++, si on fait une op√©ration sur deux nombres entiers, le r√©sultat doit rester un nombre entier. Si l‚Äôon veut que le r√©sultat soit un flottant, il faut qu‚Äôau moins un des deux nombres soit un flottant. C'est pour cela d'ailleurs que mon exemple 3.14 * 2 fonctionne bien car au moins un des deux nombres est un flottant et le r√©sultat est donc un flottant √©galement. Pour r√©sumer, toutes ces valeurs √©crites dans notre code s'appellent des litt√©raux. Les variables Les litt√©raux c'est sympa mais comment faire si l'on veut se resservir d'un r√©sultat pr√©c√©demment calcul√© ? C'est avec les variables que l'on va pouvoir faire √ßa ! C‚Äôest un concept commun √† beaucoup de langages de programmation qui permet de stocker une valeur et de lui associer un nom, afin de pouvoir l'identifier et la manipuler facilement. Nous ne rentrons pas dans le d√©tail de comment sont stock√©es ces valeurs dans la m√©moire de l'ordinateur car ce n'est pas le propos ici. ","version":"Next","tagName":"h3"},{"title":"Cr√©er une variable‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cr√©er-une-variable","content":"Pour d√©clarer une variable en C++, il faut trois choses: Pr√©ciser d'abord son type, qui indique ce que la variable va stocker (un entier, un flottant, une cha√Æne de caract√®res, etc)Un nom qui permet d'identifier la variableEnfin, la valeur √† stocker dans notre variable. Ceci se fait en mettant la valeur entre accolades {} #include &lt;iostream&gt; #include &lt;string&gt; int main() { int number { 42 }; char letter { 'A' }; float pi { 3.1415927f }; double pi_double { 1415926535897931 }; std::string text { &quot;Hello IMAC!&quot; }; return 0; }  Syntaxe h√©rit√©e Il existe √©galement une syntaxe alternative, de la forme type nom = valeur;. Essayez, vous verrez que √ßa marche. #include &lt;iostream&gt; int main() { int number { 42 }; std::cout &lt;&lt; number &lt;&lt; std::endl; return 0; } Cette syntaxe est h√©rit√©e du C et est toujours valable en C++. Dans ce cours je vous conseille fortement d'utiliser la syntaxe dite moderne utilisant les accolades {}. De plus la syntaxe avec le symbole = a d'autres subtilit√©s et peut parfois induire en erreur (des conversions implicites non desir√©es par exemple), c'est pourquoi nous ne l'utiliserons pas dans la majorit√© des cas. Ne soyez pas surpris si vous rencontrez cette syntaxe, elle est encore tr√®s utilis√©e et je l'ai moi m√™me utilis√© pendant tr√®s longtemps. ","version":"Next","tagName":"h2"},{"title":"Les types‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#les-types","content":"Dans l'exemple pr√©c√©dent j'ai utilis√© divers mots-cl√©s qui font chacun r√©f√©rence √† un type de variable sp√©cifique: Pour les nombres entiers c'est le mot-cl√© int, (abr√©viation de l‚Äôanglais integer signifiant nombre entier). Gr√¢ce √† ce type, on peut stocker des entiers n√©gatifs ou positifs.Pour les flottants(les nombres √† virgule), nous avons le mot-cl√© &quot;float&quot;, (abr√©viation de floating point numbers en anglais). Il existe aussi le mot cl√© &quot;double&quot; pour stocker des nombres √† virgule plus pr√©cis quand c'est n√©cessaire. remarque Il est recommand√© de faire la distinction entre float et double en ajoutant le suffixe f √† la fin du nombre: #include &lt;iostream&gt; int main() { float pi { 3.141592f }; double price { 4.14 }; return 0; } Pour l'instant √ßa n'a pas beaucoup d'importance mais essayez de le mettre car c'est une bonne pratique et a son importance avec des concepts plus avanc√©s en C++. Pour les caract√®res, nous avons char.Pour les cha√Ænes de caract√®res nous avons std::string. Cha√Æne de caract√®res Pour les cha√Ænes de caract√®res c'est l√©g√®rement diff√©rent, nous avons le type std::string. Ce type est particulier car il n‚Äôexiste pas nativement en C++. Pour ceux qui sont attentifs √† std:: c'est un type issu de la biblioth√®que standard dont j'ai d√©j√† parl√©. Ce sont des programmeurs experts qui ont cod√© ce type afin de manipuler ais√©ment des cha√Ænes de caract√®res. Afin de pouvoir manipuler des std::string, il faut donc inclure le bon fichier, ce que l‚Äôon fait gr√¢ce √† la ligne #include &lt;string&gt;. #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string hello { &quot;Hello IMAC!&quot; }; std::cout &lt;&lt; hello &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h2"},{"title":"Des pr√©fixes modificateurs‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-pr√©fixes-modificateurs","content":"Il est possible d'utiliser des mot-cl√©s modificateurs sur les entiers (type int) devant le type de la variable pour alt√©rer son fonctionnement (et implicitement la fa√ßon dont ils sont stock√©s en m√©moire). signed: permet d'indiquer que le nombre est sign√© (+ ou -) unsigned: permet d'indiquer que le nombre n'a pas de signe (une valeur absolue ou une taille) short: le nombre sera stock√© sur 16 bits minimum (dans le cas des petits nombres) long: le nombre sera stock√© sur 32 bits minimum (dans le cas de plus grands nombres) long long: le nombre sera stock√© sur 64 bits minimum remarque Ces pr√©fixes sont une indication pour le compilateur. Cela donne donc un minimum mais le compilateur est libre de choisir une repr√©sentation m√©moire s'il estime que c'est mieux ou plus adapt√© √† un ordinateur sp√©cifique. Pour garantir une taille tr√®s pr√©cise en m√©moire il existe depuis le C++11 des entiers de taille fix√©e (Fixed width integer types en anglais) disponible dans le fichier √† inclure &lt; cstdint &gt;. On retrouve donc par exemple int16_t pour un entier sur 16 bits ou uint32_t pour repr√©senter un entier non sign√© de 32 bits. Une liste exhaustive est disponible ici. C'est vraiment un usage tr√®s sp√©cifique et nous allons pas du tout nous en servir. ","version":"Next","tagName":"h2"},{"title":"Comportement ind√©termin√©‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#comportement-ind√©termin√©","content":"Mais qu'est ce qui se passe si je ne pr√©cise rien comme valeur pour ma variable (sans les accolades {}) ? int my_varaible;  C'est ce qu'on appelle un comportement ind√©termin√©, en anglais &quot;undefined behaviour&quot;. La variable se voit attribu√©e une valeur ind√©termin√©e. Cela peut √™tre 0 comme 142857, on ne peut pas le pr√©voir. C'est donc quelque chose qu'il faut absolument √©viter ! remarque Le compilateur l'autorise pour des questions d'optimisation et d'h√©ritage avec le C. Certains warnings de compilation indique ces erreurs. Il faut toujours initialiser ses variables. Valeur par d√©faut Si on ajoute les accolades mais sans pr√©ciser de valeur, notre variable va contenir une valeur par d√©faut. Ce sera par exemple une cha√Æne de caract√®res vide (&quot;&quot;) pour les std::string ou un 0 dans le cas d'un entier. Je vous laisse essayer: #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string default_string { }; std::cout &lt;&lt; default_string &lt;&lt; std::endl; // &quot;&quot; int default_int { }; std::cout &lt;&lt; default_int &lt;&lt; std::endl; // 0 float default_float { }; std::cout &lt;&lt; default_float &lt;&lt; std::endl; // 0.0f return 0; } Pour commencer, nous √©crirons toujours les valeurs explicitement pour √©viter de mauvaise surprise... Plus tard, avec un peu plus de pratique, vous aurez la libert√© d'utiliser l‚Äôinitialisation par d√©faut, en connaissance de cause. ","version":"Next","tagName":"h2"},{"title":"Quelques r√®gles de nommage‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-r√®gles-de-nommage","content":"Les noms des variables sont tout de m√™me soumis √† quelques r√®gles de nommage. Premi√®rement, de son origine am√©ricaine, le C++ n‚Äôautorise que les 26 lettres de l‚Äôalphabet anglais (plus les chiffres et l‚Äôunderscore _), on peut donc malheureusement dire adieu √† nos jolis accents fran√ßais. Les espaces et les signes de ponctuation sont aussi interdits (', ?, etc). Il ne peut pas commencer par un chiffre, c‚Äôest interdit. L'usage de l'underscore _ au d√©but, bien que possible, est conventionnellement utilis√© dans un cadre sp√©cifique et je vous d√©conseille donc de l'utiliser pour commencer. Enfin, il n'est pas possible d'utiliser un mot-cl√© du C++ comme nom de variable. Par exemple, il est interdit de d√©clarer une variable s‚Äôappelant int. Quelques exemples int main() { int variable42 { 42 }; int 42variable { 42 }; // Erreur : ne peut pas commencer par un chiffre. int my_variable { 0 }; int my variable { 0 }; // Erreur : espace interdit. float result { 2.71f }; float return { 2.71f }; // Erreur : mot-cl√© r√©serv√© par le C++ return 0; }  ","version":"Next","tagName":"h2"},{"title":"Un joli petit nom‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#un-joli-petit-nom","content":"Au-del√† des r√®gles de nommage, trouver un nom adapt√© √† une variable est un casse t√™te que m√™me les programmeurs exp√©riment√©s rencontrent. En effet, respecter les r√®gles ne suffit pas √† bien nommer une variable. Le nom d'une variable permet de l'identifier, de comprendre ce qu'elle stocke et comment on la manipule. remarque Le nom d'une variable est destin√© √† un lecteur humain. On choisit un nom de variable pour qu'il soit compr√©hensible pour nous et nos futurs lecteurs, amis, coll√®gues, etc Une fois le code compil√©, l'ordinateur ne fait aucune diff√©rence entre un nom ou un autre. ","version":"Next","tagName":"h3"},{"title":"Quelques mauvais exemples‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-mauvais-exemples","content":"lpi: Un acronyme ? Que signifie t'il ?value: Que stocke-t-elle‚ÄØ? Dans quel contexte‚ÄØ? Pourquoi existe-t-elle‚ÄØ?multiplication_of_two_by_sqrt_of_pi: Clair mais un peu trop long.dIsTanCe: Court et compr√©hensible mais les majuscules / minuscules peuvent rendre la lecture moins facile.qsqffqedfqzdjzqoid: S√ªrement un chat qui est pass√© sur mon clavier. Avec l'exp√©rience et le temps vous arriverez √† trouver plus facilement des noms clairs et simples. Je vous demande d√®s maintenant de faire quelques efforts pour r√©fl√©chir aux noms des variables. Cela peut vous sembler peu important, jusqu'au jour o√π vous perdrez une semaine de travail √† comprendre ce que votre programme ou variable est suppos√©e faire. ","version":"Next","tagName":"h3"},{"title":"Enum: Un type suppl√©mentaire‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#enum-un-type-suppl√©mentaire","content":"Vous allez s√ªrement le d√©couvrir en pratiquant mais parfois on souhaite stocker un nombre limit√© de possibilit√©s. Par exemple les points cardinaux (Nord, Sud, Est, Ouest), les saisons (√©t√©, printemps, automne, hiver), les jours de la semaine, etc On pourrait bien associer un entier √† chaque possibilit√© (c'est une pratique tr√®s r√©pandue en C) mais ce n'est pas la meilleure fa√ßon de faire. Un entier peut stocker des valeurs n√©gatives ou alors √™tre sup√©rieur au nombre de possibilit√©s voulues ce qui n'a pas vraiment de sens. C'est l√† qu'entre en jeu les enum (de l'anglais Enumeration). On le d√©clare en utilisant le pr√©fixe enum class puis le nom de notre √©num√©ration suivis des valeurs possibles entre accolades. Un exemple enum class Season { Spring, Summer, Autumn, Winter, }; int main() { Season current_season { Season::Spring }; return 0; }  remarque On utilise ici aussi la syntaxe avec :: pour signifier l'appartenance de la valeur √† l'enum (de la m√™me fa√ßon qu'avec la biblioth√®que standard comme avec std::string). attention Mais pourquoi le mot cl√© class ici ? Il est √©galement possible de l'omettre mais cette syntaxe est un autre &quot;type&quot; d'enum h√©rit√© du C qui a de nombreux inconv√©nients: Il n'est pas possible de d√©clarer deux enums utilisant la m√™me valeur (mais dans un contexte diff√©rent).D√©clarer une variable ayant le m√™me nom qu'une valeur d'un enum peut avoir des comportements impr√©vus. #include &lt;iostream&gt; enum PrimaryColor { Red, Yellow, Blue }; enum EyesColor { Brown, Hazel, Blue, // Erreur de compilation ici car la valeur Blue est aussi utilis√©e dans l'enum PrimaryColor Green, Grey, Amber }; int main() { // Ici Red fait r√©f√©rence √† la valeur dans l'enum PrimaryColor std::cout &lt;&lt; Red &lt;&lt; std::endl; int Red { 35 }; // Maintenant, bien que la ligne soit identique, Red fait r√©f√©rence √† la variable cr√©√©e ci-dessus std::cout &lt;&lt; Red &lt;&lt; std::endl; return 0; } On parle de &quot;Scoped enumerations&quot; avec enum class (autrement dit ayant une port√©e limit√©e pour √©viter les collisions de valeurs). Pour faire simple on √©crira syst√©matiquement enum class en C++ moderne pour s'√©viter des probl√®mes. ","version":"Next","tagName":"h2"},{"title":"Des op√©rateurs pour manipuler nos variables‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#des-op√©rateurs-pour-manipuler-nos-variables","content":"Il n'est pas seulement possible d'afficher nos variables (via std::cout), il est aussi possible de faire des op√©rations dessus. Pour cela nous allons utiliser des op√©rateurs. Les op√©rateurs sont des symboles qui permettent de manipuler des variables, c'est-√†-dire effectuer des op√©rations, les √©valuer, etc. Il y a principalement deux cat√©gories d'op√©rateurs: Les op√©rateurs binaires qui utilisent deux valeurs pour en produire une nouvelle (comme a + b par exemple)Les op√©rateurs unaires qui s'appliquent sur une valeur pour en produire une nouvelle. Nous avons par exemple vu pr√©c√©demment les op√©rateurs arithm√©tiques (+, -, *, / et %) sur les nombres. Ces op√©rateurs sont binaires. ","version":"Next","tagName":"h2"},{"title":"Op√©rateurs d'affectation‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#op√©rateurs-daffectation","content":"Pour attribuer une nouvelle valeur √† une variable, on utilise l‚Äôop√©rateur d‚Äôaffectation =, pr√©c√©d√© du nom de la variable et suivi de la valeur √† affecter‚ÄØ: nom = valeur;. #include &lt;iostream&gt; int main() { int x { 0 }; std::cout &lt;&lt; x &lt;&lt; std::endl; x = 3; std::cout &lt;&lt; x &lt;&lt; std::endl; return 0; }  C++ s'occupe en premier lieu de tout ce qui se trouve √† droite du signe =. On peut donc utiliser la valeur d'une variable pour faire un calcul avant de l'assigner √† cette m√™me variable.  Dans le cas o√π l'on veut effectuer une op√©ration sur une variable et assigner le r√©sultat √† cette m√™me variable il existe des op√©rateurs binaires nomm√©s op√©rateurs d'assignation compos√©s. On retrouve principalement ces op√©rateurs compos√©es avec les op√©rateurs arithm√©tiques: += , -= , *= , /= et %= int integer { 42 }; // √©quivalent √† √©crire &quot;integer = integer + 3&quot; integer += 3; integer -= 1; integer *= 4; integer /= 2; integer %= 2;  Il existe d'autres op√©rateurs d'affectation compos√©s mais nous les d√©couvrirons le moment venu. ","version":"Next","tagName":"h3"},{"title":"Op√©rateurs d'incr√©mentation‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#op√©rateurs-dincr√©mentation","content":"Cela va m√™me plus loin, il existe un raccourci suppl√©mentaire lorsque l'on souhaite ajouter ou soustraire 1 √† un nombre. On parle d'incr√©mentation et de d√©cr√©mentation. a++ ou ++a pour incr√©menter de 1 la valeur de la variable a.a-- ou --a pour d√©cr√©menter de 1 la valeur de la variable a. info Les deux syntaxes sont quasiment √©quivalentes, il y a une petite diff√©rence lorsque l'on souhaite utiliser le r√©sultat de l'incr√©mentation: On parle de Post-incr√©mentation avec a++: Cette forme signifie que la variable a est d'abord utilis√©e, puis elle est incr√©ment√©e de 1. Cela signifie que l'effet de l'incr√©mentation ne sera visible qu'apr√®s l'√©valuation de l'expression qui contient a++. int a { 5 }; int result { a++ }; // result prend la valeur de a (5) puis a est incr√©ment√© √† 6. // Maintenant, a vaut 6 et result vaut 5. On parle de Pr√©-incr√©mentation avec ++a: Cette forme signifie que la variable a est d'abord incr√©ment√©e, puis cette nouvelle valeur est utilis√©e. Cela signifie que l'effet de l'incr√©mentation sera visible imm√©diatement dans l'expression qui contient ++a. int a { 5 }; int result { ++a }; // a est incr√©ment√© √† 6, puis result prend la nouvelle valeur de a (6). // Maintenant, a et result valent tous les deux 6. En r√©sum√©, la seule diff√©rence entre les deux formes r√©side dans le moment o√π l'incr√©mentation est r√©alis√©e (avant ou apr√®s l'utilisation de sa valeur actuelle). Lorsque vous voulez r√©cup√©rer le r√©sultat de l'incr√©mentation, assurez-vous de choisir celle qui convient le mieux √† votre situation pour obtenir le comportement souhait√© dans votre programme. Dans la plupart des cas, je vous recommande tout simplement de ne pas l'utiliser! C'est une grosse source d‚Äôerreurs. Faites plut√¥t: int a { 5 }; a++; int result { a }; ou int a { 5 }; int result { a }; a++; Aussi, je recommandes m√™me d‚Äôutiliser a += 1 √† la place. Comme √ßa pas de surprise on est certain de ce qu‚Äôon fait. int a { 5 }; a += 1; int result { a };  ","version":"Next","tagName":"h3"},{"title":"Quelques exemples‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#quelques-exemples","content":"#include &lt;iostream&gt; int main() { int variable { 42 }; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je donne une nouvelle valeur √† ma variable variable = 2 + (3 * 9); std::cout &lt;&lt; variable &lt;&lt; std::endl; // J'utilise la valeur de ma variable pour un calcul et r√©affecte le r√©sultat √† la m√™me variable variable = variable + 7; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je me sers de ma variable pour en cr√©er une nouvelle int other_value { variable * 3 }; std::cout &lt;&lt; other_value &lt;&lt; std::endl; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux utiliser d'autres variables √©galement variable = other_value - 1; std::cout &lt;&lt; variable &lt;&lt; std::endl; // Je peux incr√©menter ma variable de deux fa√ßons variable += 1; variable++; std::cout &lt;&lt; variable &lt;&lt; std::endl; return 0; }  ","version":"Next","tagName":"h3"},{"title":"Variables constantes‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#variables-constantes","content":"Il existe enfin un dernier mot cl√© important, le mot cl√© const. Il va permettre, comme son nom l'indique, de rendre constant une variable et ainsi emp√™cher toute modification de celle-ci. Si l‚Äôon essaye de modifier une constante, on obtient une erreur de compilation. int main() { float const gravity { 9.80665f }; gravity = 9.0f; // Erreur de compilation return 0; }  Pour l'instant cela ne va pas √™tre tr√®s utile. Mais c'est une tr√®s (tr√®s (tr√®s)) bonne pratique et permet de prot√©ger des variables et donner des contraintes fortes √† notre code. Je vais l'utiliser r√©guli√®rement dans des exemples et on d√©couvrira ensemble plus tard o√π cela prendra vraiment toute son importance d'utiliser des const d√®s que possible. info Vous verrez souvent des codes qui inversent l‚Äôordre de const et √©crivent const float variable {};. C'est tout √† fait possible car le const respecte la r√®gle suivante : Il s‚Äôapplique √† ce qui est √† sa gauche, sauf s‚Äôil n‚Äôy a rien, auquel cas il s‚Äôapplique √† ce qu‚Äôil y a √† droite. Je vais le placer √† droite dans la suite de ce cours car c'est le fonctionnement voulu initialement du const. C'est une question de pr√©f√©rence et de lisibilit√©, vous √™tes libre de choisir ce que vous pr√©f√©rez. ","version":"Next","tagName":"h2"},{"title":"Entr√©e / Sortie‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#entr√©e--sortie","content":"Jusque l√†, nous avons r√©guli√®rement rencontr√© std::cout qui nous permet d'afficher des caract√®res. Il est √©galement possible de faire l'inverse en manipulant ce qu'on appelle une entr√©e. Gr√¢ce aux variables, il est possible de demander des informations √† l‚Äôutilisateur et de stocker cette information afin d'en faire quelque chose. #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;Entre ton age : &quot; &lt;&lt; std::endl; int age { 0 }; std::cin &gt;&gt; age; std::cout &lt;&lt; &quot;Tu as &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl; return 0; }  Ici std::cin est tr√®s similaire √† std::cout et signifie &quot;character input&quot;. Il faut le pr√©fixer par std::, car lui aussi appartient √† la biblioth√®que standard. De plus, on utilise ici les chevrons &gt;&gt; dans le sens inverse pour signifier que l'on &quot;ins√®re&quot;&quot; ce qui vient de notre entr√©e pour le stocker dans notre variable. attention Dans notre cas le C++ comprend que c'est un nombre et le convertit en entier (int). Mais que se passe t'il si l'on entre des lettres ? Dans ce cas de figure la variable (age ici) n'est pas modifi√©e. Mais pas seulement, std::cin n'arrive pas √† convertir notre entr√©e, il passe dans un √©tat invalide, m√©morise tous les caract√®res invalides et toutes les utilisations suivantes de std::cin seront √©rron√©es. Nous verrons plus tard comment g√©rer ce cas de figure et d√©tecter si une erreur survient. ","version":"Next","tagName":"h2"},{"title":"Cast‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#cast","content":"Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast. Il existe plusieurs types de cast dont le plus courant est le cast statique (static_cast). static_cast permet de convertir un type en un autre type. Par exemple, un int en float. C'est un cast s√ªr car il fait des v√©rifications. Il est √† utiliser par d√©faut pour les conversions de type. #include &lt;iostream&gt; int main() { int integer {42}; float floating {3.14f}; float floatingFromInteger {static_cast&lt;float&gt;(integer)}; int integerFromFloating {static_cast&lt;int&gt;(floating)}; std::cout &lt;&lt; &quot;integer: &quot; &lt;&lt; integer &lt;&lt; std::endl; std::cout &lt;&lt; &quot;floating: &quot; &lt;&lt; floating &lt;&lt; std::endl; // static_cast std::cout &lt;&lt; &quot;static_cast&lt;float&gt;(integer): &quot; &lt;&lt; floatingFromInteger &lt;&lt; std::endl; std::cout &lt;&lt; &quot;static_cast&lt;int&gt;(floating): &quot; &lt;&lt; integerFromFloating &lt;&lt; std::endl; return 0; }  integer: 42 floating: 3.14 static_cast&lt;float&gt;(integer): 42 static_cast&lt;int&gt;(floating): 3  remarque Il existe √©galement un cast h√©rit√© du C qui s'effectue avec des parenth√®ses ( ( ) ) autour du type vers lequel on veut caster devant la variable √† caster. int integer {42}; float floating {3.14f}; float floatingFromInteger {(float)integer}; int integerFromFloating {(int)floating}; Il est √† √©viter car il est dangereux et fonctionne de diff√©rentes mani√®res en fonction des cas sans v√©rifications et peut donc provoquer des erreurs ou comportements inattendus. ","version":"Next","tagName":"h2"},{"title":"En r√©sum√©‚Äã","type":1,"pageTitle":"Un monde de variables","url":"/Learn--cpp_programming/Lessons/S1/Variables#en-r√©sum√©","content":"Nous venons de d√©couvrir les variables en C++. C'est la base de tout programme informatique, ce qui permet d'√©changer et de manipuler des informations. C++ nous permet de manipuler diff√©rents types de donn√©es: des caract√®res simples (char)des cha√Ænes de caract√®res (via std::string)des nombres entiers (int)des nombres r√©els (float ou double)Des √©num√©rations (avec enum class) Il est possible d'utiliser toutes les op√©rations usuelles qui existent sur les nombres. Les variables nous permettent de stocker des valeurs et d'y associer un nom (en tenant compte de certaines r√®gles de nommage). Il est important de choisir un nom de variable qui a du sens et le plus simple possible. Il est possible de sp√©cifier qu'une variable est non modifiable avec le mot-cl√© const. On utilise des op√©rateurs pour manipuler nos variables. Il est possible de convertir un type en un autre type. C'est ce qu'on appelle un cast. Le plus courant est le cast statique (static_cast). Il fait des v√©rifications et est donc plus s√ªr. Il est √† utiliser par d√©faut pour les conversions de type. Nous pouvons demander des informations √† l‚Äôutilisateur gr√¢ce √† std::cin. ","version":"Next","tagName":"h2"},{"title":"S√©mantique et op√©rateurs","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Operators","content":"","keywords":"","version":"Next"},{"title":"Op√©rateurs‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs","content":"Les op√©rateurs sont des symboles qui permettent de manipuler des donn√©es. Par exemple, l'op√©rateur + permet d'additionner deux nombres entre eux. En C++, il est possible de d√©finir des op√©rateurs pour nos structures, c'est ce que l'on appelle la surcharge d'op√©rateurs. Cela permet ensuite d'utiliser l'op√©rateur sur nos structures sans devoir passer par une m√©thode. Pour d√©finir un op√©rateur, on utilise le mot cl√© operator suivi du symbole de l'op√©rateur. Par exemple, pour d√©finir l'op√©rateur +, on utilise operator+. Par exemple, on peut d√©finir un op√©rateur + pour notre structure Point qui permet d'additionner deux points entre eux. On peut ensuite utiliser cet op√©rateur sur nos structures comme si elles √©taient des nombres. struct Point { int x; int y; }; Point operator+(Point a, Point b) { return {a.x + b.x, a.y + b.y}; } int main() { Point a {1, 2}; Point b {3, 4}; Point c { a + b}; // c = {4, 6} }  ","version":"Next","tagName":"h2"},{"title":"√âgalit√©‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#√©galit√©","content":"Ce qui fait g√©n√©ralement sens pour une structure, c'est de pouvoir comparer deux instances de cette structure. Par exemple, on peut comparer deux points entre eux pour savoir s'ils sont √©gaux ou non. remarque D√®s que cela vous semble pertinent, c'est un indicateur qui permet de savoir si ont doit se &quot;limiter&quot; √† des m√©thodes ou si surcharger des op√©rateurs est pertinent. Pour √™tre en mesure de d√©finir l‚Äô√©galit√©, on doit respecter les conditions suivantes. Pour n'importe quel a, a == a doit √™tre vrai, c'est ce qu'on appelle la r√©flexivit√©.Pour n'importe quel a et b de m√™me type, si a == b est vrai, alors b == a doit √™tre vrai, c'est ce qu'on appelle la sym√©trie et la commutativit√©.Pour n'importe quel a, b et c de m√™me type, si a == b et b == c sont vrais, alors a == c doit √™tre vrai, c'est ce qu'on appelle la transitivit√©. Pour d√©finir l'op√©rateur d'√©galit√©, on utilise operator==. On peut ensuite utiliser cet op√©rateur sur nos structures de la m√™me fa√ßon que pour les types de base. struct Point { int x; int y; }; bool operator==(Point a, Point b) { return a.x == b.x &amp;&amp; a.y == b.y; } int main() { Point a {1, 2}; Point b {1, 2}; bool c { a == b}; // c = true }  ","version":"Next","tagName":"h2"},{"title":"Definition libre ou membre‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#definition-libre-ou-membre","content":"On peut d√©finir l'op√©rateur d'√©galit√© comme une fonction libre (en dehors de la d√©finition de la structure) ou comme une m√©thode membre. La diff√©rence est que dans le cas d'une m√©thode membre, le premier param√®tre est implicite et correspond √† l'instance sur laquelle on appelle la m√©thode. struct Point { int x; int y; bool operator==(Point b) { return x == b.x &amp;&amp; y == b.y; } };  Cela √† donc une influence sur la fa√ßon dont on utilise l'op√©rateur. Par exemple si l'on souhaite multiplier un point par un nombre, on peut d√©finir l'op√©rateur comme une m√©thode membre. struct Point { int x; int y; Point operator*(int a) { return {x * a, y * a}; } }; int main() { Point a {1, 2}; Point b { a * 2}; // b = {2, 4} }  Mais si l'on souhaite multiplier un nombre par un point, on ne peut pas d√©finir l'op√©rateur comme une m√©thode membre car le premier param√®tre est implicite et correspond √† l'instance sur laquelle on appelle la m√©thode. Il faut donc d√©finir l'op√©rateur comme une fonction libre. struct Point { int x; int y; }; Point operator*(int a, Point b) { return {a * b.x, a * b.y}; } int main() { Point a {1, 2}; Point b { 2 * a}; // b = {2, 4} }  Les deux syntaxes sont donc valables, mais il faut garder en t√™te que la syntaxe avec une m√©thode membre est plus limitante. ","version":"Next","tagName":"h3"},{"title":"R√©utilisation des op√©rateurs‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#r√©utilisation-des-op√©rateurs","content":"Je vous ai d√©j√† parl√© de l‚Äôint√©r√™t de la r√©utilisation avec les fonctions. C'est aussi valable pour les op√©rateurs. L‚Äôhabitude que beaucoup prennent est de d√©finir les op√©rateurs == et &lt;, puis de d√©finir les autres en fonction de ces deux-l√†. On va donc d√©finir l'op√©rateur != en fonction de == et l'op√©rateur &gt; en fonction de &lt;. struct Point { int x; int y; }; bool operator==(Point a, Point b) { return a.x == b.x &amp;&amp; a.y == b.y; } bool operator!=(Point a, Point b) { return !(a == b); } bool operator&lt;(Point a, Point b) { return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y); } bool operator&gt;(Point a, Point b) { return b &lt; a; }  ","version":"Next","tagName":"h2"},{"title":"Op√©rateurs d'assignation compos√©s‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs-dassignation-compos√©s","content":"Les op√©rateurs d'assignation compos√©s permettent de combiner une op√©ration et une assignation. Par exemple, l'op√©rateur += permet d'additionner une valeur √† une variable et de stocker le r√©sultat dans la variable. Il est aussi possible de d√©finir des op√©rateurs d'assignation compos√©s pour nos structures. Par exemple, on peut d√©finir l'op√©rateur += pour notre structure Point qui permet d'additionner un point √† un autre point et de stocker le r√©sultat dans le premier point. Cela fait sens dans ce cas de les d√©finir comme des m√©thodes membres. struct Point { int x; int y; Point&amp; operator+=(Point p) { x += p.x; y += p.y; return *this; } };  astuce L'expression *this peut sembler √©trange. this est un pointeur sur l'instance courante. *this est donc une r√©f√©rence sur l'instance courante. On retourne une r√©f√©rence sur l'instance courante pour pouvoir faire des op√©rations en cha√Æne. Par exemple, on peut √©crire a += b += c qui est √©quivalent √† a += (b += c). Cela nous permet d‚Äôavoir le m√™me comportement pour notre structure que s‚Äôil s‚Äôagissait d‚Äôun type natif comme int. ","version":"Next","tagName":"h2"},{"title":"Deux en un‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#deux-en-un","content":"Pour chaque op√©rateur d'assignation compos√©, il existe un op√©rateur binaire (prenant deux param√®tres) correspondant. Par exemple, l'op√©rateur += a pour op√©rateur binaire correspondant +. Dans un soucis de r√©utilisation, on peut d√©finir l'op√©rateur binaire en fonction de l'op√©rateur d'assignation compos√©. struct Point { int x; int y; Point&amp; operator+=(Point b) { x += b.x; y += b.y; return *this; } }; Point operator+(Point a, Point const&amp; b) { return a += b; }  On ici le principe de copie de param√®tre par valeur. Puisque le premier param√®tre est copi√©, on peut le modifier avec l‚Äôop√©rateur += sans risque modifier l'instance originale. On obtient donc l'op√©rateur binaire + en fonction de l'op√©rateur d'assignation compos√© +=. L'avantage est que si l'on doit modifier ou corriger le comportement le l'addition, on n'a pas besoin de modifier l'op√©rateur binaire + puisqu'il est d√©fini en fonction de l'op√©rateur d'assignation compos√© +=. ","version":"Next","tagName":"h3"},{"title":"Op√©rateurs de flux‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs-de-flux","content":"Les op√©rateurs de flux permettent de d√©finir comment afficher une structure ou la lire depuis un flux. Par exemple, on peut d√©finir l'op√©rateur &lt;&lt; pour notre structure Point qui permet d'afficher un point dans un flux. struct Point { int x; int y; }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point const&amp; p) { return os &lt;&lt; '(' &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; ')'; }  L'op√©rateur &lt;&lt; prend en premier param√®tre un flux de sortie (std::ostream&amp;) et en deuxi√®me param√®tre un point (Point const&amp;). Il retourne le flux de sortie pour pouvoir faire des op√©rations en cha√Æne. op√©rateur `&gt;&gt;` Il existe aussi l'op√©rateur &gt;&gt; qui permet de lire depuis un flux pour construire une structure. Il se d√©fini ainsi: std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Point&amp; p) { // gestion de la lecture is &gt;&gt; p.x &gt;&gt; p.y; if( /* Erreur, impossible de construire notre structure */ ) { is.setstate(std::ios::failbit); } return is; } notez que dans ce cas il faut signaler si l‚Äôentr√©e est invalide en mettant le flux dans un √©tat invalide avec std::ios::failbit, ce qui permet √† l‚Äôutilisateur de faire if (std::cin.fail()). Ces op√©rateurs s‚Äô√©crivent toujours sous la forme libre car leur premier argument est toujours un flux. ","version":"Next","tagName":"h2"},{"title":"Op√©rateurs d'affection par copie‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#op√©rateurs-daffection-par-copie","content":"Parfois, on a besoin de copier une structure. Pas seulement √† l'initialisation (dans ce cas l√† on peut utiliser la syntaxe d'initialisation {}), mais on a besoin d'affecter une nouvelle valeur √† une structure d√©j√† existante. Point const point { 3, 4 }; Point copie { 1, 1 }; // ... copie = point;  Pour faire cela il faut d√©finir l'op√©rateur d'affection par copie =. Cet op√©rateur est appel√© quand on affecte une valeur √† une structure d√©j√† existante.  struct Point { int x; int y; Point&amp; operator=(Point const&amp; b) { x = b.x; y = b.y; return *this; } };  ","version":"Next","tagName":"h2"},{"title":"Quelques bonnes pratiques‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#quelques-bonnes-pratiques","content":"Il est important de garder en t√™te que la surcharge d'op√©rateurs est une facilit√© et non une n√©cessit√©. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. IL est aussi important de respecter la s√©mantique des op√©rateurs. Par exemple, l'op√©rateur + doit faire une addition et non une soustraction. Si un op√©rateur a une s√©mantique d√©j√† d√©finie pour un domaine, tenez vous-y. Si la signification de l'op√©rateur n'est pas √©vidente et indiscutable, il faut √©viter de le surcharger. Il est pr√©f√©rable de d√©finir une m√©thode explicite dans les cas o√π la s√©mantique n'est pas √©vidente. Si pour une raison ou une autre, vous devez surcharger un op√©rateur qui n'a pas de s√©mantique √©vidente, il faut le commenter absolument. Enfin, certains op√©rateurs sont li√©s entre eux. Par exemple, si vous surchargez l'op√©rateur ==, il est conseill√© de surcharger l'op√©rateur != (en fonction de == si possible). De m√™me, si vous surchargez l'op√©rateur &lt;, les utilisateurs de votre structure s'attendront √† ce que les op√©rateurs &gt;, &lt;= et &gt;= soient d√©finis √©galement. ","version":"Next","tagName":"h2"},{"title":"D'autres op√©rateurs‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#dautres-op√©rateurs","content":"On peut aussi surcharger les op√©rateurs [] et () pour d√©finir un acc√®s √† un √©l√©ment de notre structure ou les op√©rateurs -- et ++ pour d√©finir un incr√©ment ou un d√©cr√©ment. Il existe de nombreux op√©rateurs que l'on peut surcharger mais le principe reste le m√™me. ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"S√©mantique et op√©rateurs","url":"/Learn--cpp_programming/Lessons/S2/Operators#r√©sum√©","content":"On peut d√©finir des op√©rateurs pour nos structures, c'est ce que l'on appelle la surcharge d'op√©rateurs.Pour d√©finir un op√©rateur, on utilise le mot cl√© operator suivi du symbole de l'op√©rateur. Par exemple, pour d√©finir l'op√©rateur +, on utilise operator+.Les op√©rateurs permettent de donner du sens √† nos structures et de les manipuler comme si elles √©taient des types de base. Cela donne de la s√©mantique √† nos structures.C'est int√©ressant de r√©utiliser les op√©rateurs entre eux. Par exemple, on peut d√©finir l'op√©rateur + en fonction de l'op√©rateur +=.L'expression *this permet de retourner une r√©f√©rence sur l'instance courante pour pouvoir faire des op√©rations en cha√Æne.Il est important de garder en t√™te que la surcharge d'op√©rateurs est une facilit√© et non une n√©cessit√©. Il faut donc l'utiliser avec parcimonie et quand cela fait sens pour notre structure. Parfois il est pr√©f√©rable de d√©finir une m√©thode avec un nom explicite.On peut surcharger les op√©rateurs de flux &lt;&lt; et &gt;&gt; pour d√©finir comment afficher une structure ou la lire depuis un flux.Vous trouverez la page de documentation sur la surcharge d'op√©rateurs ici. ","version":"Next","tagName":"h2"},{"title":"TD5 - Tableaux","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Arrays","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (min & max)‚Äã","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-1-min--max","content":"Des nains partent en exp√©dition dans les montagnes. Ils transportent chacun une certaine quantit√© de provisions (exprim√©e en calories). Votre mission est de d√©terminer la quantit√© de provisions la plus grande transport√©e par un nain. Je vous donne le programme suivant qui g√©n√®re la liste des calories transport√©es par chaque nain: #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstdlib&gt; int main() { size_t const dwarf_count = 20; std::vector&lt;int&gt; calories; // std::srand permet de fixer la &quot;seed&quot; du g√©n√©rateur al√©atoire (pour avoir des r√©sultats reproductibles) std::srand(42); for (int i = 0; i &lt; dwarf_count; ++i) { calories.push_back(rand() % 24000 + 100); } // affichage optionnel des calories transport√©es par chaque nain for (int const c : calories) { std::cout &lt;&lt; c &lt;&lt; &quot;, &quot;; } std::cout &lt;&lt; std::endl; // TODO: afficher la quantit√© de provisions la plus grande transport√©e par un nain return 0; }  Trouver la quantit√© de provisions la plus grande transport√©e par un nain. Trouver la quantit√© de provisions la plus petite transport√©e par un nain (arrivez vous √† le faire sans utiliser de boucle suppl√©mentaire ?). Essayez de faire fonctionner le programme avec plus de nains, par exemple 200, 2000 ou m√™me 20000 nains. (Attention, il ne faut pas afficher les calories transport√©es par chaque nain dans ce cas). Si vous avez eu besoin de changer autre chose que la variable dwarf_count pour r√©pondre √† la question pr√©c√©dente, essayez de trouver une solution qui fonctionne avec n'importe quel nombre de nains sans avoir √† modifier le code. Pour aller plus loin: Trouver les trois nains transportant le plus de provisions et afficher la somme des provisions transport√©es par ces trois nains. info Exercice inspir√© de de l'√©dition 2022 de l'advent of code: https://adventofcode.com/2022/day/1C'est un √©v√®nement annuel qui propose un probl√®me de code par jour sous forme de calendrier de l'avent. ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Luhn)‚Äã","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-2-luhn","content":"Le num√©ro de carte bancaire est un nombre de 16 chiffres. Il est compos√© de 4 groupes de 4 chiffres s√©par√©s par un espace. Tous les num√©ros de carte bancaire ne sont pas valides et il existe des algorithmes pour le v√©rifier. Cela permet de v√©rifier rapidement si un num√©ro de carte bancaire est valide ou non sans avoir √† contacter la banque et permet de d√©tecter rapidement certaines erreurs de saisie (comme l'inversion de deux chiffres par exemple).  L'algorithme de Luhn est l'un de ces algorithmes. Son principe est de calculer, √† partir d'un nombre (ou une suite de chiffres), une cl√© de contr√¥le (appel√©e checksum) qui permet de v√©rifier que le num√©ro est correct (car la cl√© est un nombre qui est d√©pendant des autres et doit respecter certaines conditions). Dans notre cas, la cl√© de contr√¥le est calcul√©e de la mani√®re suivante: On multiplie un chiffre sur deux par 2 (en commen√ßant par le deuxi√®me chiffre).Si le r√©sultat de la multiplication est sup√©rieur √† 9, on additionne les chiffres du r√©sultat (par exemple, 8 * 2 = 16, 1 + 6 = 7).On additionne tous les chiffres (y compris ceux qui n'ont pas √©t√© multipli√©s par 2). Si le r√©sultat (la cl√© de contr√¥le) est un multiple de 10, alors le num√©ro est valide. Un exemple Prenons le num√©ro de carte bancaire suivant: 1234 5678 9022 3456. On multiplie un chiffre sur deux par 2 (en commen√ßant par le dernier chiffre): 1 2 3 4 5 6 7 8 9 0 2 2 3 4 5 6 x2 x2 x2 x2 x2 x2 x2 x2 1 4 3 8 5 12 7 16 9 0 2 4 3 8 5 12 On additionne les chiffres du r√©sultat si le r√©sultat est sup√©rieur √† 9: 1 4 3 8 5 12 7 16 9 0 2 4 3 8 5 12 1 4 3 8 5 3 7 7 9 0 2 4 3 8 5 3 On additionne tous les chiffres: 1 4 3 8 5 3 7 7 9 0 2 4 3 8 5 3 1 + 4 + 3 + 8 + 5 + 3 + 7 + 7 + 9 + 0 + 2 + 4 + 3 + 8 + 5 + 3 = 70 La cl√© de contr√¥le est 70. 70 est un multiple de 10, donc le num√©ro de carte bancaire est valide. Vous devez √©crire un programme qui demande √† l'utilisateur de saisir un num√©ro de carte bancaire et qui affiche si ce num√©ro est valide ou non. Pour la saisie, vous √™tes libre de choisir le format ou syntaxe que vous voulez (via une cha√Æne de caract√®res, avec ou sans espaces, un nombre ou une boucle sur plusieurs chiffres). astuce Convertissez premi√®rement la cha√Æne de caract√®res en un tableau de chiffres.Pour convertir un caract√®re en un nombre, vous pouvez utiliser la fonction std::stoi (string to integer) ou la valeur ASCII du caract√®re. (voir l'Exercice 5 du TD2). ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Points d'√©nergie)‚Äã","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-3-points-d√©nergie","content":"Dans un jeu vid√©o de type RPG, d√®s que le joueur termine un niveau, il gagne des points d‚Äô√©nergie. Les points d'√©nergie sont calcul√©s en fonction du niveau termin√© et du nombre et du niveau de difficult√© des ennemis tu√©s. Le nombre de points d'√©nergie gagn√©s est calcul√© de la mani√®re suivante: Pour chaque ennemi tu√©, trouver tous les multiples de son niveau de difficult√© inf√©rieurs au niveau termin√© par le joueur.Combiner tous les multiples trouv√©s pour chaque ennemi tu√© en supprimant les doublons.Additionnez tous les nombres restants pour obtenir le nombre de points d'√©nergie gagn√©s. Voici un exemple: Le joueur termine le niveau 20.Il tue 2 ennemis de niveau 3, 5. Les multiples de 3 inf√©rieurs √† 20 sont: 3, 6, 9, 12, 15, 18. Les multiples de 5 inf√©rieurs √† 20 sont: 5, 10, 15. En supprimant les doublons, nous obtenons: 3, 5, 6, 9, 10, 12, 15, 18. En additionnant tous les nombres, nous obtenons 78 points d'√©nergie. Vous devez √©crire un programme qui demande √† l'utilisateur de saisir le niveau termin√© et le nombre et le niveau de difficult√© des ennemis tu√©s et qui affiche le nombre de points d'√©nergie gagn√©s. ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Palindrome)‚Äã","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-4-palindrome","content":"Un palindrome est un mot qui peut √™tre lu de la m√™me mani√®re de gauche √† droite et de droite √† gauche. Par exemple, kayak est un palindrome. √âcrire un programme qui demande √† l'utilisateur de saisir un mot et qui affiche si ce mot est un palindrome ou non. astuce Une cha√Æne de caract√®res est un tableau de caract√®res. ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Comptage)‚Äã","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-5-comptage","content":"√âcrire un programme qui demande un nombre entier positif (sup√©rieur √† 1 000 000) √† l'utilisateur et qui remplit un tableau avec les chiffres de ce nombre. Le programme doit ensuite compter le nombre d'occurrences de chiffre et afficher le chiffre qui appara√Æt le plus souvent. ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (Suppression et tassement)‚Äã","type":1,"pageTitle":"TD5 - Tableaux","url":"/Learn--cpp_programming/TDs/S1/Arrays#exercice-6-suppression-et-tassement","content":"√âcrire un programme qui demande √† l'utilisateur de saisir 10 entiers compris entre 0 et 5 et qui les stocke dans un tableau. (vous pouvez aussi demander √† l'utilisateur de saisir un nombre puis le d√©composer en chiffres et stocker les chiffres dans un tableau). Vous devez ensuite supprimer toutes les valeurs valant 3 dans le tableau en d√©calant tous les √©l√©ments vers la gauche et en compl√©tant le tableau avec des 0. Tableau avant: [1, 3, 2, 3, 3, 4, 5, 3, 0, 2]  Tableau apr√®s: [1, 2, 4, 5, 0, 2, 0, 0, 0, 0]  ","version":"Next","tagName":"h2"},{"title":"TD3 - Conditions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Conditions","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Positif ou n√©gatif)‚Äã","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-1-positif-ou-n√©gatif","content":"√âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier et aÔ¨Äiche si cet entier est positif ou n√©gatif. Exemples d‚Äôex√©cution: Saisir un entier : 42 42 est positif  Saisir un entier : -5 -5 est n√©gatif  ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Pair ou impair)‚Äã","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-2-pair-ou-impair","content":"√âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier et aÔ¨Äiche si cet entier est pair ou impair. astuce Vous pouvez utiliser l'op√©rateur modulo % qui donne le reste de la division enti√®re. ","version":"Next","tagName":"h2"},{"title":"Exercice 3‚Äã","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-3","content":"√âcrire un programme qui demande √† l‚Äôutilisateur de saisir son √¢ge (un nombre entier) et aÔ¨Äiche s‚Äôil est majeur ou mineur. G√©rer la saisie d'un √¢ge √† stocker dans une variable.G√©rer le cas o√π l‚Äôutilisateur saisit un √¢ge n√©gatif et afficher un message d‚Äôerreur dans ce cas.G√©rer le cas o√π l‚Äôutilisateur saisit un √¢ge avec des lettres et afficher et g√©rer l‚Äôerreur. info std::cin &gt;&gt; x renvoie true si tout est correct ou false si on a rencontr√© une erreur lors de la saisie. Dans notre cas, si l'utilisateur saisit un √¢ge avec des lettres, la saisie √©choue et la variable √¢ge n'est pas modifi√©e. Il est aussi possible de tester si la saisie pr√©c√©dente a √©chou√© avec std::cin.fail() qui renvoie true si la saisie a √©chou√© et false sinon. std::cin.fail() √©quivaut √† !(std::cin &gt;&gt; x). Dans le cas o√π la saisie a √©chou√©, il faut r√©initialiser la saisie de l'utilisateur pour pouvoir saisir √† nouveau un √¢ge. std::cin.clear() restaure std::cin √† un √©tat fonctionnel, sans erreur.std::cin.ignore() permet d‚Äôignorer un nombre d√©fini de caract√®res, soit jusqu‚Äô√† un nombre maximum (exemple 500), soit jusqu‚Äô√† un caract√®re pr√©cis (exemple '\\n' ou 'a'). Dans notre cas, nous allons utiliser ceci‚ÄØpour r√©initialiser la saisie de l'utilisateur si on a rencontr√© une erreur. std::cin.clear(); // On remet std::cin dans un √©tat fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caract√®res m√©moris√©s.  ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Soldes)‚Äã","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-4-soldes","content":"C'est les soldes ! Cr√©er un programme qui demande √† l'utilisateur: le type de produit (√† stocker dans un enum)le prix du produit (un nombre flottant)s'il a une carte de fid√©lit√© (boolean)son age (un nombre entier) En fonction des informations saisies, le programme affiche le prix final apr√®s r√©duction. Vous disposez des informations suivantes: Type d'article\tR√©duction\tR√©duction avec carte de fid√©lit√©Alimentation\t5%\t8% V√™tements\t10%\t15% Chaussures\t12%\t18% Autre\t0%\t0% S'il √† moins de 26 ans, il a 10% de r√©duction suppl√©mentaire sur tous les articles apr√®s r√©duction. Je vous fourni le code suivant pour l'√©num√©ration et la gestion de la saisie de l'utilisateur: enum class Article { Alimentation, Vetements, Chaussures, Autre }; // C'est un m√©canisme avanc√©, vous n'avez pas besoin de comprendre comment √ßa marche. // On en reparlera au second semestre. // retenez juste que √ßa permet de convertir une entr√©e de l'utilisateur en Article. std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; }  Cela nous permet d'utiliser l'op√©rateur &gt;&gt; pour lire un enum comme on pourrait le faire avec un int ou un float. Sans cela, on aurait du utiliser une variable interm√©diaire de type string ou int pour stocker la saisie de l'utilisateur et faire la conversion nous m√™me. Exemple de saisie d'un enum #include &lt;iostream&gt; enum class Article { Alimentation, Vetements, Chaussures, Autre }; std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Article&amp; article) { std::string articleAsString; is &gt;&gt; articleAsString; if (articleAsString == &quot;Alimentation&quot;) { article = Article::Alimentation; } else if (articleAsString == &quot;Vetements&quot;) { article = Article::Vetements; } else if (articleAsString == &quot;Chaussures&quot;) { article = Article::Chaussures; } else if (articleAsString == &quot;Autre&quot;) { article = Article::Autre; } else { is.setstate(std::ios::failbit); } return is; } int main() { Article article; std::cin &gt;&gt; article; // On v√©rifie si la saisie a √©chou√©. if (std::cin.fail()) { std::cout &lt;&lt; &quot;Erreur de saisie, il faut saisir un type d'article valide (\\&quot;Alimentation\\&quot;, \\&quot;Vetements\\&quot;, \\&quot;Chaussures\\&quot; ou \\&quot;Autre\\&quot;)&quot; &lt;&lt; std::endl; std::cin.clear(); // On remet std::cin dans un √©tat fonctionnel. std::cin.ignore(255, '\\n'); // On vide les caract√®res m√©moris√©s. // le programme s'arr√™te si on a rencontr√© une erreur de saisie et renvoie 1 pour indiquer une erreur. return 1; } if (article == Article::Alimentation) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Alimentation&quot; &lt;&lt; std::endl; } else if (article == Article::Vetements) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Vetements&quot; &lt;&lt; std::endl; } else if (article == Article::Chaussures) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Chaussures&quot; &lt;&lt; std::endl; } else if (article == Article::Autre) { std::cout &lt;&lt; &quot;Vous avez saisi un article de type Autre&quot; &lt;&lt; std::endl; } return 0; }  Demander √† l'utilisateur de saisir le type d'article, le prix, s'il a une carte de fid√©lit√© et son √¢ge. G√©rer les cas o√π l'utilisateur saisit des informations incorrectes (enum incorrect, prix ou √¢ge n√©gatif, etc.) et afficher un message d'erreur dans ce cas. Vous pouvez reprendre mon exemple de saisie d'un enum. Calculer le prix final en fonction des informations saisies et afficher le r√©sultat. L'enseigne offre √©galement un bon d'achat de 10% du montant total du ticket de caisse, √† valoir sur un prochain achat. Le bon d'achat ne peut pas √™tre sup√©rieur √† 30‚Ç¨. Calculer le montant du bon d'achat et l'afficher en fin de programme. ","version":"Next","tagName":"h2"},{"title":"Exercice 5‚Äã","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-5","content":"Calcul du temps d'√©bullition de l'eau en fonction de l'altitude en m√®tres (un nombre entier), de la temp√©rature ambiante (un nombre flottant) et de l'ajout ou non de sel (boolean). Vous disposez des informations suivantes: A 0 m√®tre d'altitude, l'eau bout √† 100¬∞C.Tout les 300 m√®tres d'altitude suppl√©mentaires, l'eau atteint son point d'√©bullition 1¬∞C plus bas.L'action d'ajouter du sel dans l'eau fait augmenter son point d'√©bullition de 1.5¬∞C.Il faut 1 min pour que l'eau gagne 10¬∞C de temp√©rature.La temp√©rature de l'eau initiale est la temp√©rature ambiante. Demander √† l'utilisateur de saisir l'altitude, la temp√©rature ambiante et s'il ajoute du sel.G√©rer le cas o√π l'utilisateur saisit une altitude n√©gative et afficher un message d'erreur.En fonction des informations saisies, afficher le temps d'√©bullition de l'eau en minutes. ","version":"Next","tagName":"h2"},{"title":"Exercice 6‚Äã","type":1,"pageTitle":"TD3 - Conditions","url":"/Learn--cpp_programming/TDs/S1/Conditions#exercice-6","content":"Essayer de refaire les exercices 1 et 2 en utilisant des ternaires. remarque Un ternaire est une expression conditionnelle qui permet de faire un test comme un if/else et de retourner une valeur en fonction du r√©sultat du test. int a {5}; int b {10}; // condition ? valeur si vrai : valeur si faux int c {(a &gt; b) ? a : b }; // c = 10 C'est r√©serv√© aux cas simples qui peuvent s'√©crire sur une seule ligne. Il ne faut pas abuser des ternaires car cela peut rendre le code illisible. ","version":"Next","tagName":"h2"},{"title":"algorithmes de tri, complexit√© et recherche dichotomique","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/Lessons/S2/Sorting","content":"","keywords":"","version":"Next"},{"title":"Tri par s√©lection‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-s√©lection","content":"L'algorithme de tri par s√©lection est un algorithme de tri qui consiste √† trouver le plus petit √©l√©ment du tableau, et √† le placer en premi√®re position (ou le plus grand √©l√©ment en derni√®re position). On r√©p√®te cette op√©ration jusqu'√† ce que le tableau soit tri√©. Un exemple, avec le m√™me tableau [6, 2, 8, 1, 5, 3, 9]: On, parcourt le tableau pour trouver le plus petit √©l√©ment, qui est 1. son indice est 3, on l'√©change avec l'√©l√©ment √† l'indice 0 (le premier √©l√©ment du tableau). 2\t8\t1\t5\t3\t9\t6 le premier √©l√©ment du tableau est d√©sormais le plus petit √©l√©ment du tableau. On recommence l'op√©ration, mais en ignorant le premier √©l√©ment du tableau, car il est d√©j√† tri√©. info Toute l'astuce de cet algorithme est donc de trier un sous-tableau plus petit √† chaque it√©ration jusqu'√† ce que le tableau soit tri√©. Voil√† les it√©rations suivantes: 1\t8\t2\t5\t3\t9\t6 1\t2\t8\t5\t3\t9\t6 1\t2\t3\t5\t8\t9\t6 A cette √©tape, l'√©l√©ment √† l'indice 4 est d√©j√† le plus petit (des √©l√©ments non tri√©s), donc on ne fait rien. 1\t2\t3\t5\t6\t9\t8 1\t2\t3\t5\t6\t8\t9 Voil√†, le tableau est tri√©. ","version":"Next","tagName":"h2"},{"title":"Tri √† bulles (bubble sort)‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-√†-bulles-bubble-sort","content":"Le tri √† bulles est un autre algorithme de tri tr√®s connu. Il consiste √† comparer deux √† deux les √©l√©ments du tableau, et √† les √©changer si ils ne sont pas dans le bon ordre. On r√©p√®te cette op√©ration jusqu'√† ce que le tableau soit tri√©. remarque Cela va avoir pour effet de faire &quot;remont√©&quot; les plus grands √©l√©ments du tableau vers la fin du tableau, comme des bulles d'air qui remontent √† la surface. Un exemple, avec le m√™me tableau [6, 2, 8, 1, 5, 3, 9]: On compare les deux premiers √©l√©ments du tableau, 6 et 2. Comme 6 est plus grand que 2, on les √©change. 2\t6\t8\t1\t5\t3\t9 On recommence l'op√©ration avec les deux √©l√©ments suivants, 6 et 8. Comme 6 est plus petit que 8, on ne fait rien. On proc√®de ainsi jusqu'√† la fin du tableau. On obtient apr√®s un premier passage sur l'ensemble du tableau: 2\t6\t1\t5\t3\t8\t9 On recommence l'op√©ration, mais en ignorant le dernier √©l√©ment du tableau, car il est d√©j√† tri√©. Voil√† les it√©rations suivantes: 2\t1\t5\t3\t6\t8\t9 1\t2\t3\t5\t6\t8\t9 Dernier passage, aucun √©change n'est effectu√©. Le tableau est tri√©. ","version":"Next","tagName":"h2"},{"title":"Parlons un peu de complexit√©‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#parlons-un-peu-de-complexit√©","content":"La complexit√© d'un algorithme est une mesure de la quantit√© de ressources (temps, m√©moire, etc) que celui-ci va utiliser pour s'ex√©cuter. En g√©n√©ral, on s'int√©resse √† la complexit√© en fonction de la taille des donn√©es en entr√©e de l'algorithme. Il existe plusieurs types de complexit√©, la plus souvent utilis√©e est la complexit√© en temps. Cela revient √† se poser la question: Si je donne √† mon programme une entr√©e de taille N, quel est l'ordre de grandeur, en fonction de N, du nombre d'op√©rations qu'il va effectuer ? remarque La complexit√© permet de quantifier la relation entre les conditions de d√©part et le temps effectu√© par l'algorithme. ","version":"Next","tagName":"h2"},{"title":"Op√©rations de base‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#op√©rations-de-base","content":"Pour &quot;compter les op√©rations&quot;, il faut d√©cider de ce qu'est une op√©ration. Ce choix d√©pend du probl√®me (et m√™me de l'algorithme) consid√©r√©. Il faut en fait choisir soi-m√™me quelques petites op√©rations que l'algorithme effectue souvent, et que l'on veut utiliser comme op√©rations de base pour mesurer la complexit√©. Les op√©rations qui caract√©rise le mieux l'algorithme et repr√©sente le mieux le temps d'ex√©cution de celui-ci. Les op√©ration de base sont souvent les op√©rations arithm√©tiques, les comparaisons, les affectations, etc. Par exemple, pour un algorithme de tri, on va compter le nombre de comparaisons et d'√©changes d'√©l√©ments du tableau. En fonction des algorithmes, certaines op√©rations peuvent √™tre plus significatives que d'autres. Par exemple, la multiplication est plus co√ªteuse que l'addition, on peut donc ne consid√©rer que les op√©rations de multiplication pour mesurer la complexit√© d'un algorithme. info On ne compte pas les op√©rations qui ne d√©pendent pas de la taille des donn√©es en entr√©e (comme l'initialisation de variables, etc). Ces op√©rations sont consid√©r√©es comme constantes et pas significatives pour la complexit√© en fonction de la taille des donn√©es en entr√©e. ","version":"Next","tagName":"h3"},{"title":"Notation \"grand O\"‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#notation-grand-o","content":"On exprime la complexit√© en fonction de la taille des donn√©es en entr√©e avec la notation &quot;grand O&quot;. La notation &quot;grand O&quot; est une notion math√©matique qui permet d'exprimer un ordre de grandeur. Par exemple, des algorithmes effectuant environ NNN op√©rations, 2N+202N+202N+20 op√©rations ou N/2N/2N/2 op√©rations ont tous la m√™me complexit√© : on la note O(N)O(N)O(N) (lire &quot;grand O de N&quot;). De m√™me, un algorithme en 3N2+4N+23N2 + 4N + 23N2+4N+2 op√©rations aura une complexit√© de O(N2)O(N2)O(N2) : on n√©glige les termes de plus faible degr√© (ici 4N4N4N et 222) et les coefficients (ici 333). On cherche seulement √† savoir comment √©volue le nombre d'op√©rations en fonction de la taille des donn√©es en entr√©e et on consid√®re le terme de plus haut degr√© qui est celui qui va cro√Ætre le plus vite en fonction de la taille des donn√©es en entr√©e. ","version":"Next","tagName":"h3"},{"title":"Tri par s√©lection‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-s√©lection-1","content":"Prenons l'exemple du tri par s√©lection. Pour trier un tableau de taille nnn, premi√®rement on parcourt le tableau pour trouver le plus petit √©l√©ment, on va donc effectuer nnn comparaisons. Ensuite, on va √©changer cet √©l√©ment avec le premier √©l√©ment du tableau, on va donc effectuer 111 √©change. Ensuite on va recommencer l'op√©ration, mais en ignorant le premier √©l√©ment du tableau, car il est d√©j√† tri√©. On va donc effectuer n‚àí1n-1n‚àí1 comparaisons et 111 √©change. On va faire cela jusqu'√† ce que le tableau soit tri√©, donc jusqu'√† ce qu'il ne reste plus qu'un seul √©l√©ment √† trier. Pour r√©sumer, on va effectuer pour les diff√©rentes it√©rations: nnn comparaisons et 111 √©changen‚àí1n-1n‚àí1 comparaisons et 111 √©changen‚àí2n-2n‚àí2 comparaisons et 111 √©change...111 comparaison et 111 √©change On peut donc calculer le nombre total de comparaisons et d'√©changes effectu√©s par l'algorithme: =(n+1)+((n‚àí1)+1)+((n‚àí2)+1)+...+(1+1)=(n+(n‚àí1)+‚ãØ+1)+(1+‚ãØ+1)=n(n+1)2+n=n2+3n2\\begin{align*} = &amp; (n+1) + ((n-1)+1) + ((n-2)+1) + ... + (1+1) \\\\ = &amp; (n + (n-1) + \\dots + 1) + (1 + \\dots + 1) \\\\ = &amp; \\frac{n(n+1)}{2} + n \\\\ = &amp; \\frac{n^2 + 3n}{2} \\\\ \\end{align*}====‚Äã(n+1)+((n‚àí1)+1)+((n‚àí2)+1)+...+(1+1)(n+(n‚àí1)+‚ãØ+1)+(1+‚ãØ+1)2n(n+1)‚Äã+n2n2+3n‚Äã‚Äã Ici, j'ai compt√© de mani√®re exacte le nombre d'op√©rations effectu√©es par l'algorithme, mais en g√©n√©ral on s'int√©resse √† la complexit√© en fonction de la taille des donn√©es en entr√©e. On va donc garder uniquement le terme de plus haut degr√©, ici n2n^2n2. On dit que la complexit√© du tri par s√©lection est en O(n2)O(n^2)O(n2). info On peux aussi √©valuer cette complexit√© sans calcul exact, mais plut√¥t en estimant le nombre d'op√©rations effectu√©es par l'algorithme. On peut voir que l'algorithme doit √† chaque it√©ration parcourir le tableau, c'est ce qui va prendre le plus de temps et d√©pendra de la taille du tableau. Chaque it√©ration va permettre de trier un √©l√©ment du tableau, donc on va effectuer nnn it√©rations. On peut donc estimer que la complexit√© du tri par s√©lection est en O(n√ón)=O(n2)O(n \\times n) = O(n^2)O(n√ón)=O(n2). ","version":"Next","tagName":"h3"},{"title":"Complexit√© dans le pire des cas‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexit√©-dans-le-pire-des-cas","content":"Le nombre d'op√©rations effectu√©es par un algorithme peut d√©pendre de la taille des donn√©es en entr√©e, mais aussi des donn√©es elles-m√™mes. Par exemple, dans le cadre d'un tri √† bulles, si le tableau est d√©j√† tri√©, on n'effectuera aucune op√©ration d'√©change, et seulement nnn comparaisons. On peut donc dire que la complexit√© du tri √† bulles est en O(n)O(n)O(n) dans le meilleur des cas. Mais si le tableau est tri√© dans l'ordre inverse, on va effectuer nnn comparaisons et nnn √©changes √† chaque it√©ration, et on va effectuer nnn it√©rations. On peut donc dire que la complexit√© du tri √† bulles est en O(n√ón)=O(n2)O(n \\times n) = O(n^2)O(n√ón)=O(n2) dans le pire des cas. remarque C'est int√©ressant de s'int√©resser √† la complexit√© dans le pire des cas, car elle permet de savoir si l'algorithme est efficace pour toutes les donn√©es possibles. l‚Äôint√©r√™t de consid√©rer le pire des cas vient du fait que pour des donn√©es quelconques, on ne peut pas savoir si elles sont favorables ou non √† l'algorithme et c'est en g√©n√©ral assez proche du comportement dans le pire des cas. ","version":"Next","tagName":"h3"},{"title":"Complexit√© en moyenne‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexit√©-en-moyenne","content":"On peut aussi s'int√©resser √† la complexit√© en moyenne, c'est-√†-dire la complexit√© sur toutes les donn√©es possibles. Par exemple, pour le tri √† bulles, on peut montrer que la complexit√© en moyenne est en O(n2)O(n^2)O(n2). Il existe des algorithmes qui ont une complexit√© en moyenne bien meilleure que leur complexit√© dans le pire des cas. Cela d√©pend du probl√®me consid√©r√© et demande une analyse plus fine de l'algorithme. ","version":"Next","tagName":"h3"},{"title":"Complexit√© en m√©moire‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#complexit√©-en-m√©moire","content":"On peut aussi s'int√©resser √† la complexit√© en m√©moire d'un algorithme. Autrement dit, combien de m√©moire va utiliser l'algorithme en fonction de la taille des donn√©es en entr√©e. C'est aussi une mesure de la complexit√© tout aussi pertinente que la complexit√© en temps. Si par exemple on a besoin de trier un tableau de 1000 √©l√©ments, on peut se dire que la complexit√© en temps n'est pas tr√®s importante, car l'algorithme va s'ex√©cuter tr√®s rapidement. Mais si l'algorithme utilise beaucoup de m√©moire, cela peut poser probl√®me, car on peut ne pas avoir assez de m√©moire disponible pour ex√©cuter l'algorithme. Dans la plupart des cas, la complexit√© en m√©moire est beaucoup plus simple √† calculer que la complexit√© en temps. Mais dans des probl√®mes plus compliqu√©s, la complexit√© en m√©moire et la complexit√© en temps peuvent √™tre li√©es. On peut par exemple choisir de sacrifier un peu de rapidit√© d'ex√©cution pour utiliser moins de m√©moire, ou au contraire d'augmenter la vitesse en augmentant la complexit√© en m√©moire de notre algorithme, par exemple en stockant dans un tableau les r√©sultats d√©j√† calcul√©s (c'est le principe de la mise en cache, appel√©e aussi memoization). ","version":"Next","tagName":"h3"},{"title":"Limitation de la complexit√©‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#limitation-de-la-complexit√©","content":"La complexit√© d'un algorithme est donc une mesure d'ordre de grandeur en fonction de la taille des donn√©es en entr√©e. Cependant, il est important de garder √† l'esprit que la complexit√© ne permet pas de savoir si un algorithme est rapide ou lent. M√™me si un algorithme √† une complexit√© plus faible qu'un autre, il peut √™tre plus (beaucoup plus) lent √† s'ex√©cuter qu'un autre algorithme pour des tailles de donn√©es en entr√©e faibles. attention La complexit√© permet de comparer des algorithmes entre eux, donner une tendance en fonction de l'augmentation la taille des donn√©es en entr√©e, mais ne permet pas de savoir si un algorithme est plus rapide qu'un autre pour des tailles de donn√©es en entr√©e faibles. ","version":"Next","tagName":"h3"},{"title":"Tri fusion (merge sort)‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-fusion-merge-sort","content":"Le tri fusion est un algorithme de tri qui consiste √† diviser le tableau en deux parties √©gales, trier les deux parties, puis fusionner les deux parties tri√©es. Le tri fusion est un algorithme efficace, car il a une complexit√© en O(n√ólog(n))O(n \\times log(n))O(n√ólog(n)). C'est un algorithme &quot;r√©cursif&quot;, c'est-√†-dire qu'il s'appelle lui-m√™me pour trier deux sous-tableaux et les fusionner pour trier le tableau complet. Il y a donc deux &quot;phases&quot; dans cet algorithme: la phase de division du tableau en deux parties √©galesla phase de fusion des deux parties tri√©es ","version":"Next","tagName":"h2"},{"title":"Phase de division‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#phase-de-division","content":"Il existe deux fa√ßons de proc√©der pour diviser le tableau en deux parties √©gales: Cr√©er des tableaux interm√©diaires pour stocker les deux parties du tableau √† trier, puis fusionner les deux tableaux tri√©s.Utiliser des indices pour d√©finir les parties du tableau √† trier, et trier directement le tableau en place. La premi√®re m√©thode est plus simple √† comprendre, mais utilise plus de m√©moire, car il faut cr√©er des tableaux interm√©diaires. On privil√©gie donc la deuxi√®me m√©thode, et c'est celle que je vais d√©tailler ici. Pour trier un tableau, on va donc utiliser deux indices, un indice de d√©but et un indice de fin, qui vont d√©finir la partie du tableau √† trier. Par exemple, pour le tableau [6, 2, 8, 1, 5, 3, 9], on va utiliser les indices 0 et 6 pour trier le tableau complet. On va calculer la taille de la partie du tableau √† trier, ici 6 (indice de fin) - 0 (indice de d√©but) + 1 (car on compte l'√©l√©ment √† l'indice de fin), soit 7. On va ensuite diviser cette taille par deux, soit 3 (on peut arrondir √† l'entier inf√©rieur). On va donc utiliser par r√©cursion les indices 0 et 3 pour trier la premi√®re partie du tableau, et les indices 4 et 6 pour trier la deuxi√®me partie du tableau. Enfin on va fusionner les deux parties tri√©es pour trier le tableau complet. ","version":"Next","tagName":"h3"},{"title":"Phase de fusion‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#phase-de-fusion","content":"C'est la phase de fusion qui est la plus int√©ressante, car c'est elle qui va permettre de trier le tableau. Pour fusionner deux tableaux tri√©s, on va utiliser deux (autres) indices, un indice pour chaque tableau, qui vont permettre de parcourir les deux tableaux. On va comparer les √©l√©ments des deux tableaux, et ajouter le plus petit des deux dans le tableau final. On va incr√©menter l'indice du tableau dont on a ajout√© l'√©l√©ment, et on recommence l'op√©ration jusqu'√† ce qu'on ait parcouru les deux tableaux. attention Il faut faire attention √† ne pas d√©passer la taille des sous-tableaux avec les indices, sinon on va avoir une erreur en essayant d'acc√©der √† un √©l√©ment qui n'existe pas. Il faut donc v√©rifier que les indices sont bien inf√©rieurs √† la taille des sous-tableaux. Si l'un des deux indices est √©gal √† la taille du sous-tableau, cela veut dire qu'on a parcouru tout le sous-tableau, et qu'il ne reste plus qu'√† ajouter les √©l√©ments du deuxi√®me sous-tableau dans le tableau final. On obtient ainsi un tableau tri√©. info La condition d'arr√™t de la r√©cursion est quand la taille de la partie du tableau √† trier est inf√©rieure ou √©gale √† 1, car un tableau de taille 1 est d√©j√† tri√©. ","version":"Next","tagName":"h3"},{"title":"Tri rapide (quick sort)‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-rapide-quick-sort","content":"Le tri rapide est un algorithme de tri qui consiste √† choisir un √©l√©ment du tableau, appel√© pivot, et √† placer tous les √©l√©ments plus petits que le pivot √† gauche du pivot, et tous les √©l√©ments plus grands que le pivot √† droite du pivot. On r√©p√®te ensuite l'op√©ration sur les deux sous-tableaux, jusqu'√† ce que le tableau soit tri√©. De la m√™me mani√®re que pour le tri fusion, c'est un algorithme r√©cursif et on va donc utiliser des indices pour d√©finir les parties du tableau √† trier. Il y a √©galement deux phases dans cet algorithme: la phase de division du tableau en deux parties en fonction du pivotla phase de tri des deux parties ","version":"Next","tagName":"h2"},{"title":"Phase de division‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#phase-de-division-1","content":"Choix du pivot‚Äã Le choix du pivot est tr√®s important, car il va d√©terminer la complexit√© de l'algorithme. Si on choisit un pivot qui est toujours le plus petit √©l√©ment du tableau, on va avoir une complexit√© en O(n2)O(n^2)O(n2), car on va devoir parcourir tout le tableau √† chaque it√©ration (de m√™me si on choisit le plus grand √©l√©ment du tableau). Il existe plusieurs m√©thodes pour choisir le pivot, la plus simple est de choisir le premier √©l√©ment du tableau. Mais cela peut √™tre probl√©matique si le tableau est d√©j√† tri√© car on va diviser le tableau en deux parties de tailles tr√®s diff√©rentes. info L'id√©al est de choisir un pivot qui est proche de la valeur m√©diane du tableau, c'est-√†-dire qui va diviser le tableau en deux parties √©gales. Il existe plusieurs m√©thodes pour choisir un pivot proche de la valeur m√©diane du tableau, mais elles sont plus compliqu√©es √† mettre en oeuvre. Nous allons pr√©f√©rer choisir un pivot al√©atoire ou plus simplement l'√©l√©ment au milieu du sous-tableau consid√©r√© pour minimiser les risques de cas d√©favorables. Partitionnement‚Äã Une fois le pivot choisi, on va parcourir le tableau et placer tous les √©l√©ments plus petits que le pivot √† gauche du pivot, et tous les √©l√©ments plus grands que le pivot √† droite du pivot. Il y a plusieurs approche pour g√©rer le pivot, dans notre cas, on va choisir de premi√®rement placer le pivot √† la fin du tableau. Pour cela, on va utiliser deux indices, un indice pour parcourir le tableau de gauche √† droite, et un indice pour parcourir le tableau de droite √† gauche. On va incr√©menter l'indice de gauche tant que l'√©l√©ment est plus petit que le pivot, et on va d√©cr√©menter l'indice de droite tant que l'√©l√©ment est plus grand que le pivot. Si l'indice de gauche est inf√©rieur √† l'indice de droite, on va √©changer les deux √©l√©ments et on recommence l'op√©ration. Une fois que les deux indices se sont crois√©s, on sait que tous les √©l√©ments plus petits que le pivot sont √† gauche du pivot, et tous les √©l√©ments plus grands que le pivot sont √† droite du pivot. Enfin, on va √©changer le pivot avec l'√©l√©ment √† l'indice de gauche (l'indice pointant sur le premier √©l√©ment plus grand que le pivot) pour que le pivot soit √† sa place d√©finitive. R√©cursion‚Äã On obtient ainsi un tableau avec le pivot √† sa place d√©finitive, et tous les √©l√©ments plus petits que le pivot √† gauche du pivot, et tous les √©l√©ments plus grands que le pivot √† droite du pivot et on conna√Æt l'indice du pivot. On va donc pouvoir appeler r√©cursivement l'algorithme sur les deux sous-tableaux, en ignorant le pivot. ","version":"Next","tagName":"h3"},{"title":"Tri par d√©nombrement (counting sort)‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#tri-par-d√©nombrement-counting-sort","content":"Un tri int√©ressant est le tri par d√©nombrement (ou counting sort en anglais). Il est tr√®s efficace, car il va permettre de trier un tableau en complexit√© lin√©aire, c'est-√†-dire en O(n)O(n)O(n). Il ne fonctionne cependant que pour des donn√©es enti√®res car il ne se base pas sur des comparaisons mais va compter le nombre d'occurrences de chaque valeur (de plus pour simplifier, on va supposer que les valeurs sont positives). Le pr√©requis pour utiliser cet algorithme est donc de conna√Ætre la valeur maximale des donn√©es √† trier. Soit on conna√Æt cette valeur √† l'avance, soit on peut la calculer en parcourant le tableau une premi√®re fois. L'algorithme consiste √† compter le nombre d'occurrences de chaque valeur dans le tableau, puis √† reconstruire le tableau en pla√ßant les valeurs dans l'ordre. Par exemple, si on se fixe des valeurs enti√®res entre 0 et 9, on peut trier le tableau suivant [1, 4, 1, 2, 7, 5, 2] en proc√©dant ainsi: On parcourt le tableau pour compter le nombre d'occurrences de chaque valeur. valeur\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9nombre d'occurrences\t0\t2\t2\t0\t1\t1\t0\t1\t0\t0 On reconstruit le tableau en parcourant le tableau des occurrences et en ajoutant les valeurs dans l'ordre. On ajoute 2 fois la valeur 1On ajoute 2 fois la valeur 2... On obtient ainsi le tableau tri√© [1, 1, 2, 2, 4, 5, 7]. attention On remarque qu'il faut pouvoir stocker le nombre d'occurrences de chaque valeur, donc un tableau de taille 10 dans notre exemple. Il faut donc un tableau de taille kkk pour trier des donn√©es comprises entre 0 et k‚àí1k-1k‚àí1 ce qui augmente la complexit√© en m√©moire de l'algorithme. C'est √† prendre en compte si on veut utiliser cet algorithme car il peut √™tre tr√®s efficace en temps, mais peut aussi utiliser beaucoup de m√©moire si les valeurs sont tr√®s grandes. C'est un algorithme √† utiliser seulement dans le cas o√π on conna√Æt la valeur maximale des donn√©es √† trier et que cette valeur est raisonnable. ","version":"Next","tagName":"h2"},{"title":"Pour aller plus loin:‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#pour-aller-plus-loin","content":"Details Tri par d√©nombrement stable‚Äã On peux am√©liorer le tri par d√©nombrement en le rendant stable. Cela signifie que si deux √©l√©ments ont la m√™me valeur, ils seront dans le m√™me ordre dans le tableau tri√© que dans le tableau initial. Cela ne semble pas tr√®s important √† premi√®re vue, mais cela permet de trier des donn√©es plus complexes et leur associant des valeurs enti√®res sur lesquelles on va effectuer le tri. POur faire cela il faut modifier l√©g√®rement l'algorithme de tri par d√©nombrement. Une fois qu'on a compt√© le nombre d'occurrences de chaque valeur, on va calculer la somme partielle des occurrences de chaque valeur. Cela va nous permettre de conna√Ætre la position de chaque valeur dans le tableau tri√©. Par exemple, si on se fixe des valeurs enti√®res entre 0 et 9 et le tableau suivant [1, 4, 1, 2, 7, 5, 2]: On compte le nombre d'occurrences de chaque valeur et on obtient le tableau suivant: [0, 2, 2, 0, 1, 1, 0, 1, 0, 0]On calcule la somme partielle des occurrences de chaque valeur et on obtient le tableau suivant: [0, 2, 4, 4, 5, 6, 6, 7, 7, 7] remarque On peut se resservir du tableau des occurrences pour stocker la somme partielle des occurrences de chaque valeur, ce qui permet de ne pas utiliser de tableau interm√©diaire suppl√©mentaire. On va construire un nouveau tableau de m√™me taille que le tableau initial, et on va parcourir le tableau initial pour ajouter les valeurs dans le nouveau tableau. On va ajouter la valeur √† la position indiqu√©e par la somme partielle des occurrences de la valeur, puis on va d√©cr√©menter la somme partielle des occurrences de la valeur. Par exemple, pour la valeur 1, on va ajouter la valeur 1 √† la position 2 du nouveau tableau, puis on va d√©cr√©menter la somme partielle des occurrences de la valeur 1 pour obtenir 1 (car il reste une occurrence de la valeur 1). On obtient ainsi le tableau tri√© [1, 1, 2, 2, 4, 5, 7]. L'inconv√©nient principal de cette m√©thode est qu'il faut un tableau interm√©diaire pour stocker le tableau tri√©, ce qui augmente la complexit√© en m√©moire de l'algorithme. tri base (radix sort)‚Äã Le tri par d√©nombrement permet de trier des donn√©es enti√®res comprises entre 0 et k‚àí1k-1k‚àí1 en complexit√© lin√©aire. On va se servir de cet algorithme pour trier des donn√©es plus complexes, en associant √† chaque donn√©e une valeur enti√®re sur laquelle on va effectuer le tri (d'o√π l'int√©r√™t de rendre le tri par d√©nombrement stable). On va consid√©rer un tri de nombres entiers, mais cela peut s'appliquer √† d'autres types de donn√©es. Un nombre entier peut √™tre repr√©sent√© en base 10, c'est-√†-dire en utilisant les chiffres de 0 √† 9. Par exemple, le nombre 123 peut √™tre repr√©sent√© en base 10 par la suite de chiffres 1, 2 et 3. On va donc pouvoir trier des nombres entiers en triant les chiffres de leur repr√©sentation en base 10. Par exemple, pour trier les nombres [123, 456, 789, 321, 654, 987], on va trier les chiffres des nombres, en commen√ßant par les centaines, puis les dizaines et enfin les unit√©s. Cela permet de trier les nombres en complexit√© lin√©aire gr√¢ce au tri par d√©nombrement. Dans notre exemple, le nombre le plus grand est 987, il a donc 3 chiffres, on va donc effectuer 3 it√©rations de tri par d√©nombrement pour trier les nombres. remarque Cette information peut √™tre connue √† l'avance, mais on peut aussi la calculer en parcourant le tableau une premi√®re fois. On trie les centaines ce qui donne [123, 321, 456, 654, 789, 987]On trie les dizaines ce qui donne [123, 321, 456, 654, 789, 987]enfin, on trie les unit√©s ce qui donne [123, 321, 456, 654, 789, 987] ","version":"Next","tagName":"h2"},{"title":"Recherche dichotomique‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#recherche-dichotomique","content":"Avoir un tableau tri√© est tr√®s utile pour effectuer des recherches dans un tableau. Par exemple, si on veut savoir si une valeur est pr√©sente dans un tableau, on peut parcourir le tableau et comparer chaque √©l√©ment avec la valeur recherch√©e. Mais si le tableau est tri√©, on peut utiliser une m√©thode plus efficace: la recherche dichotomique. La recherche dichotomique consiste √† diviser le tableau en deux parties √©gales et √† ne garder que la partie qui contient la valeur recherch√©e. On r√©p√®te l'op√©ration jusqu'√† trouver la valeur ou jusqu'√† ce qu'il ne reste plus qu'un seul √©l√©ment dans le tableau. Exemple simple avec le tableau suivant [1, 2, 2, 4, 5, 8, 12] (nombre d'√©l√©ments: 7) et la valeur recherch√©e 8: On calcule l'indice du milieu du tableau, soit 3. On compare la valeur √† l'indice 3 avec la valeur recherch√©e 8, comme 4 est plus petit que 8, on ne garde que la partie du tableau qui contient la valeur recherch√©e, c'est-√†-dire la partie du tableau √† partir de l'indice 4 (indice de d√©but: 4, indice de fin: 6). On recommence l'op√©ration avec la partie du tableau restante. Sous partie du tableau: [4, 8, 12] (nombre d'√©l√©ments: 3), indice du milieu: 5. On compare la valeur √† l'indice 5 avec la valeur recherch√©e 8, comme 8 est √©gal √† 8, on a trouv√© la valeur recherch√©e. On peut donc s'arr√™ter et renvoyer l'indice 5. ","version":"Next","tagName":"h2"},{"title":"R√©sum√©‚Äã","type":1,"pageTitle":"algorithmes de tri, complexit√© et recherche dichotomique","url":"/Learn--cpp_programming/Lessons/S2/Sorting#r√©sum√©","content":"Les algorithmes de tri sont tr√®s importants en informatique, car ils permettent de trier des donn√©es, ce qui est une op√©ration tr√®s courante.La complexit√© d'un algorithme est une mesure de la quantit√© de ressources (temps, m√©moire, etc) que celui-ci va utiliser pour s'ex√©cuter.La complexit√© en temps permet de quantifier la relation entre les conditions de d√©part (nombre d'√©l√©ments du tableau, valeurs des √©l√©ments, etc) et le temps effectu√© par l'algorithme.La complexit√© permet de comparer plusieurs algorithmes entre eux mais ne permet pas de savoir si un algorithme est rapide ou lent.Nous avons vu les algorithmes de tri suivants: Tri par s√©lection (selection sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par recherche successive du plus petit √©l√©ment du tableau. Tri √† bulles (bubble sort): O(n2)O(n^2)O(n2) C'est un algorithme qui fonctionne par comparaison successive de deux √©l√©ments cons√©cutifs du tableau. Tri fusion (merge sort): O(n√ólog(n))O(n \\times log(n))O(n√ólog(n)) C'est un algorithme qui fonctionne par r√©cursion en divisant le tableau en deux parties √©gales, en triant les deux parties, puis en fusionnant les deux parties tri√©es. Tri rapide (quick sort): O(n√ólog(n))O(n \\times log(n))O(n√ólog(n)) C'est un algorithme qui fonctionne par r√©cursion en choisissant un pivot, en divisant le tableau en deux parties en fonction du pivot, puis en triant les deux parties. Tri par d√©nombrement (counting sort): O(n)O(n)O(n) C'est un algorithme qui fonctionne en comptant le nombre d'occurrences de chaque valeur, puis en reconstruisant le tableau en pla√ßant les valeurs dans l'ordre. C'est un algorithme qui ne fonctionne que pour des donn√©es enti√®res et o√π la valeur maximale des donn√©es est connue √† l'avance et relativement petite. La recherche dichotomique est une m√©thode de recherche dans un tableau tri√© qui consiste √† diviser le tableau en deux parties √©gales et √† ne garder que la partie qui contient la valeur recherch√©e. On r√©p√®te l'op√©ration jusqu'√† trouver la valeur souhait√©e. ","version":"Next","tagName":"h2"},{"title":"TD8 - Headers","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/headers","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Fraction)‚Äã","type":1,"pageTitle":"TD8 - Headers","url":"/Learn--cpp_programming/TDs/S1/headers#exercice-1-fraction","content":"Le but de cet exercice est de cr√©er une structure permettant de repr√©senter une fraction. Cette structure devra contenir deux entiers positifs, un pour le num√©rateur et un pour le d√©nominateur. On va utiliser un fichier d'en-t√™te pour d√©finir la structure et les fonctions qui vont permettre de manipuler les fractions. Cr√©er un fichier fraction.hpp qui contiendra la d√©finition de la structure et les prototypes des m√©thodes. La structure devra s'appeler Fraction et contenir deux entiers positifs nomm√©s numerator et denominator de type unsigned int avec comme valeur par d√©faut 0/1. La structure devra contenir les m√©thodes suivantes : - `add` : prend deux fractions en param√®tre et retourne la **somme** des deux fractions. - `sub` : prend deux fractions en param√®tre et retourne la **diff√©rence** des deux fractions. - `mul` : prend deux fractions en param√®tre et retourne le **produit** des deux fractions. - `div` : prend deux fractions en param√®tre et retourne le **quotient** des deux fractions. - `display` : prend une fraction en param√®tre et affiche la fraction sous la forme `numerator/denominator`. Cr√©er un fichier fraction.cpp qui contiendra les d√©finitions des m√©thodes. Impl√©menter les fonctions dans le fichier fraction.cpp. Cr√©er un fichier utils.hpp qui contiendra les fonctions suivantes : gcd : prend deux entiers positifs en param√®tre et retourne le plus grand diviseur commun.simplify : prend une fraction en param√®tre et retourne la fraction simplifi√©e. Cr√©er un fichier utils.cpp et impl√©menter les fonctions. astuce Pour simplifier une fraction, il faut diviser le num√©rateur et le d√©nominateur par le plus grand diviseur commun. On va donc utiliser la fonction gcd pour calculer le plus grand diviseur commun et ensuite diviser le num√©rateur et le d√©nominateur par ce nombre. la fraction 4/6 devient 2/3 car gcd(4, 6) = 2 et 4/2 = 2 et 6/2 = 3. Il faut importer le fichier fraction.hpp dans le fichier utils.hpp pour pouvoir utiliser la structure Fraction dans la fonction simplify. info Pour trouver le plus grand diviseur commun, on peut utiliser l'algorithme d'Euclide qui consiste √† diviser le plus grand nombre par le plus petit et √† r√©p√©ter l'op√©ration avec le reste de la division jusqu'√† obtenir un reste nul. Dans ce cas, le plus petit nombre non nul est le plus grand diviseur commun. exemple avec 22 et 8: 22 % 8 = 6 (reste de la division de 22 par 8) 6 est diff√©rent de 0 donc on continue8 % 6 = 2 (reste de la division de 8 par 6) 2 est diff√©rent de 0 donc on continue6 % 2 = 0 (reste de la division de 6 par 2) 0 est √©gal √† 0 donc on s'arr√™te et le plus grand diviseur commun est 2. Cr√©er un fichier main.cpp qui contiendra le programme principal. Ce programme devra : Cr√©er deux fractions f1 et f2 avec les valeurs de votre choix. (id√©alement avec des valeurs al√©atoires ou saisies par l'utilisateur)Afficher les deux fractions.Afficher la somme des deux fractions.Afficher la diff√©rence des deux fractions.Afficher le produit des deux fractions.Afficher le quotient des deux fractions.Afficher les r√©sultats pr√©c√©dents sous forme de fraction simplifi√©e. info Vous d√©couvrirez au prochain semestre comment am√©liorer ce programme en utilisant la surcharge d'op√©rateurs üõ†Ô∏è. ","version":"Next","tagName":"h2"},{"title":"TD6 - Fonctions","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Functions","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Somme)‚Äã","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-1-somme","content":"√âcrire une fonction somme qui retourne la somme de deux entiers. Utiliser des param√®tres par copie et le prototype suivant: int somme(int a, int b); Utiliser des param√®tres constants pour les arguments de la fonction. Utiliser des r√©f√©rences pour les arguments de la fonction. V√©rifier que cela fonctionne aussi bien avec des variables que des litt√©raux dans le cas des r√©f√©rences. ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (Factorielle)‚Äã","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-2-factorielle","content":"√âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier positif.√âcrire une fonction r√©cursive qui retourne la factorielle de n. info La factorielle d'un entier n est le produit des nombres entiers strictement positifs inf√©rieurs ou √©gaux √† n. Afficher le r√©sultat.G√©rer les cas d'erreur (nombre n√©gatif, nombre trop grand, etc.).Utiliser une fonction it√©rative (non r√©cursive). ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Fibonacci)‚Äã","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-3-fibonacci","content":"√âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier positif.√âcrire une fonction r√©cursive qui retourne sous la forme d'un tableau les n premiers termes de la suite de Fibonacci. info La suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme des deux termes qui le pr√©c√®dent. Ses premiers termes sont 0 et 1. Afficher les n premiers termes de la suite de Fibonacci √† l'aide de la fonction pr√©c√©dente. Par exemple, si l‚Äôutilisateur saisit 7, le programme affichera 0, 1, 1, 2, 3, 5, 8.Pour aller plus loin: Essayer de trouver une solution it√©rative (non r√©cursive). ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (Surcharges)‚Äã","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-4-surcharges","content":"√âcrire une fonction qui permet de calculer la moyenne d'un tableau d'entiers.√âcrire une fonction surcharg√©e portant le m√™me nom qui permet de calculer la moyenne d'un tableau de flottants. ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (Suite)‚Äã","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-5-suite","content":"√âcrire sous forme r√©cursive les fonctions UnU_nUn‚Äã et VnV_nVn‚Äã conform√©ment √† la description suivante: U0=1U_0 = 1U0‚Äã=1 et Un+1=3Un+2VnU_{n+1} = 3U_n + 2V_nUn+1‚Äã=3Un‚Äã+2Vn‚ÄãV0=2V_0 = 2V0‚Äã=2 et Vn+1=2Vn+Un+1V_{n+1} = 2V_n + U_n + 1Vn+1‚Äã=2Vn‚Äã+Un‚Äã+1 Afficher les dix premiers termes de chacune des suites. Vous devez obtenir les r√©sultats suivants: U0 = 1 et V0 = 2 U1 = 5 et V1 = 7 U2 = 33 et V2 = 20 U3 = 139 et V3 = 74 U4 = 565 et V4 = 288 U5 = 2271 et V5 = 1142 U6 = 9097 et V6 = 4556 U7 = 36403 et V7 = 18210 U8 = 145629 et V8 = 72824 U9 = 582535 et V9 = 291278  astuce Il est possible d'exprimer UnU_nUn‚Äã et VnV_nVn‚Äã en fonction de Un‚àí1U_{n-1}Un‚àí1‚Äã et Vn‚àí1V_{n-1}Vn‚àí1‚Äã. ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (Pangramme)‚Äã","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-6-pangramme","content":"√âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne true si la cha√Æne est un pangramme, false sinon. Il faut faire attention √† la casse (majuscules/minuscules), un m√™me lettre majuscule et minuscule compte pour la m√™me lettre. info Un pangramme est une phrase contenant toutes les lettres de l'alphabet au moins une fois. ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (String)‚Äã","type":1,"pageTitle":"TD6 - Fonctions","url":"/Learn--cpp_programming/TDs/S1/Functions#exercice-7-string","content":"√âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui modifie cette cha√Æne en rempla√ßant les lettres minuscules par des lettres majuscules et vice-versa. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne le nombre de voyelles de cette cha√Æne. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne le nombre de mots de cette cha√Æne. On consid√®re que les mots sont s√©par√©s par un ou plusieurs espaces. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne la m√™me cha√Æne √©crite √† l'envers. √âcrire une fonction qui prend en param√®tre une cha√Æne de caract√®res et qui retourne true si la cha√Æne est un nombre entier. astuce L'id√©e est de parcourir la cha√Æne de caract√®res et de v√©rifier si chaque caract√®re est un chiffre ou non. Pour tester si un caract√®re est un chiffre vous pouvez comparer la valeur ASCII du caract√®re avec les valeurs ASCII des chiffres (voir l'Exercice 5 du TD2). Il existe aussi la fonction std::isdigit (voir la documentation) qui permet de tester si un caract√®re est un chiffre ou non. ","version":"Next","tagName":"h2"},{"title":"TD4 - Boucles","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Loops","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (For)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-1-for","content":"Faire une boucle for qui affiche les nombres pairs inf√©rieurs ou √©gal √† un nombre entr√© par l'utilisateur de diff√©rentes fa√ßons: en utilisant un condition et l'op√©rateur moduloen utilisant le mot cl√© continueen utilisant une boucle bien choisie (un nombre pair est un nombre qui peut s'√©crire comme le double d'un nombre entier) astuce Vous pourrez utiliser std::cin pour demander le nombre maximum √† l'utilisateur (aucune gestion d'une √©ventuelle erreur de saisie n'est demand√©e ici). ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (While)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-2-while","content":"√âcrire une boucle while qui affichera les entiers entre 1 et 20.√âcrire une boucle while qui affichera les 50 premiers multiples de 7, chacun sur une ligne de la forme: 5 fois 7 = 35.Refaire les deux questions pr√©c√©dentes en utilisant une boucle for. ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Somme d'entiers positifs)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-3-somme-dentiers-positifs","content":"√âcrire un programme qui demande √† l‚Äôutilisateur de saisir des entiers positifs (s‚Äôarr√™te d√®s que l‚Äôutilisateur saisit un entier n√©gatif) G√©rer l'entr√©e utilisateur (et son arr√™t) √† l'aide d'une boucle while ou do while.Afficher la somme des entiers positifs saisis par l‚Äôutilisateur.Modifier le programme pour qu'il affiche √©galement la moyenne des entiers positifs saisis par l‚Äôutilisateur. info Pour calculer la moyenne, il faut compter le nombre d'entiers positifs saisis par l'utilisateur. Vous n'avez pas √† stocker les entiers saisis par l'utilisateur (vous d√©couvrirez comment faire cela dans le prochain chapitre). ","version":"Next","tagName":"h2"},{"title":"Exercice 4 (rendu de monnaie)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-4-rendu-de-monnaie","content":"√âcrire un programme qui demande √† l‚Äôutilisateur un montant en euros et affiche le nombre de billets et de pi√®ces n√©cessaires pour rendre la monnaie avec le moins de billets et de pi√®ces possible. On suppose que l‚Äôon dispose de pi√®ces de 1, 2, 5, 10, 20 et 50 centimes, de 1 et 2 euros ainsi que de billets de 5, 10, 20, 50, 100, 200 et 500 euros. astuce Utilisez un tableau pour stocker le nombre de pi√®ces et de billets √† rendre. Utilisez un algorithme glouton qui consiste √† regarder si on peut rendre la monnaie avec le plus gros billet ou pi√®ce possible et √† recommencer avec le billet ou la pi√®ce suivante jusqu'√† avoir rendu toute la monnaie. ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (entr√©e utilisateur)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-5-entr√©e-utilisateur","content":"√âcrire un programme qui demande √† l'utilisateur un nombre et affiche la table de multiplication de ce nombre. Vous devrez g√©rer le cas o√π l'utilisateur saisit une valeur incorrecte (un nombre n√©gatif ou une lettre par exemple) et redemander √† l'utilisateur de saisir un nombre tant qu'il n'a pas saisi une valeur correcte. Je vous invite √† retourner voir l'exercice 3 du TD2 sur les conditions pour vous aider. ","version":"Next","tagName":"h2"},{"title":"Exercice 6 (conjecture de Syracuse)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-6-conjecture-de-syracuse","content":"√âcrire un programme qui, √† partir d‚Äôun entier positif saisi par l‚Äôutilisateur, affiche le nombre de termes de la suite de Syracuse n√©cessaires pour atteindre 1 (on inclut le terme de d√©part dans le d√©compte). La suite de Syracuse est une suite d'entiers dans laquelle chaque terme est obtenu en appliquant une fonction √† son terme pr√©c√©dent. Cette fonction est d√©finie comme suit: si le terme est pair, le terme suivant est √©gal √† la moiti√© du terme pr√©c√©dent. (x/2)si le terme est impair, le terme suivant est √©gal √† 3 fois le terme pr√©c√©dent plus 1 (3x+1). Par exemple, si le terme de d√©part est 7, la suite est :7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 4, 2, 1, 4, 2, 1, ... Ici, la suite atteint la valeur 1 au bout de 17 termes (incluant le terme de d√©part). Vous remarquez qu‚Äô√† la fin, une fois qu‚Äôon est tomb√© sur 1, la suite finit par r√©p√©ter ind√©finiment le cycle 4, 2, 1. Il est conjectur√© que cette suite atteint toujours la valeur 1 quelque soit le terme de d√©part. Cela a d'ailleurs d√©j√† √©t√© v√©rifi√©e num√©riquement jusqu‚Äô√† 10^20 (par Tomas Oliveira e Silva). ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (ASCII art)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-7-ascii-art","content":"√âcrire un programme qui demande √† l‚Äôutilisateur de saisir un entier positif et affiche un triangle rectangle de hauteur n comme dans l‚Äôexemple ci-dessous. exemple d'ex√©cution Entrez un entier positif : 5 * ** *** **** *****  Essayer d'afficher un sapin de no√´l, autrement dit un triangle rectangle isoc√®le de hauteur n et dont le sommet est compos√© d'une seule √©toile. exemple d'ex√©cution Entrez un entier positif : 3 * *** *****  Essayer d'afficher les contours d'un carr√© de c√¥t√© n comme dans l‚Äôexemple ci-dessous. exemple d'ex√©cution Entrez un entier positif : 5 ***** * * * * * * *****  ","version":"Next","tagName":"h2"},{"title":"Exercice 8 (Le juste prix)‚Äã","type":1,"pageTitle":"TD4 - Boucles","url":"/Learn--cpp_programming/TDs/S1/Loops#exercice-8-le-juste-prix","content":"Un nombre entier est tir√© au hasard entre 1 et 100 (inclus). Le joueur doit deviner ce nombre en un minimum de tentatives. √Ä chaque tentative, le programme indique au joueur si le nombre √† deviner est plus grand ou plus petit que celui qu‚Äôil a propos√©. Le programme s‚Äôarr√™te lorsque le joueur a trouv√© le nombre myst√®re. info Pour g√©n√©rer un nombre al√©atoire, vous pouvez utiliser la fonction rand() de la biblioth√®que cstdlib. Elle retourne un nombre entier al√©atoire entre 0 et RAND_MAX (une constante d√©finie dans la biblioth√®que cstdlib). Pour obtenir un nombre al√©atoire entre 1 et 100, on peut utiliser l'op√©rateur modulo %: std::rand() % 100 + 1 Pour que le g√©n√©rateur de nombres al√©atoires ne g√©n√®re pas toujours la m√™me s√©quence de nombres, il faut l‚Äôinitialiser avec une valeur diff√©rente √† chaque ex√©cution du programme. C'est avec la fonction srand(). On peut utiliser la fonction time() de la biblioth√®que ctime pour obtenir l'heure actuelle en secondes et l'utiliser comme valeur d'initialisation du g√©n√©rateur de nombres al√©atoires. #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;iostream&gt; int main() { // Initialisation du g√©n√©rateur de nombres al√©atoires avec la fonction time() std::srand(std::time(nullptr)); int random_variable { std::rand()}; std::cout &lt;&lt; &quot;Random value between 0 and &quot;&lt;&lt; RAND_MAX &lt;&lt;&quot; : &quot; &lt;&lt; random_variable &lt;&lt; std::endl; } Il existe une fa√ßon plus moderne de g√©n√©rer des nombres al√©atoires √† partir de C++11, nous d√©couvrirons cela au prochain semestre. ","version":"Next","tagName":"h2"},{"title":"TD1 - Mise en place","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Setup","content":"","keywords":"","version":"Next"},{"title":"Premier programme‚Äã","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#premier-programme","content":"Une fois que vous avez install√© les outils, vous pouvez cr√©er votre premier programme. Je vous invite √† regarder la page suivante pour avoir les instructions: Premier programme ","version":"Next","tagName":"h2"},{"title":"Plusieurs ex√©cutables‚Äã","type":1,"pageTitle":"TD1 - Mise en place","url":"/Learn--cpp_programming/TDs/S1/Setup#plusieurs-ex√©cutables","content":"Comme je l'ai expliqu√©, il ne doit y avoir qu'un seul point d'entr√©e dans un programme C++ et donc une seule fonction main. Cependant, dans le cadre des TDs, il est parfois utile de pouvoir tester plusieurs fonctions main diff√©rentes, une par exercice par exemple. Pour cela, nous allons utiliser une fonctionnalit√© de CMake qui permet de cr√©er plusieurs targets ou ex√©cutables. Je vous invite √† cr√©er deux fichiers td01_ex01.cpp et td01_ex02.cpp dans un dossier src et √† y mettre le contenu suivant: src/td01_ex01.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 01&quot; &lt;&lt; std::endl; return 0; }  src/td01_ex02.cpp #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &quot;TD 01 - Ex 02&quot; &lt;&lt; std::endl; return 0; }  Ensuite, nous allons cr√©er un fichier CMakeLists.txt √† la racine du projet avec le contenu suivant: CMakeLists.txt cmake_minimum_required(VERSION 3.0) set(CMAKE_CXX_STANDARD 17) project(TD01) # On indique que l'on veut cr√©er un ex√©cutable &quot;ex01&quot; compil√© √† partir du fichier td01_ex01.cpp add_executable(ex01 src/td01_ex01.cpp) # On indique que l'on veut cr√©er un ex√©cutable &quot;ex02&quot; compil√© √† partir du fichier td01_ex02.cpp add_executable(ex02 src/td01_ex02.cpp)  Vous devriez avoir une arborescence de fichiers qui ressemble √† √ßa: td01 ‚îú‚îÄ‚îÄ CMakeLists.txt ‚îî‚îÄ‚îÄ src ‚îú‚îÄ‚îÄ td01_ex01.cpp ‚îî‚îÄ‚îÄ td01_ex02.cpp  Ouvrez ensuite le dossier td01 avec VSCode, il devrait vous proposer de configurer CMake comme pour le premier programme. Vous devriez ensuite avoir deux targets dans la barre √† droite du bouton &quot;Run&quot; en bas:  Cela vous permet de choisir quelle target vous voulez ex√©cuter pour travailler sur plusieurs ex√©cutables dans le m√™me projet. info C'est la m√™me chose pour les t√¢ches de compilation (√† droite du bouton &quot;Build&quot;). Bravo, Vous √™tes maintenant pr√™t √† faire du C++ sur vos propres machines ! ü•≥ ","version":"Next","tagName":"h2"},{"title":"TD9 - M√©moire","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (Allocation dynamique)‚Äã","type":1,"pageTitle":"TD9 - M√©moire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-1-allocation-dynamique","content":"√âcrire un programme qui alloue dynamiquement une variable de type int avec le mot-cl√© new (sans initialisation).Demander √† l'utilisateur de saisir une valeur pour cette variable et modifier la valeur de la variable avec cette saisie.√âcrire une fonction qui prend en param√®tre un pointeur sur un int et qui affiche la valeur de la variable point√©e.Afficher la valeur de la variable avec la fonction pr√©c√©dente.Afficher l'adresse de la variable.Lib√©rer cette variable avec le mot-cl√© delete. ","version":"Next","tagName":"h2"},{"title":"Exercice 2‚Äã","type":1,"pageTitle":"TD9 - M√©moire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-2","content":"√âcrire un programme qui g√©n√®re un tableau (std::vector) de 100 entiers al√©atoires compris entre 0 et 100. info Vous pouvez utiliser la fonction rand() pour g√©n√©rer un nombre al√©atoire. Je vous renvoie √† l'Exercice 1 du TD5 pour plus d'informations. √âcrire une fonction qui retourne un pointeur sur le plus grand √©l√©ment du tableau. √âcrire une fonction qui prend en param√®tre un pointeur sur un emplacement m√©moire contigu√´ d'entiers et sa taille et qui retourne la somme des √©l√©ments du tableau. Utiliser les fonctions pr√©c√©dentes pour afficher le plus grand √©l√©ment du tableau et la somme des √©l√©ments du tableau. astuce On peut r√©cup√©rer un pointeur sur le premier √©l√©ment d'un std::vector avec la m√©thode data(). Sinon il est aussi d'utiliser l'op√©rateur &amp; sur le premier √©l√©ment du std::vector. Completer la fonction sum suivante pour qu'elle retourne un pointeur sur la somme des √©l√©ments du tableau pass√© en param√®tre. int* sum(std::vector&lt;int&gt; const&amp; v) { int sum {0}; // boucle for // TODO } Utiliser la fonction sum pour afficher la somme des √©l√©ments du tableau. En fonction du r√©sultat obtenu, que pouvez-vous en d√©duire sur le fonctionnement de la fonction sum ? Si elle ne fonctionne pas, corriger la fonction sum pour qu'elle fonctionne correctement. ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (Split)‚Äã","type":1,"pageTitle":"TD9 - M√©moire","url":"/Learn--cpp_programming/TDs/S1/MemoryAllocation#exercice-3-split","content":"Dans cet exercice, on ne doit pas utiliser de std::vector. Allouer dynamiquement un tableau de 100 flottants al√©atoires compris entre 0 et 100 (utiliser l'allocation dynamique pour des emplacements m√©moire contigu√´s). info Vous pouvez utiliser la fonction rand() pour g√©n√©rer un nombre al√©atoire. Pour g√©n√©rer un nombre flottant al√©atoire vous pouvez utiliser la fonction rand() et la diviser par RAND_MAX (qui est une constante d√©finie dans la biblioth√®que cstdlib) ce qui permet d'obtenir un nombre flottant al√©atoire entre 0 et 1. Il ne vous reste plus qu'√† multiplier ce nombre par 100 pour obtenir un nombre flottant al√©atoire entre 0 et 100. √âcrire une fonction qui prend en param√®tre un tableau de flottants (sous la forme d'un pointeur sur le premier √©l√©ment du tableau) et sa taille et qui retourne un pointeur sur le plus grand √©l√©ment du tableau. On souhaite cr√©er une fonction qui permet de cr√©er un nouveau tableau compos√© des √©l√©ments du tableau pass√© en param√®tre qui sont sup√©rieurs √† un certain seuil. √âcrire une fonction thresholdFilter qui prend en param√®tre un tableau de flottants, sa taille, un seuil et une r√©f√©rence sur un entier qui contiendra la taille du nouveau tableau et qui retourne un pointeur sur le premier √©l√©ment du nouveau tableau. Voil√† la signature de la fonction: float* thresholdFilter(float const* const array, size_t const size, float const threshold, size_t&amp; new_size); info Vous pouvez remarquer que j'ai √©crit float const* const array au lieu de float* array. Le premier const signifie que l'on ne peut pas modifier les valeurs point√©es par le pointeur array et le deuxi√®me const signifie que l'on ne peut pas modifier l'adresse point√©e par le pointeur array. ","version":"Next","tagName":"h2"},{"title":"TD7 - Structures","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Struct","content":"","keywords":"","version":"Next"},{"title":"Exercice 1‚Äã","type":1,"pageTitle":"TD7 - Structures","url":"/Learn--cpp_programming/TDs/S1/Struct#exercice-1","content":"Vous √™tes le pilote d'un sous-marin, vous avez re√ßu des ordres de mouvements sous la forme d'une instruction et d'une distance √† parcourir. Vous devez √©crire un programme qui permet de calculer la position du sous-marin apr√®s avoir effectu√© les mouvements re√ßus. Votre position initiale est (0, 0) et vous pouvez vous d√©placer dans les directions suivantes: Haut, Bas, Avant, Arri√®re. √âcrire une structure Position qui permet de stocker les coordonn√©es du sous-marin. √âcrire un enum Direction qui permet de stocker les directions possibles. √âcrire une structure Move qui repr√©sente un mouvement sous la forme d'une direction et d'une distance √† parcourir. √âcrire une fonction moveSubmarine qui permet de d√©placer le sous-marin en fonction d'un mouvement. La fonction ne doit rien retourner et doit modifier la position du sous-marin pass√©e en param√®tre. √âcrire une fonction display qui permet d'afficher la position du sous-marin pass√©e en param√®tre. Le but est d'indiquer la position du sous-marin apr√®s avoir effectu√© les mouvements suivants: Avant 10Bas 5Arri√®re 3Haut 2Avant 5Bas 1Arri√®re 2Avant 3Bas 1Haut 3Avant 1Bas 5Arri√®re 2Avant 6 Vous pouvez repr√©senter les mouvements sous la forme d'un vecteur de Move: std::vector&lt;Move&gt; moves = { {Direction::Forward, 10}, {Direction::Down, 5}, {Direction::Backward, 3}, {Direction::Up, 2}, {Direction::Forward, 5}, {Direction::Down, 1}, {Direction::Backward, 2}, {Direction::Forward, 3}, {Direction::Down, 1}, {Direction::Up, 3}, {Direction::Forward, 1}, {Direction::Down, 5}, {Direction::Backward, 2}, {Direction::Forward, 6} };  info Exercice inspir√© de de l'√©dition 2021 de l'advent of code: https://adventofcode.com/2021/day/2 ","version":"Next","tagName":"h2"},{"title":"TD2 - Variables","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S1/Variables","content":"","keywords":"","version":"Next"},{"title":"Exercice 1 (op√©rations)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-1-op√©rations","content":"Cr√©er une variable de type int et initialiser la avec une valeur de votre choix. Appliquer les op√©rations suivantes sur cette variable et afficher le r√©sultat de chaque op√©ration: Incr√©menter la variable de 1 (avec la m√©thode de votre choix).Multiplier la variable par 3.Diviser la variable par 2. astuce Utiliser la fonction std::cout pour afficher la valeur de la variable. ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (entr√©e utilisateur)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-2-entr√©e-utilisateur","content":"Cr√©er un programme qui demande √† l'utilisateur de saisir trois valeurs flottantes (de type float). Calculer la somme de ces trois valeurs et stocker le r√©sultat dans une variable de type float.Calculer de m√™me la moyenne de ces trois valeurs.Afficher le r√©sultat de la somme et de la moyenne. astuce Utiliser la fonction std::cin pour lire la valeur saisie par l'utilisateur. ","version":"Next","tagName":"h2"},{"title":"Exercice 3 (cast)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-3-cast","content":"Cr√©er une variable enti√®re (de type int) et l'initialiser avec la valeur 11. Afficher la valeur de cette variable. Afficher la valeur de cette variable divis√©e par 2. Vous devriez obtenir une valeur de 5 et non 5.5. Pourquoi ? Utiliser un cast pour convertir la variable en un type flottant. Afficher la valeur de la variable divis√©e par 2.0f astuce static_cast&lt;type&gt;(variable) permet convertir une variable en un autre type. ","version":"Next","tagName":"h2"},{"title":"Exercice 4‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-4","content":"√âcrire un programme qui demande un nombre de jours √† l'utilisateur et affiche le nombre d'ann√©es, de mois et de jours correspondant √† ce nombre de jours. L‚ÄôaÔ¨Äichage se fera sous la forme : &quot;J jours correspondent √†: xx siecle xx annee xx mois xx semaine xx jours&quot; info Pour simplifier le probl√®me, on consid√©rera que tous les mois ont 30 jours et toutes les ann√©es 360 jours. exemple d'ex√©cution Entrez un nombre de jours : 4096 4096 jours correspondent √† : 0 siecle 11 annee 4 mois 2 semaine 2 jours  ","version":"Next","tagName":"h2"},{"title":"Exercice 5 (ASCII)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-5-ascii","content":"Demander √† l'utilisateur de saisir un nombre entier entre 1 et 26 et afficher la lettre correspondante dans l'alphabet. exemple d'ex√©cution Entrez un nombre entre 1 et 26 : 5 La lettre correspondante est : E  info Le type char permet de stocker un caract√®re. Il est possible de faire des op√©rations sur les caract√®res comme si c'√©tait des entiers. Le code ASCII associe les caract√®res √† des entiers. Par exemple, le caract√®re 'A' est associ√© √† l'entier 65, 'B' √† 66, etc. En ce qui nous concerne, nous allons utiliser le fait que les lettres majuscules sont associ√©es aux entiers de 65 √† 90 et les lettres minuscules aux entiers de 97 √† 122. Vous pouvez trouver la table de correspondance ASCII compl√®te ici. ","version":"Next","tagName":"h2"},{"title":"Exercice 6‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-6","content":"Un cuisinier doit aller au march√© pour r√©cup√©rer ses l√©gumes. Il a besoin de sacs de pommes de terre, de carottes et de salades. Vous avez les informations suivantes : Un sac de pommes de terre p√®se 2kg.Le prix d'un kg de pommes de terre est de 1.5‚Ç¨.Une carotte p√®se 150g.Le prix d'un kg de carottes est de 2.5‚Ç¨.Une salade co√ªte 1.2‚Ç¨. √âcrire un programme qui demande √† l'utilisateur de saisir le nombre de sacs de pommes de terre, de carottes et de salades qu'il souhaite acheter. Le programme doit ensuite calculer le prix total de la commande et l'afficher. exemple d'ex√©cution Entrez le nombre de sacs de pommes de terre : 2 Entrez le nombre de carottes : 3 Entrez le nombre de salades : 1 Le prix total de la commande est de 8.325 ‚Ç¨  Bonus En bonus, afficher le d√©tail de la commande. ... Le prix total de la commande est de 8.325 ‚Ç¨ d√©tails: - 2 sacs de pommes de terre : 6 ‚Ç¨ - 3 carottes : 1.125 ‚Ç¨ - 1 salade : 1.2 ‚Ç¨  ","version":"Next","tagName":"h2"},{"title":"Exercice 7 (probl√®me de compilation)‚Äã","type":1,"pageTitle":"TD2 - Variables","url":"/Learn--cpp_programming/TDs/S1/Variables#exercice-7-probl√®me-de-compilation","content":"#include &lt;iotream&gt; int main() { const int a{5}; int b{8}; float c{pi*3}; // je veux le r√©sultat de pi (environ 3.141592) fois 3 b += &quot;20&quot;; // je veux ajouter 20 √† la valeur de b a = a * 15; // je veux le r√©sultat de a fois 15 std::cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; &quot;b: &quot; &lt;&lt; b &lt;&lt; std::endl std::cout &lt;&lt; &quot;c: &quot; &lt;&lt; c &lt;&lt; std::endl; return 0; }  V√©rifier que le code ne compile pas et essayez de corriger les erreurs. info Pour pi vous pouvez utiliser la constante M_PI d√©finie dans la biblioth√®que cmath. Il faut ajouter #include &lt;cmath&gt; en haut du fichier pour pouvoir l'utiliser. ","version":"Next","tagName":"h2"},{"title":"sorting","type":0,"sectionRef":"#","url":"/Learn--cpp_programming/TDs/S2/sorting","content":"","keywords":"","version":"Next"},{"title":"Exercice 1‚Äã","type":1,"pageTitle":"sorting","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-1","content":"Dans cet exercice, vous devez √©crire une fonction qui prend en param√®tre un tableau d'entiers (std::vector) et le trie par ordre croissant. Vous avez le choix entre deux algorithmes de tri: tri √† bulletri par s√©lection ","version":"Next","tagName":"h2"},{"title":"Exercice 2 (tri r√©cursif)‚Äã","type":1,"pageTitle":"sorting","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-2-tri-r√©cursif","content":"De nouveau, vous devez √©crire une fonction qui prend en param√®tre un tableau d'entiers (std::vector) et le trie par ordre croissant. Cette fois-ci, vous devez utiliser un algorithme de tri r√©cursif. Vous avez le choix entre deux algorithmes de tri: tri fusiontri rapide ","version":"Next","tagName":"h2"},{"title":"Comparaison des algorithmes de tri‚Äã","type":1,"pageTitle":"sorting","url":"/Learn--cpp_programming/TDs/S2/sorting#comparaison-des-algorithmes-de-tri","content":"Une fois nos algorithmes de tri impl√©ment√©s, nous allons les comparer en terme de complexit√© temporelle. Je vous fournis une fonction qui permet de g√©n√©rer un tableau d'entiers al√©atoires. #include &lt;vector&gt; #include &lt;cstdlib&gt; std::vector&lt;int&gt; generateRandomArray(size_t size, int max) { std::vector&lt;int&gt; array; for (size_t i {0}; i &lt; size; i++) { array.push_back(std::rand() % max); } return array; }  Je vous fournis √©galement une structure chronom√®tre, il suffit de copier le fichier ScopedTimer.hpp dans le dossier de votre projet et de l'inclure dans votre fichier source: #include &quot;ScopedTimer.hpp&quot;  Elle fonctionne de la mani√®re suivante: { ScopedTimer timer(&quot;nom du chronom√®tre&quot;); // code √† chronom√©trer }  Il affichera le temps √©coul√© entre sa cr√©ation et sa destruction(c'est √† dire √† la fin du bloc de code, c'est pourquoi il est d√©clar√© dans un bloc entre accolades (Scope)). ","version":"Next","tagName":"h2"},{"title":"biblioth√®que standard‚Äã","type":1,"pageTitle":"sorting","url":"/Learn--cpp_programming/TDs/S2/sorting#biblioth√®que-standard","content":"La biblioth√®que standard de C++ fournit une fonction de tri std::sort qui permet de trier des conteneurs (incluse dans la biblioth√®que &lt;algorithm&gt;) Vous pouvez l'utiliser de la mani√®re suivante: std::vector&lt;int&gt; array {1, 2, 3, 4, 5, 6, 7, 8, 9}; std::sort(array.begin(), array.end());  remarque begin et end sont des m√©thodes de std::vector qui permettent de r√©cup√©rer des it√©rateurs sur le d√©but et la fin du conteneur. Nous verrons les it√©rateurs plus tard dans le cours. Avec cette fonction, vous pouvez comparer les temps d'ex√©cution de vos algorithmes de tri avec celui de la biblioth√®que standard. Que constatez-vous ?Que pouvez-vous en dire ? ","version":"Next","tagName":"h3"},{"title":"Exercice 3 (dichotomie)‚Äã","type":1,"pageTitle":"sorting","url":"/Learn--cpp_programming/TDs/S2/sorting#exercice-3-dichotomie","content":"√âcrire une fonction search qui prend en param√®tre un tableau d'entiers (std::vector) tri√© par ordre croissant et une valeur enti√®re et retourne l'indice de la valeur dans le tableau. Si la valeur n'est pas pr√©sente dans le tableau, la fonction retournera -1. la fonction devra utiliser l'algorithme de recherche dichotomique. astuce On utilisera deux indices pour d√©finir la partie du tableau √† traiter: left : indice du premier √©l√©ment de la partie du tableau √† traiterright : indice du dernier √©l√©ment de la partie du tableau √† traiter Exemple simple avec le tableau suivant [1, 2, 2, 3, 4, 8, 12] (nombre d'√©l√©ments: 7) et la valeur recherch√©e 8: left = 0 et right = 6 (indice du premier et dernier √©l√©ment du tableau)middle = (left + right) / 2 = (0 + 6) / 2 = 3 (indice de l'√©l√©ment au milieu du tableau) la valeur au milieu du tableau est 3 qui est inf√©rieure √† la valeur recherch√©e 8, on ne garde que la partie droite du tableau.left devient middle + 1 = 3 + 1 = 4 (indice du premier √©l√©ment de la partie droite du tableau)left = 4 et right = 6middle = (left + right) / 2 = (4 + 6) / 2 = 5la valeur au milieu du tableau est 8 qui est √©gale √† la valeur recherch√©e, on retourne l'indice 5 de la valeur dans le tableau. tester la fonction search avec les tableaux suivants et afficher le r√©sultat de la recherche: [1, 2, 2, 3, 4, 8, 12] (valeur recherch√©e: 8)[1, 2, 3, 3, 6, 14, 12, 15] (valeur recherch√©e: 15)[2, 2, 3, 4, 5, 8, 12, 15, 16] (valeur recherch√©e: 16)[5, 6, 7, 8, 9, 10, 11, 12, 13] (valeur recherch√©e: 6)[1, 2, 3, 4, 5, 6, 7, 8, 9] (valeur recherch√©e: 10) ","version":"Next","tagName":"h2"}]