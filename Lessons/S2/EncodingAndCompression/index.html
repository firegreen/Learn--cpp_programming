<!doctype html>
<html lang="fr" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Lessons/S2/EncodingAndCompression" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Compression et encodage de données | Cours de programmation C++</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/EncodingAndCompression"><meta data-rh="true" name="docusaurus_locale" content="fr"><meta data-rh="true" name="docsearch:language" content="fr"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Compression et encodage de données | Cours de programmation C++"><meta data-rh="true" name="description" content="La compression de données est un domaine très vaste et très important en informatique. Il existe de nombreuses techniques de compression, qui sont utilisées dans de nombreux domaines : compression d&#x27;images, compression de vidéos, compression de fichiers, etc."><meta data-rh="true" property="og:description" content="La compression de données est un domaine très vaste et très important en informatique. Il existe de nombreuses techniques de compression, qui sont utilisées dans de nombreux domaines : compression d&#x27;images, compression de vidéos, compression de fichiers, etc."><link data-rh="true" rel="icon" href="/Learn--cpp_programming/imgs/favicon.ico"><link data-rh="true" rel="canonical" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/EncodingAndCompression"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/EncodingAndCompression" hreflang="fr"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/EncodingAndCompression" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"><link rel="stylesheet" href="/Learn--cpp_programming/assets/css/styles.f79f2d5c.css">
<link rel="preload" href="/Learn--cpp_programming/assets/js/runtime~main.41a2ce15.js" as="script">
<link rel="preload" href="/Learn--cpp_programming/assets/js/main.b6acc1cb.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
 <div role="region" aria-label="Aller au contenu principal"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Aller au contenu principal</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Ouvrir/fermer la barre de navigation" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Learn--cpp_programming/"><div class="navbar__logo"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Learn--cpp_programming/Lessons">Cours</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/TDs">TDs</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Annexes">Annexes</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Sources">Sources</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-label="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Retour au début de la page" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><main class="docMainContainer_gTbr docMainContainerEnhanced_Uz_u"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">Sur cette page</button></div><div class="theme-doc-markdown markdown"><header><h1>Compression et encodage de données</h1></header><p>La compression de données est un domaine très vaste et très important en informatique. Il existe de nombreuses techniques de compression, qui sont utilisées dans de nombreux domaines : compression d&#x27;<strong>images</strong>, compression de <strong>vidéos</strong>, compression de <strong>fichiers</strong>, etc.</p><p>Dans ce cours nous allons voir découvrir des techniques de compression très répandue : </p><ul><li>Le codage par plages (ou <strong>run-length encoding</strong>)</li><li>le <strong>codage de Huffman</strong></li></ul><p>Nous allons voir comment ils fonctionnent, et comment les implémenter en C++.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="compression-de-données">Compression de données<a href="#compression-de-données" class="hash-link" aria-label="Lien direct vers Compression de données" title="Lien direct vers Compression de données">​</a></h2><p>La compression de données est une technique qui permet de réduire la taille des données. Cela permet de stocker plus de données sur un support de stockage, ou de transmettre les données plus rapidement sur un réseau.</p><p>C&#x27;est un domaine crucial en informatique moderne. Sans la compression de données, il serait impossible de stocker des milliers de photos sur un téléphone portable, ou de regarder des vidéos en streaming sur Internet.</p><p>Il existe deux types de compression de données : la compression <strong>avec perte</strong> et la compression <strong>sans perte</strong>. La compression avec perte permet de réduire la taille des données, mais on ne garanti pas que les données décompressées seront identiques aux données d&#x27;origine. C&#x27;est le cas par exemple de la compression d&#x27;images au format <strong>JPEG</strong> où la perte de qualité est relativement maîtriser pour cela soit le moins perceptible par l&#x27;oeil humain. La compression sans perte permet de retrouver les données d&#x27;origine après les avoir décompressées. C&#x27;est le cas par exemple de la compression d&#x27;images au format <strong>PNG</strong>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="prérequis">Prérequis<a href="#prérequis" class="hash-link" aria-label="Lien direct vers Prérequis" title="Lien direct vers Prérequis">​</a></h2><p>Pour ce cours, il est nécessaire de connaître quelques notions de base sur la représentation des données en informatique. Voici un résumé des notions à connaître :</p><ul><li><p>Un <strong>bit</strong> est la plus petite unité de stockage en informatique. Il ne peut prendre que deux valeurs : 0 ou 1. Un <strong>octet</strong> est un groupe de <strong>8 bits</strong>. Il peut donc prendre 256 valeurs différentes (de 0 à 255).</p></li><li><p>Chaque <strong>donnée</strong> peut être représentée par une <strong>suite de bits.</strong> Par exemple, le nombre 42 peut être représenté en binaire par la suite de bits <code>101010</code>. Avec un octet, on peut représenter au maximum 256 nombres différents.</p></li><li><p>Un <strong>caractère</strong> est généralement codé sur un octet (cela peut dépendre de l&#x27;encodage utilisé). Cela signifie que l&#x27;on peut représenter 256 caractères différents. Cela inclut les <strong>lettres</strong> de l&#x27;alphabet, les <strong>chiffres</strong>, les caractères spéciaux, etc.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="encodage-et-représentation-des-données">Encodage et représentation des données<a href="#encodage-et-représentation-des-données" class="hash-link" aria-label="Lien direct vers Encodage et représentation des données" title="Lien direct vers Encodage et représentation des données">​</a></h2><p>Un encodage est une manière de représenter les données. Par exemple, on peut représenter le nombre 42 de la manière suivante : <code>101010</code>. C&#x27;est un encodage <strong>binaire</strong>. On peut aussi représenter le nombre 42 de la manière suivante : <code>2A</code>. C&#x27;est un encodage hexadécimal. </p><p>Encoder des données revient à associer à chaque donnée un <strong>code</strong>.</p><p>Dans la suite de ce cours nous allons nous intéresser à l&#x27;encodage binaire. C&#x27;est l&#x27;encodage utilisé par les ordinateurs et qui permet de représenter les données de manière la plus compacte possible. C&#x27;est aussi l&#x27;encodage utilisé par les algorithmes de compression.</p><hr><p>Dans un fichier texte, chaque lettre est représentée par un <strong>caractère</strong>. Ce caractère est généralement encodé sur un <strong>octet</strong>. Cela signifie que l&#x27;on peut représenter 256 caractères différents. Cela inclut les lettres de l&#x27;alphabet, les chiffres, les caractères spéciaux, etc.</p><p>Mais cela dépend des données du problèmes. Cet encodage sur un octet est simplement une convention. Qui permet d&#x27;associer à chaque caractère un code unique et d&#x27;uniformiser la manière dont les caractères sont représentées (chaque caractère est représenté par un octet). C&#x27;est bien pratique et flexible pour communiquer des fichiers texte entre ordinateurs.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="compression">Compression<a href="#compression" class="hash-link" aria-label="Lien direct vers Compression" title="Lien direct vers Compression">​</a></h3><p>Mais généralement lorsqu&#x27;il s&#x27;agit de compresser des données, les données du problème sont plus <strong>simples</strong>. Par exemple on pourrait se limiter aux <strong>lettres de l&#x27;alphabet</strong>. Dans ce cas, avoir un octet pour représenter chaque lettre est une perte d&#x27;espace. En effet, on pourrait se contenter de 5 bits pour représenter les 26 lettres de l&#x27;alphabet. Cela permettrait de réduire la taille du texte de 37.5% !</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>Plus généralement, si on se limite à <code>n</code> possibilités de données et que l&#x27;on souhaite utiliser un encodage avec le même nombre de bits pour chaque donnée, il faut <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil \log_2(n) \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)⌉</span></span></span></span> bits pour représenter chaque donnée.
Par exemple, si on se limite aux <strong>26</strong> lettres de l&#x27;alphabet, il faut <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mn>26</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo><mo>=</mo><mo stretchy="false">⌈</mo><mn>4.7</mn><mo stretchy="false">⌉</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">\lceil \log_2(26) \rceil = \lceil 4.7 \rceil = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">⌈</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">26</span><span class="mclose">)⌉</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">⌈</span><span class="mord">4.7</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">5</span></span></span></span> bits pour représenter chaque lettre.</p></div></div><p>De plus pour n&#x27;importe quel façon d&#x27;encoder les données, il faut respecter deux règles pour que l&#x27;encodage puisse être décodé :</p><ul><li>Chaque donnée doit être associée à un code <strong>unique</strong></li><li>Il ne doit pas y avoir d&#x27;<strong>ambiguïté</strong> lors du décodage des données. Cela signifie qu&#x27;il ne faut pas associer à une donnée le code <code>01</code> et à une autre donnée le code <code>011</code> sinon impossible de savoir si l&#x27;on doit décoder les deux premiers bits <code>01</code> ou si cela faisait en fait partie du code <code>011</code>. Les codes qui ont cette propriété sont appelés <strong>non préfixes</strong>,  nous y reviendrons plus tard.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="codage-par-plages-run-length-encoding">Codage par plages (Run-Length Encoding)<a href="#codage-par-plages-run-length-encoding" class="hash-link" aria-label="Lien direct vers Codage par plages (Run-Length Encoding)" title="Lien direct vers Codage par plages (Run-Length Encoding)">​</a></h2><p>Le codage par plages est une technique de compression <strong>sans perte</strong>. Cela signifie que l&#x27;on peut retrouver les données d&#x27;origine après les avoir décompressées. Elle est très utilisée pour compresser des images, comme par exemple les images au format <strong>BMP</strong> ou <strong>JPEG</strong>.</p><p>Le principe du codage par plages est de tenir compte de la <strong>répétition</strong> des données. Admettons que l&#x27;on ait un texte de 8 caractères, composé uniquement de la lettre <code>a</code> : <code>aaaaaaaa</code>.
Si l&#x27;on veut stocker ce texte sur un support de stockage, il faudra donc <strong>8 octets</strong> pour le stocker (1 octet par caractère).</p><p>Mais si l&#x27;on tient compte du fait que le texte est composé uniquement de la lettre <code>a</code>, on peut le représenter de la manière suivante : <code>8a</code>.</p><p>On peut donc stocker ce texte sur un support de stockage en utilisant seulement 2 octets. Cela permet de réduire la taille du texte de 75% !</p><p>C&#x27;est le principe du codage par plages : on remplace une suite de caractères identiques par le nombre de fois que le caractère est répété, suivi du caractère. Par exemple, le texte suivant <code>aaaabbbcddddd</code> peut être représenté par <code>4a3b1c5d</code>. Pour un gain de 13-8=5 octets, soit 38% de gain.</p><p>⚠️ Quand il y a peu de répétitions cependant le codage par plages peut augmenter la taille des données. Par exemple, Si on applique le codage par plage sur le texte suivant <code>abcdefgh</code> on obtient <code>1a1b1c1d1e1f1g1h</code>. Cela prend plus de place que la chaîne d&#x27;origine !
Dans ce cas de figure, pour minimiser cet effet, on choisi plutôt d&#x27;ajouter un <strong>caractère de contrôle</strong> et un nombre <code>n</code> pour indiquer que les <code>n</code> prochains caractères ne sont pas compressés. Par exemple, on pourrait utiliser le caractère <code>*</code> comme caractère de contrôle et la chaîne <code>abcdefgh</code> serait compressée en <code>*8abcdefgh</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="en-pratique">En pratique<a href="#en-pratique" class="hash-link" aria-label="Lien direct vers En pratique" title="Lien direct vers En pratique">​</a></h3><p>L&#x27;encodage <strong>RLE</strong> peut être exprimé de multiples façons en pratique pour tenir compte des propriétés des données ainsi que d&#x27;algorithmes de compression supplémentaires. Cela permet de compresser les données seulement lorsque cela est nécessaire et de laisser la chaîne telle quelle lorsque la compression induit un gaspillage.</p><p>Par exemple on pourrait se donner les règles suivantes :</p><ul><li>Lorsque trois éléments ou plus se répètent consécutivement alors la méthode de compression RLE est utilisée. On insère alors le nombre d&#x27;éléments répétés, suivi du caractère répété.</li><li>Sinon un caractère de contrôle (*) est inséré, suivi du nombre d&#x27;éléments de la chaîne non compressée puis de cette dernière.</li></ul><p>Ainsi la chaîne <code>aaaabccdeeeeefgh</code> serait compressée en <code>4a*bccd5e*fgh</code> et la chaîne <code>abcdefgh</code> serait compressée en <code>0abcdefgh</code>.</p><p>On pourrait aussi plutôt se dire que l&#x27;on utilise le caractère de contrôle pour indiquer que la chaîne est compressée. Dans ce cas, la chaîne <code>aaaabccdeeeeefgh</code> serait compressée en <code>*4abccd*5efgh</code>.</p><p>Enfin on pourrait aussi se dire que l&#x27;on utilise le caractère lui même comme caractère de contrôle. de sorte que chaque fois qu&#x27;un caractère apparaît deux fois, il indique une longueur d&#x27;exécution. Dans l&#x27;exemple précédent, cela donnerait pour la chaîne <code>aaaabccdeeeeefgh</code> l&#x27;encodage <code>aa4bcc1dee5fgh</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dans-les-images">Dans les images<a href="#dans-les-images" class="hash-link" aria-label="Lien direct vers Dans les images" title="Lien direct vers Dans les images">​</a></h3><p>Dans les images il est courant de trouver des zones de couleurs uniformes. Par exemple, une image de ciel bleu peut être représentée par une suite de pixels bleus. Dans ce cas, le codage par plages permet de réduire considérablement la taille de l&#x27;image.</p><p>Il existe donc des variantes pour parcourir les pixels d&#x27;une image dans un certains sens pour maximiser les zones de couleurs uniformes (ou de valeurs identiques). Par exemple, on peut parcourir les pixels de gauche à droite, de haut en bas. On peut aussi parcourir les pixels de gauche à droite, de bas en haut ou même encore en zigzag.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="codage-de-huffman">Codage de Huffman<a href="#codage-de-huffman" class="hash-link" aria-label="Lien direct vers Codage de Huffman" title="Lien direct vers Codage de Huffman">​</a></h2><p>Le codage de Huffman est aussi une technique de compression <strong>sans perte</strong>. C&#x27;est une technique très utilisée pour compresser des fichiers, comme par exemple des fichiers texte. Cette technique est utilisée par de nombreux formats de fichiers, comme par exemple le format <strong>JPEG</strong> pour les images.</p><p>Par exemple, si on se limite aux quatre lettres <code>a</code>, <code>b</code>, <code>c</code> et <code>d</code> (on a donc besoin seulement de 2 bits pour coder chaque lettre
).
Voilà un encodage possible :</p><ul><li><code>a</code> est codé sur <code>00</code></li><li><code>b</code> est codé sur <code>01</code></li><li><code>c</code> est codé sur <code>10</code></li><li><code>d</code> est codé sur <code>11</code></li></ul><p>Le texte <code>abbacada</code> peut donc être représenté par <code>0001010010001100</code>.
C&#x27;est déjà mieux que l&#x27;encodage ASCII, qui utilise 8 bits pour coder chaque lettre. On se limite à des données particulières, et on utilise un encodage plus compact.</p><p>Mais on peut faire mieux !</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="fréquence-dapparition-des-données">Fréquence d&#x27;apparition des données<a href="#fréquence-dapparition-des-données" class="hash-link" aria-label="Lien direct vers Fréquence d&#x27;apparition des données" title="Lien direct vers Fréquence d&#x27;apparition des données">​</a></h3><p>Le principe du codage de Huffman est de tenir compte de la <strong>fréquence d&#x27;apparition</strong> des données.</p><p>Pour un texte composé de 100 caractères (toujours avec notre alphabet de 4 lettres) il faudra donc 200 bits pour le représenter.</p><p>Dans le cas de notre exemple précédent <code>abbacada</code>, on peut remarquer que la lettre <code>a</code> apparaît <strong>4</strong> fois, la lettre <code>b</code> apparaît <strong>2</strong> fois et les lettres <code>c</code> et <code>d</code> apparaissent <strong>1</strong> fois. On peut donc se demander si l&#x27;on ne pourrait pas utiliser un encodage différent pour chaque lettre, en tenant compte de la fréquence d&#x27;apparition de chaque lettre. Cela permettrait de réduire la taille du texte.</p><p>on pourrait donc utiliser moins d&#x27;un octet pour coder les lettres les plus utilisées, et plus d&#x27;un octet pour coder les lettres les moins utilisées. Cela permettrait de réduire la taille du texte.</p><p>Admettons que l&#x27;on code les lettres de la manière suivante :</p><ul><li><code>a</code> est codé sur <code>0</code></li><li><code>b</code> est codé sur <code>10</code></li><li><code>c</code> est codé sur <code>110</code></li><li><code>d</code> est codé sur <code>111</code></li></ul><p>Le texte <code>abbacada</code> peut donc être représenté par <code>01010011001110</code> (soit 14 bits). C&#x27;est mieux que l&#x27;encodage précédent, qui utilisait 16 bits.</p><p>Mais comment faire pour trouver le meilleur encodage possible ?</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="arbre-binaire">Arbre binaire<a href="#arbre-binaire" class="hash-link" aria-label="Lien direct vers Arbre binaire" title="Lien direct vers Arbre binaire">​</a></h3><p>Dans la suite de ce cours, nous allons utiliser un <strong>arbre binaire</strong> (complet) pour trouver l&#x27;encodage de Huffman (en fonction de la fréquence d&#x27;apparition des données). Mais j&#x27;aimerai d&#x27;abord vous expliquer pourquoi on utilise un arbre binaire.</p><p>Dans un arbre binaire complet, chaque <strong>noeud</strong> possède <strong>deux fils</strong>. Chaque feuille de l&#x27;arbre va permettre de représenter une donnée. Par exemple, on peut représenter les lettres <code>a</code>, <code>b</code>, <code>c</code> et <code>d</code> de la manière suivante :</p><p>Une propriété intéressante des arbres binaires est que pour chaque feuille il existe un <strong>chemin unique</strong> de la racine à la feuille. Ce chemin va permettre d&#x27;associer un code à chaque donnée. En plus d&#x27;être unique, ce chemin est aussi <strong>préfixe</strong>. Cela signifie que l&#x27;on ne peut pas avoir un chemin qui est préfixe d&#x27;un autre chemin.</p><p>Reprenons notre exemple précédent avec les lettres <code>a</code>, <code>b</code>, <code>c</code> et <code>d</code>. Admettons que les quatre lettres apparaissent avec la même fréquence. </p><p>Dans cet arbre, si l&#x27;on parcourt le chemin <code>0-0</code> (successivement le fils gauche puis le fils gauche), on arrive à la lettre <code>a</code>. De même pour les autres feuillets. On peut donc associer à chaque lettre un code unique :</p><ul><li><code>a</code> est codé sur <code>00</code></li><li><code>b</code> est codé sur <code>01</code></li><li><code>c</code> est codé sur <code>10</code></li><li><code>d</code> est codé sur <code>11</code></li></ul><p>On retrouve bien l&#x27;encodage que l&#x27;on avait utilisé précédemment dans le cas de données équiprobables.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="algorithme">Algorithme<a href="#algorithme" class="hash-link" aria-label="Lien direct vers Algorithme" title="Lien direct vers Algorithme">​</a></h3><p>Revenons maintenant à notre cas avec des données non équiprobables. Admettons que l&#x27;on ait le texte suivant : <code>abbacada</code>. On peut calculer la fréquence d&#x27;apparition de chaque lettre :</p><table><thead><tr><th>Lettre</th><th>Fréquence</th></tr></thead><tbody><tr><td>a</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">4/8 = 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">4/8</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.5</span></span></span></span></td></tr><tr><td>b</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>0.25</mn></mrow><annotation encoding="application/x-tex">2/8 = 0.25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">2/8</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.25</span></span></span></span></td></tr><tr><td>c</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>0.125</mn></mrow><annotation encoding="application/x-tex">1/8 = 0.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1/8</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.125</span></span></span></span></td></tr><tr><td>d</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>0.125</mn></mrow><annotation encoding="application/x-tex">1/8 = 0.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1/8</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0.125</span></span></span></span></td></tr></tbody></table><p>On peut remarquer qu&#x27;ne utilisant une représentation en arbre binaire complet, les lettres les <strong>moins fréquentes</strong> seront codées sur des codes plus gros (chemins les plus longs dans l&#x27;arbre) et donc sur les feuilles les plus basses de l&#x27;arbre. Les lettres les <strong>plus fréquentes</strong> seront codées sur des codes plus petits (chemins les plus courts dans l&#x27;arbre) et donc sur les feuilles les plus hautes de l&#x27;arbre.</p><hr><p>C&#x27;est donc en suivant cette logique que l&#x27;on va construire l&#x27;arbre binaire. On va commencer par construire un arbre binaire avec les lettres les moins fréquentes.</p><p>On va donc commencer par construire un arbre binaire avec les lettres <code>c</code> et <code>d</code>. On va donc créer un noeud <code>cd</code> qui va avoir deux fils <code>c</code> et <code>d</code>. On va associer à chaque noeud la somme des fréquences de ses fils. On va donc associer à <code>cd</code> la fréquence <code>0.125 + 0.125 = 0.25</code>.</p><p>On va considérer maintenant que <code>cd</code> est un substitut aux lettres <code>c</code> et <code>d</code> et représente donc une seule donnée avec un fréquence de <code>0.25</code>.</p><p>Je vais appelé ce regroupement de données un <strong>symbole</strong>. Un symbole est donc une donnée qui peut être composée de plusieurs données. Par exemple, le symbole <code>cd</code> est composé des données <code>c</code> et <code>d</code>.</p><p>On va donc construire un arbre binaire avec les lettres <code>b</code> et <code>cd</code> (qui sont les deux symboles les moins fréquents parmi <code>a</code>, <code>b</code> et <code>cd</code>). On va donc créer un noeud <code>bcd</code> qui va avoir deux fils <code>b</code> et <code>cd</code>.</p><p>En répétant cette opération, on va finir par n&#x27;avoir plus que deux symboles : <code>a</code> et <code>bcd</code>. Cela va conduire à créer l&#x27;arbre final qui contient tous les lettres initiales.</p><p>Cela nous donne finalement l&#x27;arbre suivant:</p><p>Ce qui peux se traduire par l&#x27;encodage suivant :</p><ul><li><code>a</code>: <code>0</code></li><li><code>b</code>: <code>10</code></li><li><code>c</code>: <code>110</code></li><li><code>d</code>: <code>111</code></li></ul><p>On retrouve bien l&#x27;encodage que j&#x27;avais proposé précédemment.</p><p>Mathématiquement, on peut démontrer que l&#x27;encodage de Huffman est optimal. Cela signifie que l&#x27;encodage de Huffman permet de compresser les données de manière optimale.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="résumé">Résumé<a href="#résumé" class="hash-link" aria-label="Lien direct vers Résumé" title="Lien direct vers Résumé">​</a></h2><ul><li>La compression de données permet de réduire la taille des données. Cela permet de stocker plus de données sur un support de stockage, ou de transmettre les données plus rapidement sur un réseau.</li><li>Il existe deux types de compression de données : la compression <strong>avec perte</strong> et la compression <strong>sans perte</strong>.</li><li>L&#x27;encodage est le fait d&#x27;associer à chaque donnée un <strong>code</strong>.</li><li>Le codage par plages (<strong>RLE</strong>) est une technique de compression <strong>sans perte</strong> et consiste à remplacer une suite de caractères identiques par le nombre de fois que le caractère est répété, suivi du caractère.</li><li>Le codage de Huffman est une technique de compression <strong>sans perte</strong> et consiste à tenir compte de la <strong>fréquence d&#x27;apparition</strong> des données. Chaque donnée est associée à un code <strong>unique</strong> et <strong>préfixe</strong>. L&#x27;encodage de Huffman est optimal. On peut construire l&#x27;encodage de Huffman en utilisant un arbre binaire complet.</li><li>Un code préfixe est un code dans lequel aucun code n&#x27;est préfixe d&#x27;un autre code. Cela permet de décoder les données sans ambiguïté.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sources">Sources<a href="#sources" class="hash-link" aria-label="Lien direct vers Sources" title="Lien direct vers Sources">​</a></h2><ul><li>Super vidéo sur la théorie de l&#x27;information et l&#x27;encodage de Huffman : <a href="https://www.youtube.com/watch?v=B3y0RsVCyrw" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=B3y0RsVCyrw</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags :</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/Learn--cpp_programming/tags/c">C++</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Pages de documentation"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#compression-de-données" class="table-of-contents__link toc-highlight">Compression de données</a></li><li><a href="#prérequis" class="table-of-contents__link toc-highlight">Prérequis</a></li><li><a href="#encodage-et-représentation-des-données" class="table-of-contents__link toc-highlight">Encodage et représentation des données</a><ul><li><a href="#compression" class="table-of-contents__link toc-highlight">Compression</a></li></ul></li><li><a href="#codage-par-plages-run-length-encoding" class="table-of-contents__link toc-highlight">Codage par plages (Run-Length Encoding)</a><ul><li><a href="#en-pratique" class="table-of-contents__link toc-highlight">En pratique</a></li><li><a href="#dans-les-images" class="table-of-contents__link toc-highlight">Dans les images</a></li></ul></li><li><a href="#codage-de-huffman" class="table-of-contents__link toc-highlight">Codage de Huffman</a><ul><li><a href="#fréquence-dapparition-des-données" class="table-of-contents__link toc-highlight">Fréquence d&#39;apparition des données</a></li><li><a href="#arbre-binaire" class="table-of-contents__link toc-highlight">Arbre binaire</a></li><li><a href="#algorithme" class="table-of-contents__link toc-highlight">Algorithme</a></li></ul></li><li><a href="#résumé" class="table-of-contents__link toc-highlight">Résumé</a></li><li><a href="#sources" class="table-of-contents__link toc-highlight">Sources</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><span class="footer__link-item">
              <a href="https://discord.com/users/264442459759706112" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/discord.svg"> Discord
              </a>
              </span><span class="footer__link-separator">·</span><a href="mailto:desmet.enguerrand@gmail.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">E-Mail</a><span class="footer__link-separator">·</span><span class="footer__link-item">
              <a href="https://github.com/dsmtE" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/github-dark.svg"> GitHub
              </a>
              </span></div></div><div class="footer__bottom text--center"><div class="footer__copyright">These lessons were written by <a href="https://github.com/dsmtE">DE SMET Enguerrand</a>.<br>Copyright © 2023. Built with <a href="https://docusaurus.io/">Docusaurus</a>.</div></div></div></footer> </div>
<script src="/Learn--cpp_programming/assets/js/runtime~main.41a2ce15.js"></script>
<script src="/Learn--cpp_programming/assets/js/main.b6acc1cb.js"></script>
</body>
</html>