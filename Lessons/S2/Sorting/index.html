<!doctype html>
<html lang="fr" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Lessons/S2/Sorting" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Algorithmes de tri, complexité et recherche dichotomique | Cours de programmation C++</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/Sorting"><meta data-rh="true" name="docusaurus_locale" content="fr"><meta data-rh="true" name="docsearch:language" content="fr"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Algorithmes de tri, complexité et recherche dichotomique | Cours de programmation C++"><meta data-rh="true" name="description" content="Les algorithmes de tri sont des algorithmes qui permettent de trier des données. Ils sont très utilisés en informatique, et il en existe de nombreux. Dans ce cours, nous allons voir les plus connus pour comprendre leur fonctionnement et leur intérêt."><meta data-rh="true" property="og:description" content="Les algorithmes de tri sont des algorithmes qui permettent de trier des données. Ils sont très utilisés en informatique, et il en existe de nombreux. Dans ce cours, nous allons voir les plus connus pour comprendre leur fonctionnement et leur intérêt."><link data-rh="true" rel="icon" href="/Learn--cpp_programming/imgs/favicon.ico"><link data-rh="true" rel="canonical" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/Sorting"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/Sorting" hreflang="fr"><link data-rh="true" rel="alternate" href="https://dsmte.github.io/Learn--cpp_programming/Lessons/S2/Sorting" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"><link rel="stylesheet" href="/Learn--cpp_programming/assets/css/styles.f79f2d5c.css">
<link rel="preload" href="/Learn--cpp_programming/assets/js/runtime~main.90eb01f1.js" as="script">
<link rel="preload" href="/Learn--cpp_programming/assets/js/main.be813725.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
 <div role="region" aria-label="Aller au contenu principal"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Aller au contenu principal</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Ouvrir/fermer la barre de navigation" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Learn--cpp_programming/"><div class="navbar__logo"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/Learn--cpp_programming/imgs/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/Learn--cpp_programming/Lessons">Cours</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/TDs">TDs</a><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Annexes">Annexes</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/Learn--cpp_programming/Sources">Sources</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-label="Basculer entre le mode sombre et clair (actuellement mode clair)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Retour au début de la page" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><main class="docMainContainer_gTbr docMainContainerEnhanced_Uz_u"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">Sur cette page</button></div><div class="theme-doc-markdown markdown"><header><h1>Algorithmes de tri, complexité et recherche dichotomique</h1></header><p>Les algorithmes de tri sont des algorithmes qui permettent de <strong>trier des données</strong>. Ils sont très utilisés en informatique, et il en existe de nombreux. Dans ce cours, nous allons voir les plus connus pour comprendre leur fonctionnement et leur intérêt.</p><p>Comment trier un tableau de nombres ? C&#x27;est une question qui peut paraître simple, mais qui est en fait assez complexe. Il existe de nombreux algorithmes de tri, et chacun a ses avantages et ses inconvénients.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tri-par-comparaison">Tri par comparaison<a href="#tri-par-comparaison" class="hash-link" aria-label="Lien direct vers Tri par comparaison" title="Lien direct vers Tri par comparaison">​</a></h2><p>Les premiers algorithmes de tri que nous allons voir sont des algorithmes de tri par <strong>comparaison</strong> (Comparison based strategies).</p><p>Ils consistent à <strong>comparer</strong> deux à deux les éléments du tableau puis de les <strong>échanger</strong> ou non en fonction du résultat de la comparaison.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tri-par-sélection-selection-sort">Tri par sélection (selection sort)<a href="#tri-par-sélection-selection-sort" class="hash-link" aria-label="Lien direct vers Tri par sélection (selection sort)" title="Lien direct vers Tri par sélection (selection sort)">​</a></h3><p>L&#x27;algorithme de tri par sélection est un algorithme de tri qui consiste à trouver le plus petit élément du tableau, et à le placer en première position (ou le plus grand élément en dernière position). On répète cette opération jusqu&#x27;à ce que le tableau soit trié.</p><p>Un exemple, avec le tableau suivant <code>[6, 2, 8, 1, 5, 3, 9]</code>:</p><ol><li><p>On, parcourt le tableau pour trouver le plus petit élément qui est <code>1</code>.</p><p>Son indice est <code>3</code>, on l&#x27;échange avec l&#x27;élément à l&#x27;indice <code>0</code> (le premier élément du tableau).</p><div style="display:flex;justify-content:center"><table><tbody><tr><td style="font-weight:bold">1</td><td style="font-weight:normal">2</td><td style="font-weight:normal">8</td><td style="font-weight:bold">6</td><td style="font-weight:normal">5</td><td style="font-weight:normal">3</td><td style="font-weight:normal">9</td></tr></tbody></table></div><p>Le premier élément du tableau est désormais le plus petit élément du tableau. On recommence l&#x27;opération, mais en ignorant le premier élément du tableau, car il est déjà trié.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>Toute l&#x27;astuce de cet algorithme est donc de trier un sous-tableau plus petit à chaque itération jusqu&#x27;à ce que le tableau soit trié.</p></div></div></li></ol><p>Voilà les itérations suivantes:</p><ol><li>Le deuxième plus petit élément est <code>2</code>, il est déjà à la bonne place, on ne fait rien.</li><li><div style="display:flex;justify-content:center"><table><tbody><tr><td style="font-weight:normal">1</td><td style="font-weight:normal">2</td><td style="font-weight:bold">3</td><td style="font-weight:normal">6</td><td style="font-weight:normal">5</td><td style="font-weight:bold">8</td><td style="font-weight:normal">9</td></tr></tbody></table></div></li><li><div style="display:flex;justify-content:center"><table><tbody><tr><td style="font-weight:normal">1</td><td style="font-weight:normal">2</td><td style="font-weight:normal">3</td><td style="font-weight:bold">5</td><td style="font-weight:bold">6</td><td style="font-weight:normal">8</td><td style="font-weight:normal">9</td></tr></tbody></table></div></li><li>Il reste trois éléments à trier (<code>[6, 8, 9]</code>), il sont déjà triés, on ne fait rien.</li></ol><p>Voilà, le tableau est trié.</p><p>Je t&#x27;invite à regarder le fonctionnement de cet algorithme sur <a href="https://www.toptal.com/developers/sorting-algorithms/selection-sort" target="_blank" rel="noopener noreferrer">cette animation</a> ou encore <a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener noreferrer">ici</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tri-à-bulles-bubble-sort">Tri à bulles (bubble sort)<a href="#tri-à-bulles-bubble-sort" class="hash-link" aria-label="Lien direct vers Tri à bulles (bubble sort)" title="Lien direct vers Tri à bulles (bubble sort)">​</a></h3><p>Le tri à bulles est un autre algorithme de tri très connu.
Il consiste à <strong>comparer</strong> deux à deux les éléments du tableau, et à les échanger si ils ne sont pas dans le bon ordre. On répète cette opération jusqu&#x27;à ce que le tableau soit trié.</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>remarque</div><div class="admonitionContent_S0QG"><p>Cela va avoir pour effet de faire &quot;<strong>remonter</strong>&quot; les plus grands éléments du tableau vers la fin du tableau, comme des bulles d&#x27;air qui remontent à la surface.</p></div></div><p>Un exemple, avec le même tableau <code>[6, 2, 8, 1, 5, 3, 9]</code>:</p><ol><li><p>On compare les deux premiers éléments du tableau, <code>6</code> et <code>2</code>. Comme <code>6</code> est plus grand que <code>2</code>, on les échange.</p><div style="display:flex;justify-content:center"><table><tbody><tr><td style="font-weight:bold">2</td><td style="font-weight:bold">6</td><td style="font-weight:normal">8</td><td style="font-weight:normal">1</td><td style="font-weight:normal">5</td><td style="font-weight:normal">3</td><td style="font-weight:normal">9</td></tr></tbody></table></div></li></ol><p>On recommence l&#x27;opération avec les deux éléments suivants, <code>6</code> et <code>8</code>. Comme <code>6</code> est plus petit que <code>8</code>, on ne fait rien.
On procède ainsi jusqu&#x27;à la fin du tableau.</p><p>On obtient après un premier passage sur l&#x27;ensemble du tableau:</p><div style="display:flex;justify-content:center"><table><tbody><tr><td style="font-weight:normal">2</td><td style="font-weight:normal">6</td><td style="font-weight:normal">1</td><td style="font-weight:normal">5</td><td style="font-weight:normal">3</td><td style="font-weight:normal">8</td><td style="font-weight:normal">9</td></tr></tbody></table></div><p>On recommence l&#x27;opération, mais en ignorant le dernier élément du tableau, car il est déjà trié.</p><p>Voilà les itérations suivantes:</p><ol><li><div style="display:flex;justify-content:center"><table><tbody><tr><td style="font-weight:normal">2</td><td style="font-weight:normal">1</td><td style="font-weight:normal">5</td><td style="font-weight:normal">3</td><td style="font-weight:normal">6</td><td style="font-weight:normal">8</td><td style="font-weight:normal">9</td></tr></tbody></table></div></li><li><div style="display:flex;justify-content:center"><table><tbody><tr><td style="font-weight:normal">1</td><td style="font-weight:normal">2</td><td style="font-weight:normal">3</td><td style="font-weight:normal">5</td><td style="font-weight:normal">6</td><td style="font-weight:normal">8</td><td style="font-weight:normal">9</td></tr></tbody></table></div></li><li>Dernier passage, aucun échange n&#x27;est effectué. Le tableau est trié.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="parlons-un-peu-de-complexité">Parlons un peu de complexité<a href="#parlons-un-peu-de-complexité" class="hash-link" aria-label="Lien direct vers Parlons un peu de complexité" title="Lien direct vers Parlons un peu de complexité">​</a></h2><p>La complexité d&#x27;un algorithme est une <strong>mesure</strong> de la quantité de ressources (temps, mémoire, etc) que celui-ci va utiliser pour s&#x27;exécuter.</p><p>En général, on s&#x27;intéresse à la complexité <strong>en fonction de la taille</strong> des données en entrée de l&#x27;algorithme.</p><p>Il existe plusieurs types de complexité, la plus souvent utilisée est la <strong>complexité en temps</strong>.</p><p>Cela revient à se poser la question:</p><p><strong>Si je donne à mon programme une entrée de taille <code>n</code>, quel est l&#x27;ordre de grandeur (en fonction de <code>n</code>) du nombre d&#x27;opérations qu&#x27;il va effectuer ?</strong></p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>remarque</div><div class="admonitionContent_S0QG"><p>La complexité permet de <strong>quantifier</strong> la relation entre les conditions de départ et le temps effectué par l&#x27;algorithme.</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="opérations-de-base">Opérations de base<a href="#opérations-de-base" class="hash-link" aria-label="Lien direct vers Opérations de base" title="Lien direct vers Opérations de base">​</a></h3><p>Pour &quot;compter les opérations&quot;, il faut décider de ce qu&#x27;est une <strong>opération</strong>. Ce choix dépend du problème (et même de l&#x27;algorithme) considéré. Il faut en fait choisir soi-même quelques petites opérations que l&#x27;algorithme effectue souvent, et que l&#x27;on veut utiliser comme opérations de base pour mesurer la complexité. Les opérations qui caractérise le mieux l&#x27;algorithme et <strong>représentent le mieux le temps d&#x27;exécution</strong> de celui-ci. Les opérations de base sont souvent les opérations <strong>arithmétiques</strong>, les <strong>comparaisons</strong>, les <strong>affectations</strong>, etc. Par exemple, pour un algorithme de tri, on va compter le nombre de <strong>comparaisons</strong> et d&#x27;<strong>échanges</strong> d&#x27;éléments du tableau.</p><p>En fonction des algorithmes, certaines opérations peuvent être plus significatives que d&#x27;autres. Par exemple, la multiplication est plus coûteuse que l&#x27;addition, on peut donc ne considérer que les opérations de multiplication pour mesurer la complexité d&#x27;un algorithme.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>On ne compte pas les opérations qui ne dépendent pas de la taille des données en entrée (comme l&#x27;initialisation de variables, etc).
Ces opérations sont considérées comme constantes et pas significatives pour la complexité en fonction de la taille des données en entrée.</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="notation-grand-o">Notation &quot;grand O&quot;<a href="#notation-grand-o" class="hash-link" aria-label="Lien direct vers Notation &quot;grand O&quot;" title="Lien direct vers Notation &quot;grand O&quot;">​</a></h3><p>On exprime la complexité en fonction de la taille des données en entrée avec la notation <strong>&quot;grand O&quot;</strong>.
La notation <strong>&quot;grand O&quot;</strong> est une notion mathématique qui permet d&#x27;exprimer un ordre de grandeur.</p><p>Par exemple, des algorithmes effectuant environ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> opérations, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">2n+20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">20</span></span></span></span> opérations ou <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> opérations ont tous la même complexité : on la note <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> (lire &quot;grand O de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span>&quot;). De même, un algorithme en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3n^2 + 4n + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">4</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span> opérations aura une complexité de <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> : on néglige les termes de plus faible degré (ici <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">4n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">4</span><span class="mord mathnormal">n</span></span></span></span> et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span>) et les coefficients (ici <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">3</span></span></span></span>).
On cherche seulement à savoir comment <strong>évolue</strong> le nombre d&#x27;opérations en fonction de la taille des données en entrée et on considère le terme de plus haut degré qui est celui qui va croître le plus vite en fonction de la taille des données en entrée.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="exemple-de-calcul-de-complexité">Exemple de calcul de complexité<a href="#exemple-de-calcul-de-complexité" class="hash-link" aria-label="Lien direct vers Exemple de calcul de complexité" title="Lien direct vers Exemple de calcul de complexité">​</a></h3><p>Prenons l&#x27;exemple du <strong>tri par sélection</strong>.</p><p>Pour trier un tableau de taille <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span>, premièrement on parcourt le tableau pour trouver le plus petit élément, on va donc effectuer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> comparaisons.</p><p>Ensuite, on va échanger cet élément avec le premier élément du tableau, on va donc effectuer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> échange.</p><p>Ensuite on va recommencer l&#x27;opération, mais en ignorant le premier élément du tableau, car il est déjà trié.</p><p>On va donc effectuer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> comparaisons et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> échange.</p><p>On va faire cela jusqu&#x27;à ce que le tableau soit trié, donc jusqu&#x27;à ce qu&#x27;il ne reste plus qu&#x27;un seul élément à trier.</p><p>Pour résumer, on va effectuer pour les différentes itérations:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> comparaisons et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> échange</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> comparaisons et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> échange</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">2</span></span></span></span> comparaisons et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> échange</li><li>...</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> comparaison et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> échange</li></ul><p>On peut donc calculer le nombre total de comparaisons et d&#x27;échanges effectués par l&#x27;algorithme:</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>n</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mfrac><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>n</mi></mrow><mn>2</mn></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}
= &amp; (n+1) + ((n-1)+1) + ((n-2)+1) + ... + (1+1) \\
= &amp; (n + (n-1) + \dots + 1) + (1 + \dots + 1) \\ 
= &amp; \frac{n(n+1)}{2} + n \\
= &amp; \frac{n^2 + 3n}{2} \\
\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:7.8901em;vertical-align:-3.6951em"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.1951em"><span style="top:-6.8462em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-5.3462em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-3.2592em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.7821em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.6951em"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.1951em"><span style="top:-6.8462em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mopen">((</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-5.3462em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.2592em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord mathnormal">n</span></span></span><span style="top:-0.7821em"><span class="pstrut" style="height:3.4911em"></span><span class="mord"><span class="mord"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord">3</span><span class="mord mathnormal">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.6951em"><span></span></span></span></span></span></span></span></span></span></span></span><p>Ici, j&#x27;ai compté de manière exacte le nombre d&#x27;<strong>opérations</strong> effectuées par l&#x27;algorithme, mais en général on s&#x27;intéresse à la complexité en fonction de la taille des données en entrée.</p><p>On va donc garder uniquement le terme de plus haut degré, ici <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>.</p><p><strong>On dit que la complexité du tri par sélection est en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</strong></p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>On peut aussi évaluer cette complexité sans calcul exact, mais plutôt en estimant le nombre d&#x27;opérations effectuées par l&#x27;algorithme.</p><p>On peut voir que l&#x27;algorithme doit à chaque itération parcourir le tableau, c&#x27;est ce qui va prendre le plus de temps et dépendra de la taille du tableau.</p><p>Chaque itération va permettre de trier <strong>un</strong> élément du tableau, donc on va effectuer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> itérations.</p><p>On peut donc estimer que la complexité du tri par sélection est en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times n) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="complexité-dans-le-pire-des-cas">Complexité dans le pire des cas<a href="#complexité-dans-le-pire-des-cas" class="hash-link" aria-label="Lien direct vers Complexité dans le pire des cas" title="Lien direct vers Complexité dans le pire des cas">​</a></h3><p>Le nombre d&#x27;opérations effectuées par un algorithme peut dépendre de la taille des données en entrée, mais aussi des données elles-mêmes.</p><p>Par exemple, dans le cadre d&#x27;un <strong>tri à bulles</strong>, si le tableau est déjà trié, on n&#x27;effectuera aucune opération d&#x27;échange, et seulement <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> comparaisons.</p><p>On peut donc dire que la complexité du tri à bulles est en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> dans le meilleur des cas.</p><p>Mais si le tableau est trié dans l&#x27;<strong>ordre inverse</strong>, on va effectuer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> comparaisons et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> échanges à chaque itération, et on va effectuer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span> itérations.</p><p>On peut donc dire que la complexité du <strong>tri à bulles</strong> est en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times n) = O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> dans le pire des cas.</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>remarque</div><div class="admonitionContent_S0QG"><p>C&#x27;est intéressant de considérer la complexité dans le pire des cas, car elle permet de savoir si l&#x27;algorithme est efficace pour toutes les données possibles. En général pour des données quelconques, c&#x27;est en général assez proche du comportement dans le pire des cas.</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="complexité-en-moyenne">Complexité en moyenne<a href="#complexité-en-moyenne" class="hash-link" aria-label="Lien direct vers Complexité en moyenne" title="Lien direct vers Complexité en moyenne">​</a></h3><p>On peut aussi s&#x27;intéresser à la complexité en <strong>moyenne</strong>, c&#x27;est-à-dire la complexité sur toutes les données possibles.</p><p>Par exemple, pour le <strong>tri à bulles</strong>, la complexité en moyenne est en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</p><p>Il existe des algorithmes qui ont une complexité en <strong>moyenne</strong> bien <strong>meilleure</strong> que leur complexité dans le <strong>pire des cas</strong>. Cela dépend du problème considéré et demande une analyse plus fine de l&#x27;algorithme.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="complexité-en-mémoire">Complexité en mémoire<a href="#complexité-en-mémoire" class="hash-link" aria-label="Lien direct vers Complexité en mémoire" title="Lien direct vers Complexité en mémoire">​</a></h3><p>On peut aussi s&#x27;intéresser à la complexité en <strong>mémoire</strong> d&#x27;un algorithme. Autrement dit, combien de mémoire va utiliser l&#x27;algorithme en fonction de la taille des données en entrée.</p><p>C&#x27;est aussi une mesure de la complexité tout aussi pertinente que la complexité en temps.</p><p>Si par exemple on a besoin de trier un tableau de 1000 éléments, on peut se dire que la complexité en temps n&#x27;est pas très importante, car l&#x27;algorithme va s&#x27;exécuter très rapidement. Mais si l&#x27;algorithme utilise <strong>beaucoup de mémoire</strong>, cela peut poser problème, car il peut ne <strong>pas avoir assez de mémoire disponible</strong> pour exécuter l&#x27;algorithme.</p><p>Dans la plupart des cas, la complexité en mémoire est beaucoup plus simple à calculer que la complexité en temps.</p><p>Mais dans des problèmes plus compliqués, la complexité en <strong>mémoire</strong> et la complexité en <strong>temps</strong> peuvent être <strong>liées</strong>.</p><p>On peut par exemple choisir de sacrifier un peu de rapidité d&#x27;exécution pour utiliser moins de mémoire, ou au contraire d&#x27;augmenter la vitesse en augmentant la complexité en mémoire de notre algorithme, par exemple en stockant dans un tableau les résultats déjà calculés (c&#x27;est le principe de la mise en cache, appelée aussi <em>memoization</em>).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="limitation-de-la-complexité">Limitation de la complexité<a href="#limitation-de-la-complexité" class="hash-link" aria-label="Lien direct vers Limitation de la complexité" title="Lien direct vers Limitation de la complexité">​</a></h3><p>La complexité d&#x27;un algorithme est donc une mesure d&#x27;<strong>ordre de grandeur</strong> en fonction de la taille des données en entrée.</p><p>Cependant, il est important de garder à l&#x27;esprit que la complexité ne permet pas de savoir si un algorithme est <strong>rapide</strong> ou <strong>lent</strong>.</p><p>Même si un algorithme à une complexité plus faible qu&#x27;un autre, il peut être plus (beaucoup plus) lent à s&#x27;exécuter qu&#x27;un autre algorithme pour des tailles de données en entrée faibles.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tri-diviser-pour-régner-divide-and-conquer-paradigm">Tri diviser pour régner (Divide-and-Conquer paradigm)<a href="#tri-diviser-pour-régner-divide-and-conquer-paradigm" class="hash-link" aria-label="Lien direct vers Tri diviser pour régner (Divide-and-Conquer paradigm)" title="Lien direct vers Tri diviser pour régner (Divide-and-Conquer paradigm)">​</a></h2><p>Il existe d&#x27;autres algorithmes de tri plus efficaces que les algorithmes de tri par <strong>comparaison</strong>. Ils sont basés sur le principe de <strong>diviser pour régner</strong> (divide and conquer en anglais). L&#x27;idée est de <strong>diviser</strong> le problème en sous-problèmes plus petits, de résoudre les sous-problèmes, puis de <strong>fusionner</strong> les solutions des sous-problèmes pour résoudre le problème initial.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tri-fusion-merge-sort">Tri fusion (merge sort)<a href="#tri-fusion-merge-sort" class="hash-link" aria-label="Lien direct vers Tri fusion (merge sort)" title="Lien direct vers Tri fusion (merge sort)">​</a></h3><p>Le tri fusion est un algorithme de tri qui consiste à <strong>diviser</strong> le tableau en deux parties égales, <strong>trier</strong> les deux parties, puis <strong>fusionner</strong> les deux parties triées.</p><p>Le tri fusion est un algorithme efficace, car il a une complexité en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>.</p><p>C&#x27;est un algorithme &quot;<strong>récursif</strong>&quot;, c&#x27;est-à-dire qu&#x27;il s&#x27;appelle lui-même pour trier deux sous-tableaux et les fusionner pour trier le tableau complet.</p><p>Il y a donc deux &quot;phases&quot; dans cet algorithme:</p><ul><li>la phase de <strong>division</strong> du tableau en deux parties égales</li><li>la phase de <strong>fusion</strong> des deux parties triées</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="phase-de-division">Phase de division<a href="#phase-de-division" class="hash-link" aria-label="Lien direct vers Phase de division" title="Lien direct vers Phase de division">​</a></h4><p>Il existe deux façons de procéder pour diviser le tableau en deux parties égales:</p><ul><li>Créer des <strong>tableaux intermédiaires</strong> pour stocker les deux parties du tableau à trier, puis fusionner les deux tableaux triés.</li><li>Utiliser des <strong>indices</strong> pour définir les parties du tableau à trier, et trier directement le tableau en place.</li></ul><p>La première méthode est plus simple à comprendre, mais utilise plus de mémoire, car il faut créer des tableaux intermédiaires.</p><p>On privilégie donc la deuxième méthode, et c&#x27;est celle que je vais détailler ici.</p><p>Pour trier un tableau, on va donc utiliser deux indices, un indice de <strong>début</strong> et un indice de <strong>fin</strong>, qui vont définir la <strong>partie du tableau</strong> à trier.</p><p>Par exemple, pour le tableau <code>[6, 2, 8, 1, 5, 3, 9]</code>, les indices <code>0</code> et <code>6</code> vont définir le tableau complet.
On va calculer la taille de la partie du tableau à trier, ici <code>6</code> (indice de fin) - <code>0</code> (indice de début) + <code>1</code> (car on compte l&#x27;élément à l&#x27;indice de fin), soit <code>7</code>.</p><p>On va ensuite diviser cette taille par deux, soit <code>3</code> (on peut arrondir à l&#x27;entier inférieur).</p><p>On va donc utiliser par récursion les indices <code>0</code> et <code>3</code> pour trier la première partie du tableau, et les indices <code>4</code> et <code>6</code> pour trier la deuxième partie du tableau.</p><p>Enfin la fusion des deux parties triées va permettre d&#x27;obtenir le tableau trié.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="phase-de-fusion">Phase de fusion<a href="#phase-de-fusion" class="hash-link" aria-label="Lien direct vers Phase de fusion" title="Lien direct vers Phase de fusion">​</a></h4><p>C&#x27;est la phase de <strong>fusion</strong> qui est la plus intéressante, car c&#x27;est elle qui va permettre de trier le tableau.</p><p>Pour fusionner deux tableaux triés, on va utiliser deux (autres) <strong>indices</strong>, un indice pour chaque tableau, qui vont permettre de parcourir les deux tableaux.</p><p>On va comparer les éléments des deux tableaux, et ajouter le plus petit des deux dans le tableau final.</p><p>On va incrémenter l&#x27;indice du tableau dont on a ajouté l&#x27;élément, et on recommence l&#x27;opération jusqu&#x27;à ce qu&#x27;on ait parcouru les deux tableaux.</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>attention</div><div class="admonitionContent_S0QG"><p>Il faut faire attention à ne pas dépasser la taille des sous-tableaux avec les indices, sinon on va avoir une erreur en essayant d&#x27;accéder à un élément qui n&#x27;existe pas.</p><p>Il faut donc vérifier que les indices sont bien inférieurs à la taille des sous-tableaux.</p><p>Si l&#x27;un des deux indices est égal à la taille du sous-tableau, cela veut dire qu&#x27;on a parcouru tout le sous-tableau, et qu&#x27;il ne reste plus qu&#x27;à ajouter les éléments du deuxième sous-tableau dans le tableau final.</p></div></div><p>On obtient ainsi un tableau trié.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>La <strong>condition d&#x27;arrêt</strong> de la récursion est quand la taille de la partie du tableau à trier est inférieure ou égale à <code>1</code>, car un tableau de taille <code>1</code> est déjà trié (de même pour un tableau vide).</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tri-rapide-quick-sort">Tri rapide (quick sort)<a href="#tri-rapide-quick-sort" class="hash-link" aria-label="Lien direct vers Tri rapide (quick sort)" title="Lien direct vers Tri rapide (quick sort)">​</a></h3><p>Le tri rapide est un algorithme de tri qui consiste à choisir un élément du tableau, appelé <strong>pivot</strong>, et à placer tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot.</p><p>On répète ensuite l&#x27;opération sur les deux sous-tableaux, jusqu&#x27;à ce que le tableau soit trié.</p><p>De la même manière que pour le tri fusion, c&#x27;est un algorithme <strong>récursif</strong> et on va donc utiliser des indices pour définir les parties du tableau à trier.</p><p>Il y a également deux phases dans cet algorithme:</p><ul><li>la phase de <strong>division</strong> du tableau en deux parties en fonction du pivot</li><li>la phase de <strong>tri</strong> des deux parties</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="phase-de-division-1">Phase de division<a href="#phase-de-division-1" class="hash-link" aria-label="Lien direct vers Phase de division" title="Lien direct vers Phase de division">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="choix-du-pivot">Choix du pivot<a href="#choix-du-pivot" class="hash-link" aria-label="Lien direct vers Choix du pivot" title="Lien direct vers Choix du pivot">​</a></h5><p>Le choix du pivot est très important, car il va déterminer la complexité de l&#x27;algorithme.</p><p>Si on choisit un pivot qui est toujours le plus petit élément du tableau, on va avoir une complexité en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, car on va devoir parcourir tout le tableau à chaque itération (de même si on choisit le plus grand élément du tableau).</p><p>Il existe plusieurs méthodes pour choisir le pivot, la plus simple est de choisir le premier élément du tableau. Mais cela peut être problématique si le tableau est déjà trié car on va diviser le tableau en deux parties de tailles très différentes.</p><div class="theme-admonition theme-admonition-info alert alert--info admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</div><div class="admonitionContent_S0QG"><p>L&#x27;idéal est de choisir un pivot qui est proche de la valeur médiane du tableau, c&#x27;est-à-dire qui va diviser le tableau en deux parties égales.</p><p>Il existe plusieurs méthodes pour choisir un pivot proche de la valeur médiane du tableau, mais elles sont plus compliquées à mettre en oeuvre.</p></div></div><p>Nous allons préférer choisir un pivot aléatoire ou plus simplement l&#x27;élément au milieu du sous-tableau considéré pour minimiser les risques de cas défavorables.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="partitionnement">Partitionnement<a href="#partitionnement" class="hash-link" aria-label="Lien direct vers Partitionnement" title="Lien direct vers Partitionnement">​</a></h4><p>Une fois le pivot choisi, on va parcourir le tableau et placer tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot.</p><p>Il y a plusieurs approches pour gérer le pivot, dans notre cas, on va choisir de premièrement placer le pivot à la fin du tableau.</p><p>Pour cela, on va utiliser <strong>deux indices</strong>, un indice pour parcourir le tableau de gauche à droite, et un indice pour parcourir le tableau de droite à gauche.</p><p>On va <strong>incrémenter</strong> l&#x27;indice de <strong>gauche</strong> tant que l&#x27;élément est <strong>plus petit</strong> que le pivot, et on va <strong>décrémenter</strong> l&#x27;indice de <strong>droite</strong> tant que l&#x27;élément est <strong>plus grand</strong> que le pivot.</p><p>Si l&#x27;indice de gauche est inférieur à l&#x27;indice de droite, on va <strong>échanger</strong> les deux éléments et on recommence l&#x27;opération.</p><p>Une fois que les deux indices se sont croisés, on sait que tous les éléments plus petits que le pivot sont à gauche du pivot, et tous les éléments plus grands que le pivot sont à droite du pivot.</p><p>Enfin, on va <strong>échanger</strong> le pivot avec l&#x27;élément à l&#x27;indice de gauche (l&#x27;indice pointant sur le premier élément plus grand que le pivot) pour que le pivot soit à sa place définitive.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="récursion">Récursion<a href="#récursion" class="hash-link" aria-label="Lien direct vers Récursion" title="Lien direct vers Récursion">​</a></h4><p>On obtient ainsi un tableau avec le pivot à sa place définitive, et tous les éléments plus petits que le pivot à gauche du pivot, et tous les éléments plus grands que le pivot à droite du pivot et on connaît l&#x27;indice du pivot.</p><p>On va donc pouvoir appeler récursivement l&#x27;algorithme sur les deux sous-tableaux, en ignorant le pivot.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tri-par-dénombrement-counting-sort">Tri par dénombrement (counting sort)<a href="#tri-par-dénombrement-counting-sort" class="hash-link" aria-label="Lien direct vers Tri par dénombrement (counting sort)" title="Lien direct vers Tri par dénombrement (counting sort)">​</a></h2><p>IL existe encore d&#x27;autres algorithmes de tri, mais ils sont plus spécifiques et ne fonctionnent que dans certains cas. Je vais en présenter un simple ici pour te donner une idée de ce qui existe.</p><p>Le tri par <strong>dénombrement</strong> (ou <strong>counting sort</strong> en anglais) est très efficace, car il va permettre de trier un tableau en complexité <strong>linéaire</strong>, c&#x27;est-à-dire en <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>. Il ne fonctionne cependant que pour des données <strong>entières</strong> car il ne se base pas sur des comparaisons mais va compter le nombre d&#x27;occurrences de chaque valeur (de plus pour simplifier, on va supposer que les valeurs sont positives).</p><p>Le <strong>prérequis</strong> pour utiliser cet algorithme est donc de connaître la valeur <strong>maximale</strong> des données à trier. Soit on connaît cette valeur à l&#x27;avance, soit on peut la calculer en parcourant le tableau une première fois.</p><p>L&#x27;algorithme consiste à compter le nombre d&#x27;occurrences de chaque valeur dans le tableau, puis à reconstruire le tableau en plaçant les valeurs dans l&#x27;ordre.</p><p>Par exemple, si on se fixe des valeurs entières entre 0 et 9, on peut trier le tableau suivant <code>[1, 4, 1, 2, 7, 5, 2]</code> en procédant ainsi:</p><ol><li>On parcourt le tableau pour compter le nombre d&#x27;occurrences de chaque valeur.</li></ol><table><thead><tr><th>valeur</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>nombre d&#x27;occurrences</td><td>0</td><td>2</td><td>2</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><ol start="2"><li>On reconstruit le tableau en parcourant le tableau des occurrences et en ajoutant les valeurs dans l&#x27;ordre.</li></ol><ul><li>On ajoute 2 fois la valeur <code>1</code></li><li>On ajoute 2 fois la valeur <code>2</code></li><li>...</li></ul><p>On obtient ainsi le tableau trié <code>[1, 1, 2, 2, 4, 5, 7]</code>.</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>attention</div><div class="admonitionContent_S0QG"><p>On remarque qu&#x27;il faut pouvoir stocker le nombre d&#x27;occurrences de chaque valeur, donc un tableau de taille 10 dans notre exemple.
Il faut donc un tableau de taille <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span></span></span></span> pour trier des données comprises entre 0 et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> ce qui augmente la complexité en <strong>mémoire</strong> de l&#x27;algorithme.</p><p>C&#x27;est à prendre en compte si on veut utiliser cet algorithme car il peut être très efficace en temps, mais peut aussi utiliser beaucoup de mémoire si les valeurs sont très grandes.</p><p><strong>C&#x27;est un algorithme à utiliser seulement dans le cas où on connaît la valeur maximale des données à trier et que cette valeur est raisonnable.</strong></p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pour-aller-plus-loin">Pour aller plus loin:<a href="#pour-aller-plus-loin" class="hash-link" aria-label="Lien direct vers Pour aller plus loin:" title="Lien direct vers Pour aller plus loin:">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tri-par-dénombrement-stable">Tri par dénombrement stable<a href="#tri-par-dénombrement-stable" class="hash-link" aria-label="Lien direct vers Tri par dénombrement stable" title="Lien direct vers Tri par dénombrement stable">​</a></h3><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Details</summary><div><div class="collapsibleContent_i85q"><p>On peut améliorer le tri par dénombrement en le rendant <strong>stable</strong>. Cela signifie que si deux éléments ont la même valeur, ils seront dans le même ordre dans le tableau trié que dans le tableau initial. Cela ne semble pas très important à première vue, mais cela permet de trier des données plus complexes en leur associant des valeurs entières sur lesquelles on va effectuer le tri.</p><p>Pour faire cela il faut modifier légèrement l&#x27;algorithme de tri par dénombrement.</p><p>Une fois qu&#x27;on a compté le nombre d&#x27;occurrences de chaque valeur, on va calculer la somme partielle des occurrences de chaque valeur. Cela va nous permettre de connaître la position de chaque valeur dans le tableau trié.</p><p>Par exemple, avec le tableau suivant <code>[1, 4, 1, 2, 7, 5, 2]</code> contenant des valeurs entières entre 0 et 9:</p><ul><li>On compte le nombre d&#x27;occurrences de chaque valeur : <code>[0, 2, 2, 0, 1, 1, 0, 1, 0, 0]</code></li><li>On calcule la <strong>somme partielle</strong> des occurrences de chaque valeur : <code>[0, 2, 4, 4, 5, 6, 6, 7, 7, 7]</code></li></ul><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>remarque</div><div class="admonitionContent_S0QG"><p>On peut se resservir du tableau des occurrences pour stocker la somme partielle des occurrences de chaque valeur, ce qui permet de ne pas utiliser de tableau intermédiaire supplémentaire.</p></div></div><p>On va construire un nouveau tableau de même taille que le tableau initial, en parcourant le tableau initial pour ajouter les valeurs dans le nouveau tableau. On va ajouter la valeur à la position indiquée par la somme partielle des occurrences de la valeur, puis on va décrémenter la somme partielle des occurrences de la valeur.</p><p>Par exemple, pour la valeur <code>1</code>, on va ajouter la valeur <code>1</code> à la position <code>2</code> du nouveau tableau, puis on va décrémenter la somme partielle des occurrences de la valeur <code>1</code> pour obtenir <code>1</code> (car il reste une occurrence de la valeur <code>1</code>).</p><p>On obtient ainsi le tableau trié <code>[1, 1, 2, 2, 4, 5, 7]</code>.</p><p>L&#x27;inconvénient principal de cette méthode est qu&#x27;il faut un tableau intermédiaire pour stocker le tableau trié, ce qui augmente la complexité en mémoire de l&#x27;algorithme.</p></div></div></details><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tri-par-base-radix-sort">Tri par base (radix sort)<a href="#tri-par-base-radix-sort" class="hash-link" aria-label="Lien direct vers Tri par base (radix sort)" title="Lien direct vers Tri par base (radix sort)">​</a></h3><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Details</summary><div><div class="collapsibleContent_i85q"><p>Le tri par dénombrement permet de trier des données entières comprises entre 0 et <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.03148em">k</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> en complexité linéaire.</p><p>On va se servir de cet algorithme pour trier des données plus complexes, en associant à chaque donnée une valeur entière sur laquelle on va effectuer le tri (d&#x27;où l&#x27;intérêt de rendre le tri par dénombrement stable).</p><p>On va considérer un tri de nombres entiers, mais cela peut s&#x27;appliquer à d&#x27;autres types de données.</p><p>Un nombre entier peut être représenté en base <code>10</code>, c&#x27;est-à-dire en utilisant les chiffres de <code>0</code> à <code>9</code>.</p><p>Par exemple, le nombre <code>123</code> peut être représenté en base <code>10</code> par la suite de chiffres <code>1</code>, <code>2</code> et <code>3</code>.</p><p>On va donc pouvoir trier des nombres entiers en triant les chiffres de leur représentation en base <code>10</code>.</p><p>Par exemple, pour trier les nombres <code>[123, 456, 789, 321, 654, 987]</code>, on va trier les chiffres des nombres, en commençant par les centaines, puis les dizaines et enfin les unités.</p><p>Cela permet de trier les nombres en complexité linéaire grâce au tri par dénombrement.</p><p>Dans notre exemple, le nombre le plus grand est <code>987</code>, il a donc <code>3</code> chiffres, on va donc effectuer <code>3</code> itérations de tri par dénombrement pour trier les nombres.</p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>remarque</div><div class="admonitionContent_S0QG"><p>Cette information peut être connue à l&#x27;avance, mais on peut aussi la calculer en parcourant le tableau une première fois.</p></div></div><ol><li>On trie les centaines ce qui donne <code>[123, 321, 456, 654, 789, 987]</code></li><li>On trie les dizaines ce qui donne <code>[123, 321, 456, 654, 789, 987]</code></li><li>enfin, on trie les unités ce qui donne <code>[123, 321, 456, 654, 789, 987]</code></li></ol></div></div></details><h2 class="anchor anchorWithStickyNavbar_LWe7" id="recherche-dichotomique">Recherche dichotomique<a href="#recherche-dichotomique" class="hash-link" aria-label="Lien direct vers Recherche dichotomique" title="Lien direct vers Recherche dichotomique">​</a></h2><p>Avoir un tableau trié est très utile pour effectuer des recherches dans un tableau.</p><p>Par exemple, si on veut savoir si une valeur est présente dans un tableau, on peut parcourir le tableau et comparer chaque élément avec la valeur recherchée.</p><p>Mais si le tableau est trié, on peut utiliser une méthode plus efficace: la <strong>recherche dichotomique</strong>.</p><p>La <strong>recherche dichotomique</strong> consiste à diviser le tableau en deux parties égales et à ne garder que la partie qui contient la valeur recherchée. On répète l&#x27;opération jusqu&#x27;à trouver la valeur ou jusqu&#x27;à ce qu&#x27;il ne reste plus qu&#x27;un seul élément dans le tableau.</p><p>Exemple simple avec le tableau suivant <code>[1, 2, 2, 4, 5, 8, 12]</code> (nombre d&#x27;éléments: 7) et la valeur recherchée <code>8</code>:</p><ol><li><p>On calcule l&#x27;indice du milieu du tableau, soit <code>3</code>.</p><p>On compare la valeur à l&#x27;indice <code>3</code> avec la valeur recherchée <code>8</code>, comme <code>4</code> est plus petit que <code>8</code>, on ne garde que la partie du tableau qui contient la valeur recherchée, c&#x27;est-à-dire la partie du tableau à partir de l&#x27;indice <code>4</code> (indice de début: <code>4</code>, indice de fin: <code>6</code>).</p><p>On recommence l&#x27;opération avec la partie du tableau restante.</p></li><li><p>Sous partie du tableau: <code>[5, 8, 12]</code> (nombre d&#x27;éléments: 3), indice du milieu: <code>5</code>.</p><p>On compare la valeur à l&#x27;indice <code>5</code> avec la valeur recherchée <code>8</code>, comme <code>8</code> est égal à <code>8</code>, on a trouvé la valeur recherchée.</p><p>On peut donc s&#x27;arrêter et renvoyer l&#x27;indice <code>5</code>.</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="résumé">Résumé<a href="#résumé" class="hash-link" aria-label="Lien direct vers Résumé" title="Lien direct vers Résumé">​</a></h2><ul><li>Les <strong>algorithmes de tri</strong> sont très importants en informatique, car ils permettent de trier des données, ce qui est une opération très courante.</li><li>La complexité d&#x27;un algorithme est une <strong>mesure</strong> de la quantité de ressources (<strong>temps</strong>, <strong>mémoire</strong>, etc) que celui-ci va utiliser pour s&#x27;exécuter.</li><li>La <strong>complexité en temps</strong> permet de <strong>quantifier</strong> la relation entre les <strong>conditions de départ</strong> (<strong>nombre d&#x27;éléments</strong> du tableau, valeurs des éléments, etc) et le <strong>temps</strong> effectué par l&#x27;algorithme.</li><li>La <strong>complexité</strong> permet de <strong>comparer</strong> plusieurs algorithmes entre eux mais ne permet pas de savoir si un algorithme est <strong>rapide</strong> ou <strong>lent</strong>.</li><li>Nous avons vu les algorithmes de tri suivants:<ul><li><strong>Tri par sélection</strong> (selection sort): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><blockquote><p>C&#x27;est un algorithme qui fonctionne par <strong>recherche successive</strong> du plus petit élément du tableau.</p></blockquote></li><li><strong>Tri à bulles</strong> (bubble sort): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><blockquote><p>C&#x27;est un algorithme qui fonctionne par <strong>comparaison successive</strong> de deux éléments consécutifs du tableau.</p></blockquote></li><li><strong>Tri fusion</strong> (merge sort): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span><blockquote><p>C&#x27;est un algorithme qui fonctionne par récursion en <strong>divisant</strong> le tableau en deux parties égales, en triant les deux parties, puis en <strong>fusionnant</strong> les deux parties triées.</p></blockquote></li><li><strong>Tri rapide</strong> (quick sort): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span><blockquote><p>C&#x27;est un algorithme qui fonctionne par récursion en choisissant un <strong>pivot</strong>, en divisant le tableau en deux parties en fonction du pivot, puis en triant les deux parties.</p></blockquote></li><li><strong>Tri par dénombrement</strong> (counting sort): <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><blockquote><p>C&#x27;est un algorithme qui fonctionne en comptant le nombre d&#x27;occurrences de chaque valeur, puis en reconstruisant le tableau en plaçant les valeurs dans l&#x27;ordre.
C&#x27;est un algorithme qui ne fonctionne que pour des données <strong>entières</strong> et où la valeur maximale des données est connue à l&#x27;avance et relativement petite.</p></blockquote></li></ul></li><li>La <strong>recherche dichotomique</strong> est une méthode de recherche dans un tableau trié qui consiste à diviser le tableau en deux parties égales et à ne garder que la partie qui contient la valeur recherchée. On répète l&#x27;opération jusqu&#x27;à trouver la valeur souhaitée.</li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags :</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/Learn--cpp_programming/tags/c">C++</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Pages de documentation"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#tri-par-comparaison" class="table-of-contents__link toc-highlight">Tri par comparaison</a><ul><li><a href="#tri-par-sélection-selection-sort" class="table-of-contents__link toc-highlight">Tri par sélection (selection sort)</a></li><li><a href="#tri-à-bulles-bubble-sort" class="table-of-contents__link toc-highlight">Tri à bulles (bubble sort)</a></li></ul></li><li><a href="#parlons-un-peu-de-complexité" class="table-of-contents__link toc-highlight">Parlons un peu de complexité</a><ul><li><a href="#opérations-de-base" class="table-of-contents__link toc-highlight">Opérations de base</a></li><li><a href="#notation-grand-o" class="table-of-contents__link toc-highlight">Notation &quot;grand O&quot;</a></li><li><a href="#exemple-de-calcul-de-complexité" class="table-of-contents__link toc-highlight">Exemple de calcul de complexité</a></li><li><a href="#complexité-dans-le-pire-des-cas" class="table-of-contents__link toc-highlight">Complexité dans le pire des cas</a></li><li><a href="#complexité-en-moyenne" class="table-of-contents__link toc-highlight">Complexité en moyenne</a></li><li><a href="#complexité-en-mémoire" class="table-of-contents__link toc-highlight">Complexité en mémoire</a></li><li><a href="#limitation-de-la-complexité" class="table-of-contents__link toc-highlight">Limitation de la complexité</a></li></ul></li><li><a href="#tri-diviser-pour-régner-divide-and-conquer-paradigm" class="table-of-contents__link toc-highlight">Tri diviser pour régner (Divide-and-Conquer paradigm)</a><ul><li><a href="#tri-fusion-merge-sort" class="table-of-contents__link toc-highlight">Tri fusion (merge sort)</a></li><li><a href="#tri-rapide-quick-sort" class="table-of-contents__link toc-highlight">Tri rapide (quick sort)</a></li></ul></li><li><a href="#tri-par-dénombrement-counting-sort" class="table-of-contents__link toc-highlight">Tri par dénombrement (counting sort)</a></li><li><a href="#pour-aller-plus-loin" class="table-of-contents__link toc-highlight">Pour aller plus loin:</a><ul><li><a href="#tri-par-dénombrement-stable" class="table-of-contents__link toc-highlight">Tri par dénombrement stable</a></li><li><a href="#tri-par-base-radix-sort" class="table-of-contents__link toc-highlight">Tri par base (radix sort)</a></li></ul></li><li><a href="#recherche-dichotomique" class="table-of-contents__link toc-highlight">Recherche dichotomique</a></li><li><a href="#résumé" class="table-of-contents__link toc-highlight">Résumé</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__links text--center"><div class="footer__links"><span class="footer__link-item">
              <a href="https://discord.com/users/264442459759706112" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/discord.svg"> Discord
              </a>
              </span><span class="footer__link-separator">·</span><a href="mailto:desmet.enguerrand@gmail.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">E-Mail</a><span class="footer__link-separator">·</span><span class="footer__link-item">
              <a href="https://github.com/dsmtE" class="footer__link-item">
                <img src="https://api.iconify.design/skill-icons/github-dark.svg"> GitHub
              </a>
              </span></div></div><div class="footer__bottom text--center"><div class="footer__copyright">These lessons were written by <a href="https://github.com/dsmtE">DE SMET Enguerrand</a>.<br>Copyright © 2023. Built with <a href="https://docusaurus.io/">Docusaurus</a>.</div></div></div></footer> </div>
<script src="/Learn--cpp_programming/assets/js/runtime~main.90eb01f1.js"></script>
<script src="/Learn--cpp_programming/assets/js/main.be813725.js"></script>
</body>
</html>